import{D as K,N as B,U as $,M,e as S,Q as v,z as F,p as g,j as D,d as L,l as E,B as k,h as W,_ as A}from"./use-locale-context-cwTY9VYn-REDUMe7F.js";var N=new WeakMap,T=new WeakMap,x={},I=0,P=e=>e&&(e.host||P(e.parentNode)),j=(e,i)=>i.map(a=>{if(e.contains(a))return a;const t=P(a);return t&&e.contains(t)?t:(console.error("[zag-js > ariaHidden] target",a,"in not contained inside",e,". Doing nothing"),null)}).filter(a=>!!a),z=new Set(["script","output","status","next-route-announcer"]),U=e=>z.has(e.localName)||e.role==="status"||e.hasAttribute("aria-live")?!0:e.matches("[data-live-announcer]"),_=(e,i)=>{const{parentNode:a,markerName:t,controlAttribute:s}=i,o=j(a,Array.isArray(e)?e:[e]);x[t]||(x[t]=new WeakMap);const n=x[t],l=[],u=new Set,r=new Set(o),d=c=>{!c||u.has(c)||(u.add(c),d(c.parentNode))};o.forEach(d);const b=c=>{!c||r.has(c)||Array.prototype.forEach.call(c.children,p=>{if(u.has(p))b(p);else try{if(U(p))return;const f=p.getAttribute(s)==="true",O=(N.get(p)||0)+1,m=(n.get(p)||0)+1;N.set(p,O),n.set(p,m),l.push(p),O===1&&f&&T.set(p,!0),m===1&&p.setAttribute(t,""),f||p.setAttribute(s,"true")}catch(f){console.error("[zag-js > ariaHidden] cannot operate on ",p,f)}})};return b(a),u.clear(),I++,()=>{l.forEach(c=>{const p=N.get(c)-1,f=n.get(c)-1;N.set(c,p),n.set(c,f),p||(T.has(c)||c.removeAttribute(s),T.delete(c)),f||c.removeAttribute(t)}),I--,I||(N=new WeakMap,N=new WeakMap,T=new WeakMap,x={})}},V=e=>(Array.isArray(e)?e[0]:e).ownerDocument.body,Y=(e,i=V(e),a="data-aria-hidden")=>{if(i)return _(e,{parentNode:i,markerName:a,controlAttribute:"aria-hidden"})},q=e=>{const i=requestAnimationFrame(()=>e());return()=>cancelAnimationFrame(i)};function it(e,i={}){const{defer:a=!0}=i,t=a?q:o=>o(),s=[];return s.push(t(()=>{const o=(typeof e=="function"?e():e).filter(Boolean);o.length!==0&&s.push(Y(o))})),()=>{s.forEach(o=>o==null?void 0:o())}}var H=Object.defineProperty,Q=(e,i,a)=>i in e?H(e,i,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[i]=a,h=(e,i,a)=>Q(e,typeof i!="symbol"?i+"":i,a),G={activateTrap(e,i){if(e.length>0){const t=e[e.length-1];t!==i&&t.pause()}const a=e.indexOf(i);a===-1||e.splice(a,1),e.push(i)},deactivateTrap(e,i){const a=e.indexOf(i);a!==-1&&e.splice(a,1),e.length>0&&e[e.length-1].unpause()}},X=[],J=class{constructor(e,i){h(this,"trapStack"),h(this,"config"),h(this,"doc"),h(this,"state",{containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:!1,paused:!1,delayInitialFocusTimer:void 0,recentNavEvent:void 0}),h(this,"listenerCleanups",[]),h(this,"handleFocus",t=>{const s=k(t),o=this.findContainerIndex(s,t)>=0;if(o||W(s))o&&(this.state.mostRecentlyFocusedNode=s);else{t.stopImmediatePropagation();let n,l=!0;if(this.state.mostRecentlyFocusedNode)if(F(this.state.mostRecentlyFocusedNode)>0){const u=this.findContainerIndex(this.state.mostRecentlyFocusedNode),{tabbableNodes:r}=this.state.containerGroups[u];if(r.length>0){const d=r.findIndex(b=>b===this.state.mostRecentlyFocusedNode);d>=0&&(this.config.isKeyForward(this.state.recentNavEvent)?d+1<r.length&&(n=r[d+1],l=!1):d-1>=0&&(n=r[d-1],l=!1))}}else this.state.containerGroups.some(u=>u.tabbableNodes.some(r=>F(r)>0))||(l=!1);else l=!1;l&&(n=this.findNextNavNode({target:this.state.mostRecentlyFocusedNode,isBackward:this.config.isKeyBackward(this.state.recentNavEvent)})),n?this.tryFocus(n):this.tryFocus(this.state.mostRecentlyFocusedNode||this.getInitialFocusNode())}this.state.recentNavEvent=void 0}),h(this,"handlePointerDown",t=>{const s=k(t);if(!(this.findContainerIndex(s,t)>=0)){if(w(this.config.clickOutsideDeactivates,t)){this.deactivate({returnFocus:this.config.returnFocusOnDeactivate});return}w(this.config.allowOutsideClick,t)||t.preventDefault()}}),h(this,"handleClick",t=>{const s=k(t);this.findContainerIndex(s,t)>=0||w(this.config.clickOutsideDeactivates,t)||w(this.config.allowOutsideClick,t)||(t.preventDefault(),t.stopImmediatePropagation())}),h(this,"handleTabKey",t=>{if(this.config.isKeyForward(t)||this.config.isKeyBackward(t)){this.state.recentNavEvent=t;const s=this.config.isKeyBackward(t),o=this.findNextNavNode({event:t,isBackward:s});if(!o)return;y(t)&&t.preventDefault(),this.tryFocus(o)}}),h(this,"handleEscapeKey",t=>{Z(t)&&w(this.config.escapeDeactivates,t)!==!1&&(t.preventDefault(),this.deactivate())}),h(this,"_mutationObserver"),h(this,"setupMutationObserver",()=>{const t=this.doc.defaultView||window;this._mutationObserver=new t.MutationObserver(s=>{s.some(o=>Array.from(o.removedNodes).some(n=>n===this.state.mostRecentlyFocusedNode))&&this.tryFocus(this.getInitialFocusNode())})}),h(this,"updateObservedNodes",()=>{var t;(t=this._mutationObserver)==null||t.disconnect(),this.state.active&&!this.state.paused&&this.state.containers.map(s=>{var o;(o=this._mutationObserver)==null||o.observe(s,{subtree:!0,childList:!0})})}),h(this,"getInitialFocusNode",()=>{let t=this.getNodeForOption("initialFocus",{hasFallback:!0});if(t===!1)return!1;if(t===void 0||t&&!A(t)){const s=D(this.doc);if(s&&this.findContainerIndex(s)>=0)t=s;else{const o=this.state.tabbableGroups[0];t=o&&o.firstTabbableNode||this.getNodeForOption("fallbackFocus")}}else t===null&&(t=this.getNodeForOption("fallbackFocus"));if(!t)throw new Error("Your focus-trap needs to have at least one focusable element");return t.isConnected||(t=this.getNodeForOption("fallbackFocus")),t}),h(this,"tryFocus",t=>{if(t!==!1&&t!==D(this.doc)){if(!t||!t.focus){this.tryFocus(this.getInitialFocusNode());return}t.focus({preventScroll:!!this.config.preventScroll}),this.state.mostRecentlyFocusedNode=t,tt(t)&&t.select()}}),h(this,"deactivate",t=>{if(!this.state.active)return this;const s={onDeactivate:this.config.onDeactivate,onPostDeactivate:this.config.onPostDeactivate,checkCanReturnFocus:this.config.checkCanReturnFocus,...t};clearTimeout(this.state.delayInitialFocusTimer),this.state.delayInitialFocusTimer=void 0,this.removeListeners(),this.state.active=!1,this.state.paused=!1,this.updateObservedNodes(),G.deactivateTrap(this.trapStack,this);const o=this.getOption(s,"onDeactivate"),n=this.getOption(s,"onPostDeactivate"),l=this.getOption(s,"checkCanReturnFocus"),u=this.getOption(s,"returnFocus","returnFocusOnDeactivate");o==null||o();const r=()=>{R(()=>{if(u){const d=this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);this.tryFocus(d)}n==null||n()})};if(u&&l){const d=this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);return l(d).then(r,r),this}return r(),this}),h(this,"pause",t=>{if(this.state.paused||!this.state.active)return this;const s=this.getOption(t,"onPause"),o=this.getOption(t,"onPostPause");return this.state.paused=!0,s==null||s(),this.removeListeners(),this.updateObservedNodes(),o==null||o(),this}),h(this,"unpause",t=>{if(!this.state.paused||!this.state.active)return this;const s=this.getOption(t,"onUnpause"),o=this.getOption(t,"onPostUnpause");return this.state.paused=!1,s==null||s(),this.updateTabbableNodes(),this.addListeners(),this.updateObservedNodes(),o==null||o(),this}),h(this,"updateContainerElements",t=>(this.state.containers=Array.isArray(t)?t.filter(Boolean):[t].filter(Boolean),this.state.active&&this.updateTabbableNodes(),this.updateObservedNodes(),this)),h(this,"getReturnFocusNode",t=>{const s=this.getNodeForOption("setReturnFocus",{params:[t]});return s||(s===!1?!1:t)}),h(this,"getOption",(t,s,o)=>t&&t[s]!==void 0?t[s]:this.config[o||s]),h(this,"getNodeForOption",(t,{hasFallback:s=!1,params:o=[]}={})=>{let n=this.config[t];if(typeof n=="function"&&(n=n(...o)),n===!0&&(n=void 0),!n){if(n===void 0||n===!1)return n;throw new Error(`\`${t}\` was specified but was not a node, or did not return a node`)}let l=n;if(typeof n=="string"){try{l=this.doc.querySelector(n)}catch(u){throw new Error(`\`${t}\` appears to be an invalid selector; error="${u.message}"`)}if(!l&&!s)throw new Error(`\`${t}\` as selector refers to no known node`)}return l}),h(this,"findNextNavNode",t=>{const{event:s,isBackward:o=!1}=t,n=t.target||k(s);this.updateTabbableNodes();let l=null;if(this.state.tabbableGroups.length>0){const u=this.findContainerIndex(n,s),r=u>=0?this.state.containerGroups[u]:void 0;if(u<0)o?l=this.state.tabbableGroups[this.state.tabbableGroups.length-1].lastTabbableNode:l=this.state.tabbableGroups[0].firstTabbableNode;else if(o){let d=this.state.tabbableGroups.findIndex(({firstTabbableNode:b})=>n===b);if(d<0&&((r==null?void 0:r.container)===n||A(n)&&!v(n)&&!(r!=null&&r.nextTabbableNode(n,!1)))&&(d=u),d>=0){const b=d===0?this.state.tabbableGroups.length-1:d-1,c=this.state.tabbableGroups[b];l=F(n)>=0?c.lastTabbableNode:c.lastDomTabbableNode}else y(s)||(l=r==null?void 0:r.nextTabbableNode(n,!1))}else{let d=this.state.tabbableGroups.findIndex(({lastTabbableNode:b})=>n===b);if(d<0&&((r==null?void 0:r.container)===n||A(n)&&!v(n)&&!(r!=null&&r.nextTabbableNode(n)))&&(d=u),d>=0){const b=d===this.state.tabbableGroups.length-1?0:d+1,c=this.state.tabbableGroups[b];l=F(n)>=0?c.firstTabbableNode:c.firstDomTabbableNode}else y(s)||(l=r==null?void 0:r.nextTabbableNode(n))}}else l=this.getNodeForOption("fallbackFocus");return l}),this.trapStack=i.trapStack||X;const a={returnFocusOnDeactivate:!0,escapeDeactivates:!0,delayInitialFocus:!0,isKeyForward(t){return y(t)&&!t.shiftKey},isKeyBackward(t){return y(t)&&t.shiftKey},...i};this.doc=a.document||B(Array.isArray(e)?e[0]:e),this.config=a,this.updateContainerElements(e),this.setupMutationObserver()}get active(){return this.state.active}get paused(){return this.state.paused}findContainerIndex(e,i){const a=typeof(i==null?void 0:i.composedPath)=="function"?i.composedPath():void 0;return this.state.containerGroups.findIndex(({container:t,tabbableNodes:s})=>t.contains(e)||(a==null?void 0:a.includes(t))||s.find(o=>o===e))}updateTabbableNodes(){if(this.state.containerGroups=this.state.containers.map(e=>{const i=M(e),a=S(e),t=i.length>0?i[0]:void 0,s=i.length>0?i[i.length-1]:void 0,o=a.find(r=>v(r)),n=a.slice().reverse().find(r=>v(r)),l=!!i.find(r=>F(r)>0);function u(r,d=!0){const b=i.indexOf(r);return b<0?d?a.slice(a.indexOf(r)+1).find(c=>v(c)):a.slice(0,a.indexOf(r)).reverse().find(c=>v(c)):i[b+(d?1:-1)]}return{container:e,tabbableNodes:i,focusableNodes:a,posTabIndexesFound:l,firstTabbableNode:t,lastTabbableNode:s,firstDomTabbableNode:o,lastDomTabbableNode:n,nextTabbableNode:u}}),this.state.tabbableGroups=this.state.containerGroups.filter(e=>e.tabbableNodes.length>0),this.state.tabbableGroups.length<=0&&!this.getNodeForOption("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");if(this.state.containerGroups.find(e=>e.posTabIndexesFound)&&this.state.containerGroups.length>1)throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.")}addListeners(){if(this.state.active)return G.activateTrap(this.trapStack,this),this.state.delayInitialFocusTimer=this.config.delayInitialFocus?R(()=>{this.tryFocus(this.getInitialFocusNode())}):this.tryFocus(this.getInitialFocusNode()),this.listenerCleanups.push(g(this.doc,"focusin",this.handleFocus,!0),g(this.doc,"mousedown",this.handlePointerDown,{capture:!0,passive:!1}),g(this.doc,"touchstart",this.handlePointerDown,{capture:!0,passive:!1}),g(this.doc,"click",this.handleClick,{capture:!0,passive:!1}),g(this.doc,"keydown",this.handleTabKey,{capture:!0,passive:!1}),g(this.doc,"keydown",this.handleEscapeKey)),this}removeListeners(){if(this.state.active)return this.listenerCleanups.forEach(e=>e()),this.listenerCleanups=[],this}activate(e){if(this.state.active)return this;const i=this.getOption(e,"onActivate"),a=this.getOption(e,"onPostActivate"),t=this.getOption(e,"checkCanFocusTrap");t||this.updateTabbableNodes(),this.state.active=!0,this.state.paused=!1,this.state.nodeFocusedBeforeActivation=D(this.doc),i==null||i();const s=()=>{t&&this.updateTabbableNodes(),this.addListeners(),this.updateObservedNodes(),a==null||a()};return t?(t(this.state.containers.concat()).then(s,s),this):(s(),this)}},y=e=>e.key==="Tab",w=(e,...i)=>typeof e=="function"?e(...i):e,Z=e=>!e.isComposing&&e.key==="Escape",R=e=>setTimeout(e,0),tt=e=>e.localName==="input"&&"select"in e&&typeof e.select=="function";function at(e,i={}){let a;const t=K(()=>{const s=typeof e=="function"?e():e;if(s){a=new J(s,{escapeDeactivates:!1,allowOutsideClick:!0,preventScroll:!0,returnFocusOnDeactivate:!0,delayInitialFocus:!1,fallbackFocus:s,...i,document:B(s)});try{a.activate()}catch{}}});return function(){a==null||a.deactivate(),t()}}var C="data-scroll-lock";function et(e){const i=e.getBoundingClientRect().left;return Math.round(i)+e.scrollLeft?"paddingLeft":"paddingRight"}function ot(e){const i=e??document,a=i.defaultView??window,{documentElement:t,body:s}=i;if(s.hasAttribute(C))return;const o=a.innerWidth-t.clientWidth;s.setAttribute(C,"");const n=()=>L(t,"--scrollbar-width",`${o}px`),l=et(t),u=()=>E(s,{overflow:"hidden",[l]:`${o}px`}),r=()=>{const{scrollX:b,scrollY:c,visualViewport:p}=a,f=(p==null?void 0:p.offsetLeft)??0,O=(p==null?void 0:p.offsetTop)??0,m=E(s,{position:"fixed",overflow:"hidden",top:`${-(c-Math.floor(O))}px`,left:`${-(b-Math.floor(f))}px`,right:"0",[l]:`${o}px`});return()=>{m==null||m(),a.scrollTo({left:b,top:c,behavior:"instant"})}},d=[n(),$()?r():u()];return()=>{d.forEach(b=>b==null?void 0:b()),s.removeAttribute(C)}}export{it as a,at as o,ot as r};
