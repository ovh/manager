//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

//-----ClientClass--Client---
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming


export class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://www.ovh.com";

    }

    /**
     * List available services
     * @param orderBy (optional) Order services by services.expanded.Service properties
     * @param resourceName (optional) Filter services by their resourceName (resource.name)
     * @param routes (optional) Filter services by API route path (comma separated)
     * @param sort (optional) Sort results generated by 'orderBy'
     * @return successful operation
     */
    servicesAll(orderBy: string | undefined, resourceName: string | undefined, routes: string | undefined, sort: string | undefined, cancelToken?: CancelToken | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/services?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (resourceName === null)
            throw new Error("The parameter 'resourceName' cannot be null.");
        else if (resourceName !== undefined)
            url_ += "resourceName=" + encodeURIComponent("" + resourceName) + "&";
        if (routes === null)
            throw new Error("The parameter 'routes' cannot be null.");
        else if (routes !== undefined)
            url_ += "routes=" + encodeURIComponent("" + routes) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServicesAll(_response);
        });
    }

    protected processServicesAll(response: AxiosResponse): Promise<number[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<number[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number[]>(null as any);
    }

    /**
     * Get details about a service
     * @param serviceId Service ID
     * @return successful operation
     */
    servicesGET(serviceId: number, cancelToken?: CancelToken | undefined): Promise<Service2> {
        let url_ = this.baseUrl + "/services/{serviceId}";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServicesGET(_response);
        });
    }

    protected processServicesGET(response: AxiosResponse): Promise<Service2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Service2.fromJS(resultData200);
            return Promise.resolve<Service2>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Service2>(null as any);
    }

    /**
     * Update service information
     * @param serviceId Service ID
     * @return successful operation
     */
    servicesPUT(serviceId: number, body: Service4, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/services/{serviceId}";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processServicesPUT(_response);
        });
    }

    protected processServicesPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get engagement details
     * @param serviceId Service ID
     * @return successful operation
     */
    engagement(serviceId: number, cancelToken?: CancelToken | undefined): Promise<Engagement> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/engagement";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEngagement(_response);
        });
    }

    protected processEngagement(response: AxiosResponse): Promise<Engagement> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Engagement.fromJS(resultData200);
            return Promise.resolve<Engagement>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Engagement>(null as any);
    }

    /**
     * List all available engagements a given service can subscribe to
     * @param serviceId Service ID
     * @return successful operation
     */
    available(serviceId: number, cancelToken?: CancelToken | undefined): Promise<Pricing[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/engagement/available";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAvailable(_response);
        });
    }

    protected processAvailable(response: AxiosResponse): Promise<Pricing[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pricing.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Pricing[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Pricing[]>(null as any);
    }

    /**
     * Change your Engagement end rules
     * @param serviceId Service ID
     * @return successful operation
     */
    endRule(serviceId: number, body: UpdateEndRuleRequest, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/engagement/endRule";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEndRule(_response);
        });
    }

    protected processEndRule(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Flush the engagement of this service
     * @param serviceId Service ID
     * @return successful operation
     */
    flush(serviceId: number, body: EngagementFlushRequest, cancelToken?: CancelToken | undefined): Promise<EngagementFlushOrder> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/engagement/flush";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFlush(_response);
        });
    }

    protected processFlush(response: AxiosResponse): Promise<EngagementFlushOrder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EngagementFlushOrder.fromJS(resultData200);
            return Promise.resolve<EngagementFlushOrder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EngagementFlushOrder>(null as any);
    }

    /**
     * Delete the ongoing Engagement request on this Service
     * @param serviceId Service ID
     * @return successful operation
     */
    requestDELETE(serviceId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/engagement/request";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestDELETE(_response);
        });
    }

    protected processRequestDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get the ongoing Engagement request on this Service
     * @param serviceId Service ID
     * @return successful operation
     */
    requestGET(serviceId: number, cancelToken?: CancelToken | undefined): Promise<EngagementRequest> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/engagement/request";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestGET(_response);
        });
    }

    protected processRequestGET(response: AxiosResponse): Promise<EngagementRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EngagementRequest.fromJS(resultData200);
            return Promise.resolve<EngagementRequest>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EngagementRequest>(null as any);
    }

    /**
     * Request an Engagement on this Service
     * @param serviceId Service ID
     * @return successful operation
     */
    requestPOST(serviceId: number, body: EngagementRequestCreation, cancelToken?: CancelToken | undefined): Promise<EngagementRequest> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/engagement/request";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRequestPOST(_response);
        });
    }

    protected processRequestPOST(response: AxiosResponse): Promise<EngagementRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = EngagementRequest.fromJS(resultData200);
            return Promise.resolve<EngagementRequest>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<EngagementRequest>(null as any);
    }

    /**
     * List available invoices
     * @param serviceId Service ID
     * @return successful operation
     */
    invoicesAll(serviceId: number, cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/invoices";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInvoicesAll(_response);
        });
    }

    protected processInvoicesAll(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * Get service's invoices
     * @param invoiceId Invoice ID
     * @param serviceId Service ID
     * @return successful operation
     */
    invoices(invoiceId: string, serviceId: number, cancelToken?: CancelToken | undefined): Promise<Invoice> {
        let url_ = this.baseUrl + "/services/{serviceId}/billing/invoices/{invoiceId}";
        if (invoiceId === undefined || invoiceId === null)
          throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInvoices(_response);
        });
    }

    protected processInvoices(response: AxiosResponse): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Invoice.fromJS(resultData200);
            return Promise.resolve<Invoice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Invoice>(null as any);
    }

    /**
     * Get a summary of the ongoing consumption of your service
     * @param serviceId Service ID
     * @return successful operation
     */
    consumption(serviceId: number, cancelToken?: CancelToken | undefined): Promise<Summary> {
        let url_ = this.baseUrl + "/services/{serviceId}/consumption";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConsumption(_response);
        });
    }

    protected processConsumption(response: AxiosResponse): Promise<Summary> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Summary.fromJS(resultData200);
            return Promise.resolve<Summary>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Summary>(null as any);
    }

    /**
     * Get each resource consumed by your service
     * @param planFamily (optional) Filter elements on a commercial offer's family
     * @param serviceId Service ID
     * @param uniqueId (optional) Filter elements on a given uniqueId
     * @return successful operation
     */
    element(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined, cancelToken?: CancelToken | undefined): Promise<Element[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/consumption/element?";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        if (planFamily === null)
            throw new Error("The parameter 'planFamily' cannot be null.");
        else if (planFamily !== undefined)
            url_ += "planFamily=" + encodeURIComponent("" + planFamily) + "&";
        if (uniqueId === null)
            throw new Error("The parameter 'uniqueId' cannot be null.");
        else if (uniqueId !== undefined)
            url_ += "uniqueId=" + encodeURIComponent("" + uniqueId) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processElement(_response);
        });
    }

    protected processElement(response: AxiosResponse): Promise<Element[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Element.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Element[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Element[]>(null as any);
    }

    /**
     * Get a summary of the forecasted consumption of your service
     * @param serviceId Service ID
     * @return successful operation
     */
    forecast(serviceId: number, cancelToken?: CancelToken | undefined): Promise<Summary> {
        let url_ = this.baseUrl + "/services/{serviceId}/consumption/forecast";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processForecast(_response);
        });
    }

    protected processForecast(response: AxiosResponse): Promise<Summary> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Summary.fromJS(resultData200);
            return Promise.resolve<Summary>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Summary>(null as any);
    }

    /**
     * Get each resource forecasted consumption of your service
     * @param planFamily (optional) Filter elements on a commercial offer's family
     * @param serviceId Service ID
     * @param uniqueId (optional) Filter elements on a given uniqueId
     * @return successful operation
     */
    element2(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined, cancelToken?: CancelToken | undefined): Promise<Element[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/consumption/forecast/element?";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        if (planFamily === null)
            throw new Error("The parameter 'planFamily' cannot be null.");
        else if (planFamily !== undefined)
            url_ += "planFamily=" + encodeURIComponent("" + planFamily) + "&";
        if (uniqueId === null)
            throw new Error("The parameter 'uniqueId' cannot be null.");
        else if (uniqueId !== undefined)
            url_ += "uniqueId=" + encodeURIComponent("" + uniqueId) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processElement2(_response);
        });
    }

    protected processElement2(response: AxiosResponse): Promise<Element[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Element.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Element[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Element[]>(null as any);
    }

    /**
     * List consumption history of your service
     * @param planFamily (optional) Order services by services.expanded.Service properties
     * @param serviceId Service ID
     * @param uniqueId (optional) Filter services by API route path (comma separated)
     * @return successful operation
     */
    historyAll(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined, cancelToken?: CancelToken | undefined): Promise<number[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/consumption/history?";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        if (planFamily === null)
            throw new Error("The parameter 'planFamily' cannot be null.");
        else if (planFamily !== undefined)
            url_ += "planFamily=" + encodeURIComponent("" + planFamily) + "&";
        if (uniqueId === null)
            throw new Error("The parameter 'uniqueId' cannot be null.");
        else if (uniqueId !== undefined)
            url_ += "uniqueId=" + encodeURIComponent("" + uniqueId) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHistoryAll(_response);
        });
    }

    protected processHistoryAll(response: AxiosResponse): Promise<number[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<number[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number[]>(null as any);
    }

    /**
     * Get a summary of the past consumption of your service
     * @param id Id
     * @param serviceId Service ID
     * @return successful operation
     */
    history(id: number, serviceId: number, cancelToken?: CancelToken | undefined): Promise<Summary> {
        let url_ = this.baseUrl + "/services/{serviceId}/consumption/history/{id}";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: AxiosResponse): Promise<Summary> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Summary.fromJS(resultData200);
            return Promise.resolve<Summary>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Summary>(null as any);
    }

    /**
     * Get each resource consumed for the given history
     * @param id Id
     * @param planFamily (optional) Filter elements on a commercial offer's family
     * @param serviceId Service ID
     * @param uniqueId (optional) Filter elements on a given uniqueId
     * @return successful operation
     */
    element3(id: number, planFamily: string | undefined, serviceId: number, uniqueId: string | undefined, cancelToken?: CancelToken | undefined): Promise<Element[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/consumption/history/{id}/element?";
        if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        if (planFamily === null)
            throw new Error("The parameter 'planFamily' cannot be null.");
        else if (planFamily !== undefined)
            url_ += "planFamily=" + encodeURIComponent("" + planFamily) + "&";
        if (uniqueId === null)
            throw new Error("The parameter 'uniqueId' cannot be null.");
        else if (uniqueId !== undefined)
            url_ += "uniqueId=" + encodeURIComponent("" + uniqueId) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processElement3(_response);
        });
    }

    protected processElement3(response: AxiosResponse): Promise<Element[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Element.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Element[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Element[]>(null as any);
    }

    /**
     * Update service contacts
     * @param serviceId Service ID
     * @return successful operation
     */
    contacts(serviceId: number, body: ContactChangeRequest, cancelToken?: CancelToken | undefined): Promise<Task> {
        let url_ = this.baseUrl + "/services/{serviceId}/contacts";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContacts(_response);
        });
    }

    protected processContacts(response: AxiosResponse): Promise<Task> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Task.fromJS(resultData200);
            return Promise.resolve<Task>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Task>(null as any);
    }

    /**
     * List offers this option can be converted to
     * @param serviceId Service ID
     * @return successful operation
     */
    detachAll(serviceId: number, cancelToken?: CancelToken | undefined): Promise<GenericProductDefinition[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/detach";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetachAll(_response);
        });
    }

    protected processDetachAll(response: AxiosResponse): Promise<GenericProductDefinition[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GenericProductDefinition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GenericProductDefinition[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GenericProductDefinition[]>(null as any);
    }

    /**
     * View an offer this option can be converted to
     * @param planCode Plan code
     * @param serviceId Service ID
     * @return successful operation
     */
    detach(planCode: string, serviceId: number, cancelToken?: CancelToken | undefined): Promise<GenericProductDefinition> {
        let url_ = this.baseUrl + "/services/{serviceId}/detach/{planCode}";
        if (planCode === undefined || planCode === null)
          throw new Error("The parameter 'planCode' must be defined.");
        url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDetach(_response);
        });
    }

    protected processDetach(response: AxiosResponse): Promise<GenericProductDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GenericProductDefinition.fromJS(resultData200);
            return Promise.resolve<GenericProductDefinition>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GenericProductDefinition>(null as any);
    }

    /**
     * Perform the migration to a standalone offer. May require you to pay an Order
     * @param planCode Plan code
     * @param serviceId Service ID
     * @return successful operation
     */
    execute(planCode: string, serviceId: number, body: DetachExecutionRequest, cancelToken?: CancelToken | undefined): Promise<Order2> {
        let url_ = this.baseUrl + "/services/{serviceId}/detach/{planCode}/execute";
        if (planCode === undefined || planCode === null)
          throw new Error("The parameter 'planCode' must be defined.");
        url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExecute(_response);
        });
    }

    protected processExecute(response: AxiosResponse): Promise<Order2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Order2.fromJS(resultData200);
            return Promise.resolve<Order2>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Order2>(null as any);
    }

    /**
     * View all offers compatible for the detachment for the given option offer
     * @param planCode Plan code
     * @param serviceId Service ID
     * @return successful operation
     */
    options(planCode: string, serviceId: number, cancelToken?: CancelToken | undefined): Promise<DetachOptionsDefinition[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/detach/{planCode}/options";
        if (planCode === undefined || planCode === null)
          throw new Error("The parameter 'planCode' must be defined.");
        url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOptions(_response);
        });
    }

    protected processOptions(response: AxiosResponse): Promise<DetachOptionsDefinition[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DetachOptionsDefinition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DetachOptionsDefinition[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DetachOptionsDefinition[]>(null as any);
    }

    /**
     * Simulate the migration to a standalone offer
     * @param planCode Plan code
     * @param serviceId Service ID
     * @return successful operation
     */
    simulate(planCode: string, serviceId: number, body: DetachExecutionRequest, cancelToken?: CancelToken | undefined): Promise<Order2> {
        let url_ = this.baseUrl + "/services/{serviceId}/detach/{planCode}/simulate";
        if (planCode === undefined || planCode === null)
          throw new Error("The parameter 'planCode' must be defined.");
        url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSimulate(_response);
        });
    }

    protected processSimulate(response: AxiosResponse): Promise<Order2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Order2.fromJS(resultData200);
            return Promise.resolve<Order2>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Order2>(null as any);
    }

    /**
     * List available forms for service
     * @param serviceId Service ID
     * @return successful operation
     */
    formAll(serviceId: number, cancelToken?: CancelToken | undefined): Promise<Description[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/form";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFormAll(_response);
        });
    }

    protected processFormAll(response: AxiosResponse): Promise<Description[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Description.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Description[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Description[]>(null as any);
    }

    /**
     * Get specified form description for service
     * @param formName Form name
     * @param serviceId Service ID
     * @return successful operation
     */
    form(formName: string, serviceId: number, cancelToken?: CancelToken | undefined): Promise<Description> {
        let url_ = this.baseUrl + "/services/{serviceId}/form/{formName}";
        if (formName === undefined || formName === null)
          throw new Error("The parameter 'formName' must be defined.");
        url_ = url_.replace("{formName}", encodeURIComponent("" + formName));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processForm(_response);
        });
    }

    protected processForm(response: AxiosResponse): Promise<Description> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Description.fromJS(resultData200);
            return Promise.resolve<Description>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Description>(null as any);
    }

    /**
     * Post answers to the form for your service
     * @param formName Form name
     * @param serviceId Service ID
     * @return successful operation
     */
    answer(formName: string, serviceId: number, body: Form, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/services/{serviceId}/form/{formName}/answer";
        if (formName === undefined || formName === null)
          throw new Error("The parameter 'formName' must be defined.");
        url_ = url_.replace("{formName}", encodeURIComponent("" + formName));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAnswer(_response);
        });
    }

    protected processAnswer(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Response.fromJS(resultData200);
            return Promise.resolve<Response>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(null as any);
    }

    /**
     * Get options of a service
     * @param serviceId Service ID
     * @return successful operation
     */
    options2(serviceId: number, cancelToken?: CancelToken | undefined): Promise<Service2[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/options";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOptions2(_response);
        });
    }

    protected processOptions2(response: AxiosResponse): Promise<Service2[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Service2.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Service2[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Service2[]>(null as any);
    }

    /**
     * Get possible renew periods of a service
     * @param serviceId Service ID
     * @return successful operation
     */
    renewPeriodCapacities(serviceId: number, cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/renewPeriodCapacities";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRenewPeriodCapacities(_response);
        });
    }

    protected processRenewPeriodCapacities(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * List contracts automatically agreed when subscribing to savings plan for this project
     * @param serviceId Service ID
     * @return successful operation
     */
    contracts(serviceId: number, cancelToken?: CancelToken | undefined): Promise<Contract[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/contracts";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processContracts(_response);
        });
    }

    protected processContracts(response: AxiosResponse): Promise<Contract[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contract.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Contract[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Anonymous2.fromJS(resultData500);
            return throwException("Error 500 response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Contract[]>(null as any);
    }

    /**
     * List subscribable Savings Plan commercial offers for a given Subscription
     * @param productCode (optional) Filter offers by product code
     * @param serviceId Service ID
     * @return successful operation
     */
    subscribable(productCode: string | undefined, serviceId: number, cancelToken?: CancelToken | undefined): Promise<SubscribableSavingsPlanOffer[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribable?";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        if (productCode === null)
            throw new Error("The parameter 'productCode' cannot be null.");
        else if (productCode !== undefined)
            url_ += "productCode=" + encodeURIComponent("" + productCode) + "&";
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribable(_response);
        });
    }

    protected processSubscribable(response: AxiosResponse): Promise<SubscribableSavingsPlanOffer[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableSavingsPlanOffer.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SubscribableSavingsPlanOffer[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous3.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Anonymous4.fromJS(resultData500);
            return throwException("Error 500 response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubscribableSavingsPlanOffer[]>(null as any);
    }

    /**
     * Subscribe to a Savings Plan, applicable contracts will be automatically agreed to.
     * @param serviceId Service ID
     * @return successful operation
     */
    execute2(serviceId: number, body: Subscribe, cancelToken?: CancelToken | undefined): Promise<SavingsPlan> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribe/execute";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExecute2(_response);
        });
    }

    protected processExecute2(response: AxiosResponse): Promise<SavingsPlan> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SavingsPlan.fromJS(resultData200);
            return Promise.resolve<SavingsPlan>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Anonymous5.fromJS(resultData400);
            return throwException("Error 400 response", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous6.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavingsPlan>(null as any);
    }

    /**
     * Simulate a Subscription to a Savings Plan
     * @param serviceId Service ID
     * @return successful operation
     */
    simulate2(serviceId: number, body: Subscribe, cancelToken?: CancelToken | undefined): Promise<SimulatedSavingsPlan> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribe/simulate";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSimulate2(_response);
        });
    }

    protected processSimulate2(response: AxiosResponse): Promise<SimulatedSavingsPlan> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SimulatedSavingsPlan.fromJS(resultData200);
            return Promise.resolve<SimulatedSavingsPlan>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Anonymous7.fromJS(resultData400);
            return throwException("Error 400 response", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous8.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SimulatedSavingsPlan>(null as any);
    }

    /**
     * List subscribed Savings Plans
     * @param serviceId Service ID
     * @return successful operation
     */
    subscribedAll(serviceId: number, cancelToken?: CancelToken | undefined): Promise<SavingsPlan[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribed";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribedAll(_response);
        });
    }

    protected processSubscribedAll(response: AxiosResponse): Promise<SavingsPlan[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SavingsPlan.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SavingsPlan[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous9.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Anonymous10.fromJS(resultData500);
            return throwException("Error 500 response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavingsPlan[]>(null as any);
    }

    /**
     * Fetch a subscribed Savings Plan
     * @param savingsPlanId Savings plan ID
     * @param serviceId Service ID
     * @return successful operation
     */
    subscribedGET(savingsPlanId: string, serviceId: number, cancelToken?: CancelToken | undefined): Promise<SavingsPlan> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}";
        if (savingsPlanId === undefined || savingsPlanId === null)
          throw new Error("The parameter 'savingsPlanId' must be defined.");
        url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribedGET(_response);
        });
    }

    protected processSubscribedGET(response: AxiosResponse): Promise<SavingsPlan> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SavingsPlan.fromJS(resultData200);
            return Promise.resolve<SavingsPlan>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous11.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Anonymous12.fromJS(resultData500);
            return throwException("Error 500 response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavingsPlan>(null as any);
    }

    /**
     * Update a subscribed Savings Plan
     * @param savingsPlanId Savings plan ID
     * @param serviceId Service ID
     * @return successful operation
     */
    subscribedPUT(savingsPlanId: string, serviceId: number, body: SavingsPlan, cancelToken?: CancelToken | undefined): Promise<SavingsPlan> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}";
        if (savingsPlanId === undefined || savingsPlanId === null)
          throw new Error("The parameter 'savingsPlanId' must be defined.");
        url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSubscribedPUT(_response);
        });
    }

    protected processSubscribedPUT(response: AxiosResponse): Promise<SavingsPlan> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SavingsPlan.fromJS(resultData200);
            return Promise.resolve<SavingsPlan>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Anonymous13.fromJS(resultData400);
            return throwException("Error 400 response", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous14.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Anonymous15.fromJS(resultData500);
            return throwException("Error 500 response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavingsPlan>(null as any);
    }

    /**
     * Change the action occurring at the end of the Savings Plan period
     * @param savingsPlanId Savings plan ID
     * @param serviceId Service ID
     * @return successful operation
     */
    changePeriodEndAction(savingsPlanId: string, serviceId: number, body: ChangePeriodEndAction, cancelToken?: CancelToken | undefined): Promise<SavingsPlan> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}/changePeriodEndAction";
        if (savingsPlanId === undefined || savingsPlanId === null)
          throw new Error("The parameter 'savingsPlanId' must be defined.");
        url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePeriodEndAction(_response);
        });
    }

    protected processChangePeriodEndAction(response: AxiosResponse): Promise<SavingsPlan> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SavingsPlan.fromJS(resultData200);
            return Promise.resolve<SavingsPlan>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Anonymous16.fromJS(resultData400);
            return throwException("Error 400 response", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous17.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Anonymous18.fromJS(resultData500);
            return throwException("Error 500 response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavingsPlan>(null as any);
    }

    /**
     * Resize the Savings Plan
     * @param savingsPlanId Savings plan ID
     * @param serviceId Service ID
     * @return successful operation
     */
    changeSize(savingsPlanId: string, serviceId: number, body: ChangeSize, cancelToken?: CancelToken | undefined): Promise<SavingsPlan> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}/changeSize";
        if (savingsPlanId === undefined || savingsPlanId === null)
          throw new Error("The parameter 'savingsPlanId' must be defined.");
        url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeSize(_response);
        });
    }

    protected processChangeSize(response: AxiosResponse): Promise<SavingsPlan> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SavingsPlan.fromJS(resultData200);
            return Promise.resolve<SavingsPlan>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Anonymous19.fromJS(resultData400);
            return throwException("Error 400 response", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous20.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Anonymous21.fromJS(resultData500);
            return throwException("Error 500 response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavingsPlan>(null as any);
    }

    /**
     * List the period history of a given Savings Plan
     * @param savingsPlanId Savings plan ID
     * @param serviceId Service ID
     * @return successful operation
     */
    periods(savingsPlanId: string, serviceId: number, cancelToken?: CancelToken | undefined): Promise<Period[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}/periods";
        if (savingsPlanId === undefined || savingsPlanId === null)
          throw new Error("The parameter 'savingsPlanId' must be defined.");
        url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPeriods(_response);
        });
    }

    protected processPeriods(response: AxiosResponse): Promise<Period[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Period.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Period[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Anonymous22.fromJS(resultData404);
            return throwException("Error 404 response", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = Anonymous23.fromJS(resultData500);
            return throwException("Error 500 response", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Period[]>(null as any);
    }

    /**
     * View the technical details of the service
     * @param serviceId Service ID
     * @return successful operation
     */
    technicalDetails(serviceId: number, cancelToken?: CancelToken | undefined): Promise<TechnicalDetails> {
        let url_ = this.baseUrl + "/services/{serviceId}/technicalDetails";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTechnicalDetails(_response);
        });
    }

    protected processTechnicalDetails(response: AxiosResponse): Promise<TechnicalDetails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TechnicalDetails.fromJS(resultData200);
            return Promise.resolve<TechnicalDetails>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TechnicalDetails>(null as any);
    }

    /**
     * Request service termination
     * @param serviceId Service ID
     * @return successful operation
     */
    terminate(serviceId: number, cancelToken?: CancelToken | undefined): Promise<TerminationAnswer> {
        let url_ = this.baseUrl + "/services/{serviceId}/terminate";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTerminate(_response);
        });
    }

    protected processTerminate(response: AxiosResponse): Promise<TerminationAnswer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TerminationAnswer.fromJS(resultData200);
            return Promise.resolve<TerminationAnswer>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TerminationAnswer>(null as any);
    }

    /**
     * Confirm service termination
     * @param serviceId Service ID
     * @return successful operation
     */
    confirm(serviceId: number, body: ConfirmServiceTerminationRequest, cancelToken?: CancelToken | undefined): Promise<TerminationAnswer> {
        let url_ = this.baseUrl + "/services/{serviceId}/terminate/confirm";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirm(_response);
        });
    }

    protected processConfirm(response: AxiosResponse): Promise<TerminationAnswer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TerminationAnswer.fromJS(resultData200);
            return Promise.resolve<TerminationAnswer>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TerminationAnswer>(null as any);
    }

    /**
     * List offers this option can be converted to
     * @param serviceId Service ID
     * @return successful operation
     */
    upgradeAll(serviceId: number, cancelToken?: CancelToken | undefined): Promise<GenericProductDefinition[]> {
        let url_ = this.baseUrl + "/services/{serviceId}/upgrade";
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpgradeAll(_response);
        });
    }

    protected processUpgradeAll(response: AxiosResponse): Promise<GenericProductDefinition[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GenericProductDefinition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GenericProductDefinition[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GenericProductDefinition[]>(null as any);
    }

    /**
     * View an offer this option can be converted to
     * @param planCode Plan code
     * @param serviceId Service ID
     * @return successful operation
     */
    upgrade(planCode: string, serviceId: number, cancelToken?: CancelToken | undefined): Promise<GenericProductDefinition> {
        let url_ = this.baseUrl + "/services/{serviceId}/upgrade/{planCode}";
        if (planCode === undefined || planCode === null)
          throw new Error("The parameter 'planCode' must be defined.");
        url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpgrade(_response);
        });
    }

    protected processUpgrade(response: AxiosResponse): Promise<GenericProductDefinition> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GenericProductDefinition.fromJS(resultData200);
            return Promise.resolve<GenericProductDefinition>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GenericProductDefinition>(null as any);
    }

    /**
     * Perform the migration to another offer. May require you to pay an Order
     * @param planCode Plan code
     * @param serviceId Service ID
     * @return successful operation
     */
    execute3(planCode: string, serviceId: number, body: ExecutionRequest, cancelToken?: CancelToken | undefined): Promise<Order2> {
        let url_ = this.baseUrl + "/services/{serviceId}/upgrade/{planCode}/execute";
        if (planCode === undefined || planCode === null)
          throw new Error("The parameter 'planCode' must be defined.");
        url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExecute3(_response);
        });
    }

    protected processExecute3(response: AxiosResponse): Promise<Order2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Order2.fromJS(resultData200);
            return Promise.resolve<Order2>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Order2>(null as any);
    }

    /**
     * Simulate the conversion to another offer
     * @param planCode Plan code
     * @param serviceId Service ID
     * @return successful operation
     */
    simulate3(planCode: string, serviceId: number, body: ExecutionRequest, cancelToken?: CancelToken | undefined): Promise<Order2> {
        let url_ = this.baseUrl + "/services/{serviceId}/upgrade/{planCode}/simulate";
        if (planCode === undefined || planCode === null)
          throw new Error("The parameter 'planCode' must be defined.");
        url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
        if (serviceId === undefined || serviceId === null)
          throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
          url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSimulate3(_response);
        });
    }

    protected processSimulate3(response: AxiosResponse): Promise<Order2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Order2.fromJS(resultData200);
            return Promise.resolve<Order2>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Order2>(null as any);
    }
}

//-----/ClientClass----

export * as Query from './Query';



//-----Types.File-----
/** Key and value, with proper key strings */
export class SafeKeyValue_string implements ISafeKeyValue_string {
    readonly key?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: ISafeKeyValue_string) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SafeKeyValue_string {
        data = typeof data === 'object' ? data : {};
        let result = new SafeKeyValue_string();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** Key and value, with proper key strings */
export interface ISafeKeyValue_string {
    key?: string;
    value?: string;

    [key: string]: any;
}

/** A contract */
export class Contract implements IContract {
    /** Terms of the contract */
    readonly content?: string;
    /** Name of the contract */
    readonly name?: string;
    /** URL to download the contract */
    readonly url?: string;

    [key: string]: any;

    constructor(data?: IContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).content = _data["content"];
            (<any>this).name = _data["name"];
            (<any>this).url = _data["url"];
        }
    }

    static fromJS(data: any): Contract {
        data = typeof data === 'object' ? data : {};
        let result = new Contract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["content"] = this.content;
        data["name"] = this.name;
        data["url"] = this.url;
        return data;
    }
}

/** A contract */
export interface IContract {
    /** Terms of the contract */
    content?: string;
    /** Name of the contract */
    name?: string;
    /** URL to download the contract */
    url?: string;

    [key: string]: any;
}

/** Currency code */
export enum CurrencyCodeEnum {
    AUD = "AUD",
    CAD = "CAD",
    CZK = "CZK",
    EUR = "EUR",
    GBP = "GBP",
    INR = "INR",
    LTL = "LTL",
    MAD = "MAD",
    N_A = "N/A",
    PLN = "PLN",
    SGD = "SGD",
    TND = "TND",
    USD = "USD",
    XOF = "XOF",
    Points = "points",
}

/** An order */
export class Order implements IOrder {
    /** List of contracts related to the order */
    readonly contracts?: Contract[];
    /** Details of the order */
    readonly details?: OrderDetail[];
    /** Identifier of the order */
    readonly orderId?: number | undefined;
    /** Prices of the order including with and without taxes */
    readonly prices?: OrderPrices;
    /** URL to download the order */
    readonly url?: string | undefined;

    [key: string]: any;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["contracts"])) {
                (<any>this).contracts = [] as any;
                for (let item of _data["contracts"])
                    (<any>this).contracts!.push(Contract.fromJS(item));
            }
            if (Array.isArray(_data["details"])) {
                (<any>this).details = [] as any;
                for (let item of _data["details"])
                    (<any>this).details!.push(OrderDetail.fromJS(item));
            }
            (<any>this).orderId = _data["orderId"];
            (<any>this).prices = _data["prices"] ? OrderPrices.fromJS(_data["prices"]) : <any>undefined;
            (<any>this).url = _data["url"];
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        data["orderId"] = this.orderId;
        data["prices"] = this.prices ? this.prices.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data;
    }
}

/** An order */
export interface IOrder {
    /** List of contracts related to the order */
    contracts?: Contract[];
    /** Details of the order */
    details?: OrderDetail[];
    /** Identifier of the order */
    orderId?: number | undefined;
    /** Prices of the order including with and without taxes */
    prices?: OrderPrices;
    /** URL to download the order */
    url?: string | undefined;

    [key: string]: any;
}

/** Detail of an order */
export class OrderDetail implements IOrderDetail {
    /** Cart Item ID the details is related to */
    readonly cartItemID?: number | undefined;
    /** Description of the detail */
    readonly description?: string;
    /** Type of detail */
    readonly detailType?: OrderDetailTypeEnum | undefined;
    /** Service name */
    readonly domain?: string;
    /** Original price of the detail before reduction application */
    readonly originalTotalPrice?: Price;
    /** Quantity of the service */
    readonly quantity?: number;
    /** Total price of the reduction */
    readonly reductionTotalPrice?: Price;
    /** List of reductions applied to the detail */
    readonly reductions?: Reduction[];
    /** Price total of the services */
    readonly totalPrice?: Price;
    /** Unitary price of the service */
    readonly unitPrice?: Price;

    [key: string]: any;

    constructor(data?: IOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).cartItemID = _data["cartItemID"];
            (<any>this).description = _data["description"];
            (<any>this).detailType = _data["detailType"];
            (<any>this).domain = _data["domain"];
            (<any>this).originalTotalPrice = _data["originalTotalPrice"] ? Price.fromJS(_data["originalTotalPrice"]) : <any>undefined;
            (<any>this).quantity = _data["quantity"];
            (<any>this).reductionTotalPrice = _data["reductionTotalPrice"] ? Price.fromJS(_data["reductionTotalPrice"]) : <any>undefined;
            if (Array.isArray(_data["reductions"])) {
                (<any>this).reductions = [] as any;
                for (let item of _data["reductions"])
                    (<any>this).reductions!.push(Reduction.fromJS(item));
            }
            (<any>this).totalPrice = _data["totalPrice"] ? Price.fromJS(_data["totalPrice"]) : <any>undefined;
            (<any>this).unitPrice = _data["unitPrice"] ? Price.fromJS(_data["unitPrice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderDetail {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["cartItemID"] = this.cartItemID;
        data["description"] = this.description;
        data["detailType"] = this.detailType;
        data["domain"] = this.domain;
        data["originalTotalPrice"] = this.originalTotalPrice ? this.originalTotalPrice.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["reductionTotalPrice"] = this.reductionTotalPrice ? this.reductionTotalPrice.toJSON() : <any>undefined;
        if (Array.isArray(this.reductions)) {
            data["reductions"] = [];
            for (let item of this.reductions)
                data["reductions"].push(item.toJSON());
        }
        data["totalPrice"] = this.totalPrice ? this.totalPrice.toJSON() : <any>undefined;
        data["unitPrice"] = this.unitPrice ? this.unitPrice.toJSON() : <any>undefined;
        return data;
    }
}

/** Detail of an order */
export interface IOrderDetail {
    /** Cart Item ID the details is related to */
    cartItemID?: number | undefined;
    /** Description of the detail */
    description?: string;
    /** Type of detail */
    detailType?: OrderDetailTypeEnum | undefined;
    /** Service name */
    domain?: string;
    /** Original price of the detail before reduction application */
    originalTotalPrice?: Price;
    /** Quantity of the service */
    quantity?: number;
    /** Total price of the reduction */
    reductionTotalPrice?: Price;
    /** List of reductions applied to the detail */
    reductions?: Reduction[];
    /** Price total of the services */
    totalPrice?: Price;
    /** Unitary price of the service */
    unitPrice?: Price;

    [key: string]: any;
}

/** Product type of item in order */
export enum OrderDetailTypeEnum {
    ACCESSORY = "ACCESSORY",
    CAUTION = "CAUTION",
    CHOOSED = "CHOOSED",
    CONSUMPTION = "CONSUMPTION",
    CREATION = "CREATION",
    DELIVERY = "DELIVERY",
    DURATION = "DURATION",
    GIFT = "GIFT",
    INSTALLATION = "INSTALLATION",
    LICENSE = "LICENSE",
    MUTE = "MUTE",
    OTHER = "OTHER",
    OUTPLAN = "OUTPLAN",
    QUANTITY = "QUANTITY",
    REFUND = "REFUND",
    RENEW = "RENEW",
    SPECIAL = "SPECIAL",
    SWITCH = "SWITCH",
    TRANSFER = "TRANSFER",
    VOUCHER = "VOUCHER",
}

/** Prices of an order */
export class OrderPrices implements IOrderPrices {
    /** Price before reduction application */
    readonly originalWithoutTax?: Price | undefined;
    /** Price concerning the reduced amount */
    readonly reduction?: Price | undefined;
    /** Tax amount */
    readonly tax?: Price;
    /** Price with tax */
    readonly withTax?: Price;
    /** Price without tax */
    readonly withoutTax?: Price;

    [key: string]: any;

    constructor(data?: IOrderPrices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).originalWithoutTax = _data["originalWithoutTax"] ? Price.fromJS(_data["originalWithoutTax"]) : <any>undefined;
            (<any>this).reduction = _data["reduction"] ? Price.fromJS(_data["reduction"]) : <any>undefined;
            (<any>this).tax = _data["tax"] ? Price.fromJS(_data["tax"]) : <any>undefined;
            (<any>this).withTax = _data["withTax"] ? Price.fromJS(_data["withTax"]) : <any>undefined;
            (<any>this).withoutTax = _data["withoutTax"] ? Price.fromJS(_data["withoutTax"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderPrices {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPrices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["originalWithoutTax"] = this.originalWithoutTax ? this.originalWithoutTax.toJSON() : <any>undefined;
        data["reduction"] = this.reduction ? this.reduction.toJSON() : <any>undefined;
        data["tax"] = this.tax ? this.tax.toJSON() : <any>undefined;
        data["withTax"] = this.withTax ? this.withTax.toJSON() : <any>undefined;
        data["withoutTax"] = this.withoutTax ? this.withoutTax.toJSON() : <any>undefined;
        return data;
    }
}

/** Prices of an order */
export interface IOrderPrices {
    /** Price before reduction application */
    originalWithoutTax?: Price | undefined;
    /** Price concerning the reduced amount */
    reduction?: Price | undefined;
    /** Tax amount */
    tax?: Price;
    /** Price with tax */
    withTax?: Price;
    /** Price without tax */
    withoutTax?: Price;

    [key: string]: any;
}

/** Price with its currency and textual representation */
export class Price implements IPrice {
    /** Currency code */
    readonly currencyCode?: CurrencyCodeEnum;
    /** Price in microcents */
    readonly priceInUcents?: number | undefined;
    /** Textual representation */
    readonly text?: string;
    /** The effective price */
    readonly value?: number;

    [key: string]: any;

    constructor(data?: IPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).currencyCode = _data["currencyCode"];
            (<any>this).priceInUcents = _data["priceInUcents"];
            (<any>this).text = _data["text"];
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): Price {
        data = typeof data === 'object' ? data : {};
        let result = new Price();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["currencyCode"] = this.currencyCode;
        data["priceInUcents"] = this.priceInUcents;
        data["text"] = this.text;
        data["value"] = this.value;
        return data;
    }
}

/** Price with its currency and textual representation */
export interface IPrice {
    /** Currency code */
    currencyCode?: CurrencyCodeEnum;
    /** Price in microcents */
    priceInUcents?: number | undefined;
    /** Textual representation */
    text?: string;
    /** The effective price */
    value?: number;

    [key: string]: any;
}

/** Order detail reduction */
export class Reduction implements IReduction {
    /** In which context the reduction is applied */
    readonly context?: ReductionContextEnum;
    /** Promotion description */
    readonly description?: string;
    /** Reduction price applied with this promotion */
    readonly price?: Price;
    /** Reduction description */
    readonly reductionDescription?: string;
    /** Reduction effect, price modification */
    readonly type?: ReductionTypeEnum;
    /** The reduction value */
    readonly value?: Price;

    [key: string]: any;

    constructor(data?: IReduction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).context = _data["context"];
            (<any>this).description = _data["description"];
            (<any>this).price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            (<any>this).reductionDescription = _data["reductionDescription"];
            (<any>this).type = _data["type"];
            (<any>this).value = _data["value"] ? Price.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Reduction {
        data = typeof data === 'object' ? data : {};
        let result = new Reduction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["context"] = this.context;
        data["description"] = this.description;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["reductionDescription"] = this.reductionDescription;
        data["type"] = this.type;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** Order detail reduction */
export interface IReduction {
    /** In which context the reduction is applied */
    context?: ReductionContextEnum;
    /** Promotion description */
    description?: string;
    /** Reduction price applied with this promotion */
    price?: Price;
    /** Reduction description */
    reductionDescription?: string;
    /** Reduction effect, price modification */
    type?: ReductionTypeEnum;
    /** The reduction value */
    value?: Price;

    [key: string]: any;
}

/** Context of the reduction */
export enum ReductionContextEnum {
    Promotion = "promotion",
    Voucher = "voucher",
}

/** Type of reduction */
export enum ReductionTypeEnum {
    Fixed_amount = "fixed_amount",
    Forced_amount = "forced_amount",
    Percentage = "percentage",
}

/** Representation of a generic product */
export class GenericProductDefinition implements IGenericProductDefinition {
    /** Product offer identifier */
    readonly planCode?: string;
    /** Prices of the product offer */
    readonly prices?: GenericProductPricing[];
    /** Name of the product */
    readonly productName?: string;
    /** Product type */
    readonly productType?: GenericProductTypeEnum;

    [key: string]: any;

    constructor(data?: IGenericProductDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).planCode = _data["planCode"];
            if (Array.isArray(_data["prices"])) {
                (<any>this).prices = [] as any;
                for (let item of _data["prices"])
                    (<any>this).prices!.push(GenericProductPricing.fromJS(item));
            }
            (<any>this).productName = _data["productName"];
            (<any>this).productType = _data["productType"];
        }
    }

    static fromJS(data: any): GenericProductDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new GenericProductDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["planCode"] = this.planCode;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        data["productName"] = this.productName;
        data["productType"] = this.productType;
        return data;
    }
}

/** Representation of a generic product */
export interface IGenericProductDefinition {
    /** Product offer identifier */
    planCode?: string;
    /** Prices of the product offer */
    prices?: GenericProductPricing[];
    /** Name of the product */
    productName?: string;
    /** Product type */
    productType?: GenericProductTypeEnum;

    [key: string]: any;
}

/** Representation of a product pricing */
export class GenericProductPricing implements IGenericProductPricing {
    /** Capacities of the pricing (type of pricing) */
    readonly capacities?: GenericProductPricingCapacitiesEnum[];
    /** Description of the pricing */
    readonly description?: string;
    /** Duration for ordering the product */
    readonly duration?: string;
    /** Interval of renewal */
    readonly interval?: number;
    /** Maximum quantity that can be ordered */
    readonly maximumQuantity?: number | undefined;
    /** Maximum repeat for renewal */
    readonly maximumRepeat?: number | undefined;
    /** Minimum quantity that can be ordered */
    readonly minimumQuantity?: number;
    /** Minimum repeat for renewal */
    readonly minimumRepeat?: number;
    /** Price of the product */
    readonly price?: Price;
    /** Price of the product in micro-centims */
    readonly priceInUcents?: number;
    /** Pricing model identifier */
    readonly pricingMode?: string;
    /** Pricing type */
    readonly pricingType?: GenericProductPricingTypeEnum;

    [key: string]: any;

    constructor(data?: IGenericProductPricing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["capacities"])) {
                (<any>this).capacities = [] as any;
                for (let item of _data["capacities"])
                    (<any>this).capacities!.push(item);
            }
            (<any>this).description = _data["description"];
            (<any>this).duration = _data["duration"];
            (<any>this).interval = _data["interval"];
            (<any>this).maximumQuantity = _data["maximumQuantity"];
            (<any>this).maximumRepeat = _data["maximumRepeat"];
            (<any>this).minimumQuantity = _data["minimumQuantity"];
            (<any>this).minimumRepeat = _data["minimumRepeat"];
            (<any>this).price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            (<any>this).priceInUcents = _data["priceInUcents"];
            (<any>this).pricingMode = _data["pricingMode"];
            (<any>this).pricingType = _data["pricingType"];
        }
    }

    static fromJS(data: any): GenericProductPricing {
        data = typeof data === 'object' ? data : {};
        let result = new GenericProductPricing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.capacities)) {
            data["capacities"] = [];
            for (let item of this.capacities)
                data["capacities"].push(item);
        }
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["interval"] = this.interval;
        data["maximumQuantity"] = this.maximumQuantity;
        data["maximumRepeat"] = this.maximumRepeat;
        data["minimumQuantity"] = this.minimumQuantity;
        data["minimumRepeat"] = this.minimumRepeat;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["priceInUcents"] = this.priceInUcents;
        data["pricingMode"] = this.pricingMode;
        data["pricingType"] = this.pricingType;
        return data;
    }
}

/** Representation of a product pricing */
export interface IGenericProductPricing {
    /** Capacities of the pricing (type of pricing) */
    capacities?: GenericProductPricingCapacitiesEnum[];
    /** Description of the pricing */
    description?: string;
    /** Duration for ordering the product */
    duration?: string;
    /** Interval of renewal */
    interval?: number;
    /** Maximum quantity that can be ordered */
    maximumQuantity?: number | undefined;
    /** Maximum repeat for renewal */
    maximumRepeat?: number | undefined;
    /** Minimum quantity that can be ordered */
    minimumQuantity?: number;
    /** Minimum repeat for renewal */
    minimumRepeat?: number;
    /** Price of the product */
    price?: Price;
    /** Price of the product in micro-centims */
    priceInUcents?: number;
    /** Pricing model identifier */
    pricingMode?: string;
    /** Pricing type */
    pricingType?: GenericProductPricingTypeEnum;

    [key: string]: any;
}

/** Capacity of a pricing (type) */
export enum GenericProductPricingCapacitiesEnum {
    Consumption = "consumption",
    Detach = "detach",
    Downgrade = "downgrade",
    Dynamic = "dynamic",
    Installation = "installation",
    Renew = "renew",
    Upgrade = "upgrade",
}

/** Type of a pricing */
export enum GenericProductPricingTypeEnum {
    Consumption = "consumption",
    Purchase = "purchase",
    Rental = "rental",
}

/** Type of a product */
export enum GenericProductTypeEnum {
    Cloud_service = "cloud_service",
    Delivery = "delivery",
    Deposit = "deposit",
    Domain = "domain",
    Implementation_services = "implementation_services",
    Saas_license = "saas_license",
    Shipping = "shipping",
    Storage = "storage",
}

/** Map a possible renew for a specific service */
export class RenewType implements IRenewType {
    /** The service is automatically renewed */
    automatic?: boolean;
    /** The service will be deleted at expiration */
    deleteAtExpiration?: boolean;
    /** The service forced to be renewed */
    forced?: boolean;
    /** The service needs to be manually renewed and paid */
    manualPayment?: boolean | undefined;
    /** period of renew in month */
    period?: number | undefined;

    [key: string]: any;

    constructor(data?: IRenewType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.automatic = _data["automatic"];
            this.deleteAtExpiration = _data["deleteAtExpiration"];
            this.forced = _data["forced"];
            this.manualPayment = _data["manualPayment"];
            this.period = _data["period"];
        }
    }

    static fromJS(data: any): RenewType {
        data = typeof data === 'object' ? data : {};
        let result = new RenewType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["automatic"] = this.automatic;
        data["deleteAtExpiration"] = this.deleteAtExpiration;
        data["forced"] = this.forced;
        data["manualPayment"] = this.manualPayment;
        data["period"] = this.period;
        return data;
    }
}

/** Map a possible renew for a specific service */
export interface IRenewType {
    /** The service is automatically renewed */
    automatic?: boolean;
    /** The service will be deleted at expiration */
    deleteAtExpiration?: boolean;
    /** The service forced to be renewed */
    forced?: boolean;
    /** The service needs to be manually renewed and paid */
    manualPayment?: boolean | undefined;
    /** period of renew in month */
    period?: number | undefined;

    [key: string]: any;
}

/** Detailed renewal type of a service */
export enum RenewalTypeEnum {
    AutomaticForcedProduct = "automaticForcedProduct",
    AutomaticV2012 = "automaticV2012",
    AutomaticV2014 = "automaticV2014",
    AutomaticV2016 = "automaticV2016",
    Manual = "manual",
    OneShot = "oneShot",
    Option = "option",
}

/** service.StateEnum */
export enum StateEnum {
    AutorenewInProgress = "autorenewInProgress",
    Expired = "expired",
    InCreation = "inCreation",
    Ok = "ok",
    PendingDebt = "pendingDebt",
    UnPaid = "unPaid",
}

/** All future uses you can provide for a service termination */
export enum TerminationFutureUseEnum {
    NOT_REPLACING_SERVICE = "NOT_REPLACING_SERVICE",
    OTHER = "OTHER",
    SUBSCRIBE_AN_OTHER_SERVICE = "SUBSCRIBE_AN_OTHER_SERVICE",
    SUBSCRIBE_OTHER_KIND_OF_SERVICE_WITH_COMPETITOR = "SUBSCRIBE_OTHER_KIND_OF_SERVICE_WITH_COMPETITOR",
    SUBSCRIBE_SIMILAR_SERVICE_WITH_COMPETITOR = "SUBSCRIBE_SIMILAR_SERVICE_WITH_COMPETITOR",
}

/** All reasons you can provide for a service termination */
export enum TerminationReasonEnum {
    FEATURES_DONT_SUIT_ME = "FEATURES_DONT_SUIT_ME",
    LACK_OF_PERFORMANCES = "LACK_OF_PERFORMANCES",
    MIGRATED_TO_ANOTHER_OVH_PRODUCT = "MIGRATED_TO_ANOTHER_OVH_PRODUCT",
    MIGRATED_TO_COMPETITOR = "MIGRATED_TO_COMPETITOR",
    NOT_ENOUGH_RECOGNITION = "NOT_ENOUGH_RECOGNITION",
    NOT_NEEDED_ANYMORE = "NOT_NEEDED_ANYMORE",
    NOT_RELIABLE = "NOT_RELIABLE",
    NO_ANSWER = "NO_ANSWER",
    OTHER = "OTHER",
    PRODUCT_DIMENSION_DONT_SUIT_ME = "PRODUCT_DIMENSION_DONT_SUIT_ME",
    PRODUCT_TOOLS_DONT_SUIT_ME = "PRODUCT_TOOLS_DONT_SUIT_ME",
    TOO_EXPENSIVE = "TOO_EXPENSIVE",
    TOO_HARD_TO_USE = "TOO_HARD_TO_USE",
    UNSATIFIED_BY_CUSTOMER_SUPPORT = "UNSATIFIED_BY_CUSTOMER_SUPPORT",
}

/** Details about a Service */
export class Service implements IService {
    /** Indicates that the service can be set up to be deleted at expiration */
    readonly canDeleteAtExpiration?: boolean;
    readonly contactAdmin?: string;
    readonly contactBilling?: string;
    readonly contactTech?: string;
    readonly creation?: Date;
    readonly domain?: string;
    readonly engagedUpTo?: Date | undefined;
    readonly expiration?: Date;
    /** All the possible renew period of your service in month */
    readonly possibleRenewPeriod?: number[] | undefined;
    /** Way of handling the renew */
    renew?: RenewType | undefined;
    readonly renewalType?: RenewalTypeEnum;
    readonly serviceId?: number;
    readonly status?: StateEnum;

    [key: string]: any;

    constructor(data?: IService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).canDeleteAtExpiration = _data["canDeleteAtExpiration"];
            (<any>this).contactAdmin = _data["contactAdmin"];
            (<any>this).contactBilling = _data["contactBilling"];
            (<any>this).contactTech = _data["contactTech"];
            (<any>this).creation = _data["creation"] ? parseDateOnly(_data["creation"].toString()) : <any>undefined;
            (<any>this).domain = _data["domain"];
            (<any>this).engagedUpTo = _data["engagedUpTo"] ? parseDateOnly(_data["engagedUpTo"].toString()) : <any>undefined;
            (<any>this).expiration = _data["expiration"] ? parseDateOnly(_data["expiration"].toString()) : <any>undefined;
            if (Array.isArray(_data["possibleRenewPeriod"])) {
                (<any>this).possibleRenewPeriod = [] as any;
                for (let item of _data["possibleRenewPeriod"])
                    (<any>this).possibleRenewPeriod!.push(item);
            }
            this.renew = _data["renew"] ? RenewType.fromJS(_data["renew"]) : <any>undefined;
            (<any>this).renewalType = _data["renewalType"];
            (<any>this).serviceId = _data["serviceId"];
            (<any>this).status = _data["status"];
        }
    }

    static fromJS(data: any): Service {
        data = typeof data === 'object' ? data : {};
        let result = new Service();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["canDeleteAtExpiration"] = this.canDeleteAtExpiration;
        data["contactAdmin"] = this.contactAdmin;
        data["contactBilling"] = this.contactBilling;
        data["contactTech"] = this.contactTech;
        data["creation"] = this.creation ? formatDate(this.creation) : <any>undefined;
        data["domain"] = this.domain;
        data["engagedUpTo"] = this.engagedUpTo ? formatDate(this.engagedUpTo) : <any>undefined;
        data["expiration"] = this.expiration ? formatDate(this.expiration) : <any>undefined;
        if (Array.isArray(this.possibleRenewPeriod)) {
            data["possibleRenewPeriod"] = [];
            for (let item of this.possibleRenewPeriod)
                data["possibleRenewPeriod"].push(item);
        }
        data["renew"] = this.renew ? this.renew.toJSON() : <any>undefined;
        data["renewalType"] = this.renewalType;
        data["serviceId"] = this.serviceId;
        data["status"] = this.status;
        return data;
    }
}

/** Details about a Service */
export interface IService {
    /** Indicates that the service can be set up to be deleted at expiration */
    canDeleteAtExpiration?: boolean;
    contactAdmin?: string;
    contactBilling?: string;
    contactTech?: string;
    creation?: Date;
    domain?: string;
    engagedUpTo?: Date | undefined;
    expiration?: Date;
    /** All the possible renew period of your service in month */
    possibleRenewPeriod?: number[] | undefined;
    /** Way of handling the renew */
    renew?: RenewType | undefined;
    renewalType?: RenewalTypeEnum;
    serviceId?: number;
    status?: StateEnum;

    [key: string]: any;
}

/** Description of an invoice */
export class Invoice implements IInvoice {
    /** Invoice date */
    readonly date?: Date;
    /** Invoice reference */
    readonly id?: string;
    /** Invoice details */
    readonly lines?: InvoiceLine[];

    [key: string]: any;

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["lines"])) {
                (<any>this).lines = [] as any;
                for (let item of _data["lines"])
                    (<any>this).lines!.push(InvoiceLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["id"] = this.id;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        return data;
    }
}

/** Description of an invoice */
export interface IInvoice {
    /** Invoice date */
    date?: Date;
    /** Invoice reference */
    id?: string;
    /** Invoice details */
    lines?: InvoiceLine[];

    [key: string]: any;
}

/** Description of an invoice line */
export class InvoiceLine implements IInvoiceLine {
    /** Description of item */
    readonly description?: string;
    /** End period */
    readonly periodEnd?: Date | undefined;
    /** Start period */
    readonly periodStart?: Date | undefined;
    /** Price without tax */
    readonly price?: Price;
    /** Quantity of item */
    readonly quantity?: number;
    /** Associated service name */
    readonly serviceName?: string;
    /** Price with tax */
    readonly totalPrice?: Price;
    /** Type of item */
    readonly type?: InvoiceLineTypeEnum | undefined;

    [key: string]: any;

    constructor(data?: IInvoiceLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).description = _data["description"];
            (<any>this).periodEnd = _data["periodEnd"] ? new Date(_data["periodEnd"].toString()) : <any>undefined;
            (<any>this).periodStart = _data["periodStart"] ? new Date(_data["periodStart"].toString()) : <any>undefined;
            (<any>this).price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            (<any>this).quantity = _data["quantity"];
            (<any>this).serviceName = _data["serviceName"];
            (<any>this).totalPrice = _data["totalPrice"] ? Price.fromJS(_data["totalPrice"]) : <any>undefined;
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): InvoiceLine {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["periodEnd"] = this.periodEnd ? this.periodEnd.toISOString() : <any>undefined;
        data["periodStart"] = this.periodStart ? this.periodStart.toISOString() : <any>undefined;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["serviceName"] = this.serviceName;
        data["totalPrice"] = this.totalPrice ? this.totalPrice.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

/** Description of an invoice line */
export interface IInvoiceLine {
    /** Description of item */
    description?: string;
    /** End period */
    periodEnd?: Date | undefined;
    /** Start period */
    periodStart?: Date | undefined;
    /** Price without tax */
    price?: Price;
    /** Quantity of item */
    quantity?: number;
    /** Associated service name */
    serviceName?: string;
    /** Price with tax */
    totalPrice?: Price;
    /** Type of item */
    type?: InvoiceLineTypeEnum | undefined;

    [key: string]: any;
}

/** Type of item */
export enum InvoiceLineTypeEnum {
    Accessory = "accessory",
    Consumption = "consumption",
    Creation = "creation",
    Deposit = "deposit",
    Duration = "duration",
    Gift = "gift",
    Installation = "installation",
    Misc = "misc",
    Other = "other",
    Outplan = "outplan",
    Quantity = "quantity",
    Special = "special",
    Voucher = "voucher",
}

/** Representation of a service pricing */
export class Pricing implements IPricing {
    /** Capacities of the pricing (type of pricing) */
    readonly capacities?: GenericProductPricingCapacitiesEnum[];
    /** Description of the pricing */
    readonly description?: string;
    /** Default renew interval displayed using ISO8601 */
    readonly duration?: string;
    /** Pricing's engagement configuration */
    readonly engagementConfiguration?: EngagementConfiguration | undefined;
    /** Interval of renewal */
    readonly interval?: number;
    /** Maximum quantity that can be ordered */
    readonly maximumQuantity?: number | undefined;
    /** Maximum repeat for renewal */
    readonly maximumRepeat?: number | undefined;
    /** Minimum quantity that can be ordered */
    readonly minimumQuantity?: number;
    /** Minimum repeat for renewal */
    readonly minimumRepeat?: number;
    /** Price of the product */
    readonly price?: Price;
    /** Price of the product in micro-centims */
    readonly priceInUcents?: number;
    /** Pricing model identifier */
    readonly pricingMode?: string;
    /** Pricing type */
    readonly pricingType?: GenericProductPricingTypeEnum;

    [key: string]: any;

    constructor(data?: IPricing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["capacities"])) {
                (<any>this).capacities = [] as any;
                for (let item of _data["capacities"])
                    (<any>this).capacities!.push(item);
            }
            (<any>this).description = _data["description"];
            (<any>this).duration = _data["duration"];
            (<any>this).engagementConfiguration = _data["engagementConfiguration"] ? EngagementConfiguration.fromJS(_data["engagementConfiguration"]) : <any>undefined;
            (<any>this).interval = _data["interval"];
            (<any>this).maximumQuantity = _data["maximumQuantity"];
            (<any>this).maximumRepeat = _data["maximumRepeat"];
            (<any>this).minimumQuantity = _data["minimumQuantity"];
            (<any>this).minimumRepeat = _data["minimumRepeat"];
            (<any>this).price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            (<any>this).priceInUcents = _data["priceInUcents"];
            (<any>this).pricingMode = _data["pricingMode"];
            (<any>this).pricingType = _data["pricingType"];
        }
    }

    static fromJS(data: any): Pricing {
        data = typeof data === 'object' ? data : {};
        let result = new Pricing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.capacities)) {
            data["capacities"] = [];
            for (let item of this.capacities)
                data["capacities"].push(item);
        }
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["engagementConfiguration"] = this.engagementConfiguration ? this.engagementConfiguration.toJSON() : <any>undefined;
        data["interval"] = this.interval;
        data["maximumQuantity"] = this.maximumQuantity;
        data["maximumRepeat"] = this.maximumRepeat;
        data["minimumQuantity"] = this.minimumQuantity;
        data["minimumRepeat"] = this.minimumRepeat;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["priceInUcents"] = this.priceInUcents;
        data["pricingMode"] = this.pricingMode;
        data["pricingType"] = this.pricingType;
        return data;
    }
}

/** Representation of a service pricing */
export interface IPricing {
    /** Capacities of the pricing (type of pricing) */
    capacities?: GenericProductPricingCapacitiesEnum[];
    /** Description of the pricing */
    description?: string;
    /** Default renew interval displayed using ISO8601 */
    duration?: string;
    /** Pricing's engagement configuration */
    engagementConfiguration?: EngagementConfiguration | undefined;
    /** Interval of renewal */
    interval?: number;
    /** Maximum quantity that can be ordered */
    maximumQuantity?: number | undefined;
    /** Maximum repeat for renewal */
    maximumRepeat?: number | undefined;
    /** Minimum quantity that can be ordered */
    minimumQuantity?: number;
    /** Minimum repeat for renewal */
    minimumRepeat?: number;
    /** Price of the product */
    price?: Price;
    /** Price of the product in micro-centims */
    priceInUcents?: number;
    /** Pricing model identifier */
    pricingMode?: string;
    /** Pricing type */
    pricingType?: GenericProductPricingTypeEnum;

    [key: string]: any;
}

/** Configuration of an engagement triggered by a given pricing */
export class EngagementConfiguration implements IEngagementConfiguration {
    /** Default action executed once the engagement is fully consumed */
    readonly defaultEndAction?: EndStrategyEnum;
    /** Engagement's duration displayed using ISO8601 */
    readonly duration?: string;
    /** Engagement type, either fully pre-paid (upfront) or periodically paid up to engagement duration (periodic) */
    readonly type?: TypeEnum;

    [key: string]: any;

    constructor(data?: IEngagementConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).defaultEndAction = _data["defaultEndAction"];
            (<any>this).duration = _data["duration"];
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): EngagementConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultEndAction"] = this.defaultEndAction;
        data["duration"] = this.duration;
        data["type"] = this.type;
        return data;
    }
}

/** Configuration of an engagement triggered by a given pricing */
export interface IEngagementConfiguration {
    /** Default action executed once the engagement is fully consumed */
    defaultEndAction?: EndStrategyEnum;
    /** Engagement's duration displayed using ISO8601 */
    duration?: string;
    /** Engagement type, either fully pre-paid (upfront) or periodically paid up to engagement duration (periodic) */
    type?: TypeEnum;

    [key: string]: any;
}

/** Description of the rule applied at the end of the Engagement */
export class EndRule implements IEndRule {
    /** Describes the possible strategies for this Engagement */
    readonly possibleStrategies?: EndStrategyEnum[];
    /** Strategy applied at the end */
    readonly strategy?: EndStrategyEnum;

    [key: string]: any;

    constructor(data?: IEndRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["possibleStrategies"])) {
                (<any>this).possibleStrategies = [] as any;
                for (let item of _data["possibleStrategies"])
                    (<any>this).possibleStrategies!.push(item);
            }
            (<any>this).strategy = _data["strategy"];
        }
    }

    static fromJS(data: any): EndRule {
        data = typeof data === 'object' ? data : {};
        let result = new EndRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.possibleStrategies)) {
            data["possibleStrategies"] = [];
            for (let item of this.possibleStrategies)
                data["possibleStrategies"].push(item);
        }
        data["strategy"] = this.strategy;
        return data;
    }
}

/** Description of the rule applied at the end of the Engagement */
export interface IEndRule {
    /** Describes the possible strategies for this Engagement */
    possibleStrategies?: EndStrategyEnum[];
    /** Strategy applied at the end */
    strategy?: EndStrategyEnum;

    [key: string]: any;
}

/** Strategy applicable at the end of the Engagement */
export enum EndStrategyEnum {
    CANCEL_SERVICE = "CANCEL_SERVICE",
    REACTIVATE_ENGAGEMENT = "REACTIVATE_ENGAGEMENT",
    STOP_ENGAGEMENT_FALLBACK_DEFAULT_PRICE = "STOP_ENGAGEMENT_FALLBACK_DEFAULT_PRICE",
    STOP_ENGAGEMENT_KEEP_PRICE = "STOP_ENGAGEMENT_KEEP_PRICE",
}

/** Description of an Engagement */
export class Engagement implements IEngagement {
    /** Current engagement period */
    readonly currentPeriod?: EngagementPeriod;
    /** Describes the rule applied at the end of the Engagement */
    readonly endRule?: EndRule | undefined;

    [key: string]: any;

    constructor(data?: IEngagement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).currentPeriod = _data["currentPeriod"] ? EngagementPeriod.fromJS(_data["currentPeriod"]) : <any>undefined;
            (<any>this).endRule = _data["endRule"] ? EndRule.fromJS(_data["endRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Engagement {
        data = typeof data === 'object' ? data : {};
        let result = new Engagement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["currentPeriod"] = this.currentPeriod ? this.currentPeriod.toJSON() : <any>undefined;
        data["endRule"] = this.endRule ? this.endRule.toJSON() : <any>undefined;
        return data;
    }
}

/** Description of an Engagement */
export interface IEngagement {
    /** Current engagement period */
    currentPeriod?: EngagementPeriod;
    /** Describes the rule applied at the end of the Engagement */
    endRule?: EndRule | undefined;

    [key: string]: any;
}

/** Order created when flushing the engagement of a service */
export class EngagementFlushOrder implements IEngagementFlushOrder {
    /** Order created to flush the engagement of the service */
    readonly order?: Order;

    [key: string]: any;

    constructor(data?: IEngagementFlushOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EngagementFlushOrder {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementFlushOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        return data;
    }
}

/** Order created when flushing the engagement of a service */
export interface IEngagementFlushOrder {
    /** Order created to flush the engagement of the service */
    order?: Order;

    [key: string]: any;
}

/** Parameters needed to flush the engagement */
export class EngagementFlushRequest implements IEngagementFlushRequest {
    /** Indicates that order, if needed, will be automatically paid with preferred payment method */
    autoPayWithPreferredPaymentMethod?: boolean;
    /** If false, the order will be registered; if true, the order will be returned but not registered. Useful to compute prices */
    dryRun?: boolean;
    /** If true, when the order will be paid, the service termination workflow will automatically be started */
    terminateSubscription?: boolean;

    [key: string]: any;

    constructor(data?: IEngagementFlushRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.autoPayWithPreferredPaymentMethod = _data["autoPayWithPreferredPaymentMethod"];
            this.dryRun = _data["dryRun"];
            this.terminateSubscription = _data["terminateSubscription"];
        }
    }

    static fromJS(data: any): EngagementFlushRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementFlushRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["autoPayWithPreferredPaymentMethod"] = this.autoPayWithPreferredPaymentMethod;
        data["dryRun"] = this.dryRun;
        data["terminateSubscription"] = this.terminateSubscription;
        return data;
    }
}

/** Parameters needed to flush the engagement */
export interface IEngagementFlushRequest {
    /** Indicates that order, if needed, will be automatically paid with preferred payment method */
    autoPayWithPreferredPaymentMethod?: boolean;
    /** If false, the order will be registered; if true, the order will be returned but not registered. Useful to compute prices */
    dryRun?: boolean;
    /** If true, when the order will be paid, the service termination workflow will automatically be started */
    terminateSubscription?: boolean;

    [key: string]: any;
}

/** Period of Engagement */
export class EngagementPeriod implements IEngagementPeriod {
    /** End of the period */
    readonly endDate?: Date | undefined;
    /** Beginning of the period */
    readonly startDate?: Date;

    [key: string]: any;

    constructor(data?: IEngagementPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).endDate = _data["endDate"] ? parseDateOnly(_data["endDate"].toString()) : <any>undefined;
            (<any>this).startDate = _data["startDate"] ? parseDateOnly(_data["startDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EngagementPeriod {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementPeriod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        return data;
    }
}

/** Period of Engagement */
export interface IEngagementPeriod {
    /** End of the period */
    endDate?: Date | undefined;
    /** Beginning of the period */
    startDate?: Date;

    [key: string]: any;
}

/** Ongoing Engagement request on a Service */
export class EngagementRequest implements IEngagementRequest {
    /** Option Pricings this request will migrate the Services to */
    readonly options?: EngagementRequestOption[];
    /** If not null, Order to pay in order to trigger the Engagement */
    readonly order?: Order | undefined;
    /** Pricing this request will migrate the Service to */
    readonly pricing?: Pricing;
    /** Date the request was made on */
    readonly requestDate?: Date;

    [key: string]: any;

    constructor(data?: IEngagementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["options"])) {
                (<any>this).options = [] as any;
                for (let item of _data["options"])
                    (<any>this).options!.push(EngagementRequestOption.fromJS(item));
            }
            (<any>this).order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            (<any>this).pricing = _data["pricing"] ? Pricing.fromJS(_data["pricing"]) : <any>undefined;
            (<any>this).requestDate = _data["requestDate"] ? parseDateOnly(_data["requestDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EngagementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["pricing"] = this.pricing ? this.pricing.toJSON() : <any>undefined;
        data["requestDate"] = this.requestDate ? formatDate(this.requestDate) : <any>undefined;
        return data;
    }
}

/** Ongoing Engagement request on a Service */
export interface IEngagementRequest {
    /** Option Pricings this request will migrate the Services to */
    options?: EngagementRequestOption[];
    /** If not null, Order to pay in order to trigger the Engagement */
    order?: Order | undefined;
    /** Pricing this request will migrate the Service to */
    pricing?: Pricing;
    /** Date the request was made on */
    requestDate?: Date;

    [key: string]: any;
}

/** Parameters needed to create an Engagement */
export class EngagementRequestCreation implements IEngagementRequestCreation {
    /** Pricing mode to use in order to engage the Service */
    pricingMode!: string;

    [key: string]: any;

    constructor(data?: IEngagementRequestCreation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.pricingMode = _data["pricingMode"];
        }
    }

    static fromJS(data: any): EngagementRequestCreation {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementRequestCreation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["pricingMode"] = this.pricingMode;
        return data;
    }
}

/** Parameters needed to create an Engagement */
export interface IEngagementRequestCreation {
    /** Pricing mode to use in order to engage the Service */
    pricingMode: string;

    [key: string]: any;
}

/** Pricing detail for an Ongoing Engagement request on an option Service */
export class EngagementRequestOption implements IEngagementRequestOption {
    /** Pricing this request will migrate the option Service to */
    readonly pricing?: Pricing;
    /** Service ID */
    readonly serviceId?: number;

    [key: string]: any;

    constructor(data?: IEngagementRequestOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).pricing = _data["pricing"] ? Pricing.fromJS(_data["pricing"]) : <any>undefined;
            (<any>this).serviceId = _data["serviceId"];
        }
    }

    static fromJS(data: any): EngagementRequestOption {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementRequestOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["pricing"] = this.pricing ? this.pricing.toJSON() : <any>undefined;
        data["serviceId"] = this.serviceId;
        return data;
    }
}

/** Pricing detail for an Ongoing Engagement request on an option Service */
export interface IEngagementRequestOption {
    /** Pricing this request will migrate the option Service to */
    pricing?: Pricing;
    /** Service ID */
    serviceId?: number;

    [key: string]: any;
}

/** Engagement's type, either fully pre-paid (upfront) or periodically paid up to engagement duration (periodic) */
export enum TypeEnum {
    Periodic = "periodic",
    Upfront = "upfront",
}

/** Update your Engagement end rules */
export class UpdateEndRuleRequest implements IUpdateEndRuleRequest {
    /** Strategy applied at the end of the Engagement */
    strategy!: EndStrategyEnum;

    [key: string]: any;

    constructor(data?: IUpdateEndRuleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.strategy = _data["strategy"];
        }
    }

    static fromJS(data: any): UpdateEndRuleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEndRuleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["strategy"] = this.strategy;
        return data;
    }
}

/** Update your Engagement end rules */
export interface IUpdateEndRuleRequest {
    /** Strategy applied at the end of the Engagement */
    strategy: EndStrategyEnum;

    [key: string]: any;
}

/** Service change contact payload */
export class ChangeContact implements IChangeContact {
    /** The contact to set as admin contact */
    contactAdmin?: string;
    /** The contact to set as billing contact */
    contactBilling?: string;
    /** The contact to set as tech contact */
    contactTech?: string;

    [key: string]: any;

    constructor(data?: IChangeContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contactAdmin = _data["contactAdmin"];
            this.contactBilling = _data["contactBilling"];
            this.contactTech = _data["contactTech"];
        }
    }

    static fromJS(data: any): ChangeContact {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contactAdmin"] = this.contactAdmin;
        data["contactBilling"] = this.contactBilling;
        data["contactTech"] = this.contactTech;
        return data;
    }
}

/** Service change contact payload */
export interface IChangeContact {
    /** The contact to set as admin contact */
    contactAdmin?: string;
    /** The contact to set as billing contact */
    contactBilling?: string;
    /** The contact to set as tech contact */
    contactTech?: string;

    [key: string]: any;
}

/** Service confirm termination payload */
export class ConfirmTermination implements IConfirmTermination {
    /** Commentary about your termination request */
    commentary?: string;
    /** All future uses you can provide for a service termination */
    futureUse?: TerminationFutureUseEnum;
    /** All reasons you can provide for a service termination */
    reason?: TerminationReasonEnum;
    /** The termination token sent by email to the admin contact */
    token!: string;

    [key: string]: any;

    constructor(data?: IConfirmTermination) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.commentary = _data["commentary"];
            this.futureUse = _data["futureUse"];
            this.reason = _data["reason"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmTermination {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmTermination();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["commentary"] = this.commentary;
        data["futureUse"] = this.futureUse;
        data["reason"] = this.reason;
        data["token"] = this.token;
        return data;
    }
}

/** Service confirm termination payload */
export interface IConfirmTermination {
    /** Commentary about your termination request */
    commentary?: string;
    /** All future uses you can provide for a service termination */
    futureUse?: TerminationFutureUseEnum;
    /** All reasons you can provide for a service termination */
    reason?: TerminationReasonEnum;
    /** The termination token sent by email to the admin contact */
    token: string;

    [key: string]: any;
}

/** Element's quantity consumed for a given time range */
export class Detail implements IDetail {
    /** Begin date */
    readonly beginDate?: Date | undefined;
    /** End date */
    readonly endDate?: Date | undefined;
    /** Pricing mode used during detail's time period */
    readonly pricingMode?: string;
    /** Consumed quantity */
    readonly quantity?: number;

    [key: string]: any;

    constructor(data?: IDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).beginDate = _data["beginDate"] ? new Date(_data["beginDate"].toString()) : <any>undefined;
            (<any>this).endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            (<any>this).pricingMode = _data["pricingMode"];
            (<any>this).quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): Detail {
        data = typeof data === 'object' ? data : {};
        let result = new Detail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["beginDate"] = this.beginDate ? this.beginDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["pricingMode"] = this.pricingMode;
        data["quantity"] = this.quantity;
        return data;
    }
}

/** Element's quantity consumed for a given time range */
export interface IDetail {
    /** Begin date */
    beginDate?: Date | undefined;
    /** End date */
    endDate?: Date | undefined;
    /** Pricing mode used during detail's time period */
    pricingMode?: string;
    /** Consumed quantity */
    quantity?: number;

    [key: string]: any;
}

/** Consumption information for a specific offer */
export class Element implements IElement {
    /** List of consumption details for this element */
    readonly details?: Detail[];
    /** List of metadata related to this element */
    readonly metadata?: SafeKeyValue_string[] | undefined;
    /** Identifier of the offer */
    readonly planCode?: string;
    /** Family of the offer */
    readonly planFamily?: string;
    /** Total price of the element */
    readonly price?: Price;
    /** Consumed quantity */
    readonly quantity?: number;
    /** Unique ID of the consumed resource */
    readonly uniqueId?: string | undefined;

    [key: string]: any;

    constructor(data?: IElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["details"])) {
                (<any>this).details = [] as any;
                for (let item of _data["details"])
                    (<any>this).details!.push(Detail.fromJS(item));
            }
            if (Array.isArray(_data["metadata"])) {
                (<any>this).metadata = [] as any;
                for (let item of _data["metadata"])
                    (<any>this).metadata!.push(SafeKeyValue_string.fromJS(item));
            }
            (<any>this).planCode = _data["planCode"];
            (<any>this).planFamily = _data["planFamily"];
            (<any>this).price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            (<any>this).quantity = _data["quantity"];
            (<any>this).uniqueId = _data["uniqueId"];
        }
    }

    static fromJS(data: any): Element {
        data = typeof data === 'object' ? data : {};
        let result = new Element();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.details)) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        if (Array.isArray(this.metadata)) {
            data["metadata"] = [];
            for (let item of this.metadata)
                data["metadata"].push(item.toJSON());
        }
        data["planCode"] = this.planCode;
        data["planFamily"] = this.planFamily;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["uniqueId"] = this.uniqueId;
        return data;
    }
}

/** Consumption information for a specific offer */
export interface IElement {
    /** List of consumption details for this element */
    details?: Detail[];
    /** List of metadata related to this element */
    metadata?: SafeKeyValue_string[] | undefined;
    /** Identifier of the offer */
    planCode?: string;
    /** Family of the offer */
    planFamily?: string;
    /** Total price of the element */
    price?: Price;
    /** Consumed quantity */
    quantity?: number;
    /** Unique ID of the consumed resource */
    uniqueId?: string | undefined;

    [key: string]: any;
}

/** Consumed amount for a given commercial offer's family */
export class PricePlanFamily implements IPricePlanFamily {
    /** Commercial offer's range */
    readonly planFamily?: string;
    /** Consumed amount by resources related to the given family */
    readonly price?: Price;

    [key: string]: any;

    constructor(data?: IPricePlanFamily) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).planFamily = _data["planFamily"];
            (<any>this).price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PricePlanFamily {
        data = typeof data === 'object' ? data : {};
        let result = new PricePlanFamily();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["planFamily"] = this.planFamily;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        return data;
    }
}

/** Consumed amount for a given commercial offer's family */
export interface IPricePlanFamily {
    /** Commercial offer's range */
    planFamily?: string;
    /** Consumed amount by resources related to the given family */
    price?: Price;

    [key: string]: any;
}

/** Summary of the consumption of a service */
export class Summary implements ISummary {
    /** Begin date of the returned consumption snapshot */
    readonly beginDate?: Date;
    /** End date of the returned consumption snapshot */
    readonly endDate?: Date;
    /** Consumption transaction ID */
    readonly id?: number;
    /** Order ID */
    readonly orderId?: number | undefined;
    /** Total price of the service's consumption */
    readonly price?: Price;
    /** All the categories of commercial offers involved in the consumption of the service and their price */
    readonly priceByPlanFamily?: PricePlanFamily[];
    /** Service ID */
    readonly serviceId?: number;

    [key: string]: any;

    constructor(data?: ISummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).beginDate = _data["beginDate"] ? new Date(_data["beginDate"].toString()) : <any>undefined;
            (<any>this).endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            (<any>this).id = _data["id"];
            (<any>this).orderId = _data["orderId"];
            (<any>this).price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            if (Array.isArray(_data["priceByPlanFamily"])) {
                (<any>this).priceByPlanFamily = [] as any;
                for (let item of _data["priceByPlanFamily"])
                    (<any>this).priceByPlanFamily!.push(PricePlanFamily.fromJS(item));
            }
            (<any>this).serviceId = _data["serviceId"];
        }
    }

    static fromJS(data: any): Summary {
        data = typeof data === 'object' ? data : {};
        let result = new Summary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["beginDate"] = this.beginDate ? this.beginDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["orderId"] = this.orderId;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        if (Array.isArray(this.priceByPlanFamily)) {
            data["priceByPlanFamily"] = [];
            for (let item of this.priceByPlanFamily)
                data["priceByPlanFamily"].push(item.toJSON());
        }
        data["serviceId"] = this.serviceId;
        return data;
    }
}

/** Summary of the consumption of a service */
export interface ISummary {
    /** Begin date of the returned consumption snapshot */
    beginDate?: Date;
    /** End date of the returned consumption snapshot */
    endDate?: Date;
    /** Consumption transaction ID */
    id?: number;
    /** Order ID */
    orderId?: number | undefined;
    /** Total price of the service's consumption */
    price?: Price;
    /** All the categories of commercial offers involved in the consumption of the service and their price */
    priceByPlanFamily?: PricePlanFamily[];
    /** Service ID */
    serviceId?: number;

    [key: string]: any;
}

/** Contact change request */
export class ContactChangeRequest implements IContactChangeRequest {
    /** List of accounts you want to be considered as 'admin' of the service */
    admin!: string[];
    /** List of accounts you want to be considered as 'billing' contact */
    billing!: string[];
    /** List of accounts you want to be considered as 'technical' contact */
    technical!: string[];

    [key: string]: any;

    constructor(data?: IContactChangeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.admin = [];
            this.billing = [];
            this.technical = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["admin"])) {
                this.admin = [] as any;
                for (let item of _data["admin"])
                    this.admin!.push(item);
            }
            if (Array.isArray(_data["billing"])) {
                this.billing = [] as any;
                for (let item of _data["billing"])
                    this.billing!.push(item);
            }
            if (Array.isArray(_data["technical"])) {
                this.technical = [] as any;
                for (let item of _data["technical"])
                    this.technical!.push(item);
            }
        }
    }

    static fromJS(data: any): ContactChangeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ContactChangeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.admin)) {
            data["admin"] = [];
            for (let item of this.admin)
                data["admin"].push(item);
        }
        if (Array.isArray(this.billing)) {
            data["billing"] = [];
            for (let item of this.billing)
                data["billing"].push(item);
        }
        if (Array.isArray(this.technical)) {
            data["technical"] = [];
            for (let item of this.technical)
                data["technical"].push(item);
        }
        return data;
    }
}

/** Contact change request */
export interface IContactChangeRequest {
    /** List of accounts you want to be considered as 'admin' of the service */
    admin: string[];
    /** List of accounts you want to be considered as 'billing' contact */
    billing: string[];
    /** List of accounts you want to be considered as 'technical' contact */
    technical: string[];

    [key: string]: any;
}

/** Contact change task */
export class Task implements ITask {
    /** Unique identifier of the Task */
    readonly id?: number;
    /** Computed API route to fetch and manage the Task created */
    readonly route?: string;

    [key: string]: any;

    constructor(data?: ITask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).id = _data["id"];
            (<any>this).route = _data["route"];
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["route"] = this.route;
        return data;
    }
}

/** Contact change task */
export interface ITask {
    /** Unique identifier of the Task */
    id?: number;
    /** Computed API route to fetch and manage the Task created */
    route?: string;

    [key: string]: any;
}

/** Billing information of the service */
export class Billing implements IBilling {
    /** Engagement summary for this Service */
    readonly engagement?: EngagementSummary | undefined;
    /** Ongoing engagement request summary for this Service */
    readonly engagementRequest?: EngagementRequestSummary | undefined;
    /** Expiration date */
    readonly expirationDate?: Date | undefined;
    /** Group information */
    readonly group?: Group | undefined;
    /** Service life cycle */
    readonly lifecycle?: Lifecycle | undefined;
    /** Next billing date */
    readonly nextBillingDate?: Date | undefined;
    /** Service Plan */
    readonly plan?: Plan | undefined;
    /** Service current Pricing */
    readonly pricing?: Pricing | undefined;
    /** Service life renew */
    readonly renew?: Renew | undefined;

    [key: string]: any;

    constructor(data?: IBilling) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).engagement = _data["engagement"] ? EngagementSummary.fromJS(_data["engagement"]) : <any>undefined;
            (<any>this).engagementRequest = _data["engagementRequest"] ? EngagementRequestSummary.fromJS(_data["engagementRequest"]) : <any>undefined;
            (<any>this).expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            (<any>this).group = _data["group"] ? Group.fromJS(_data["group"]) : <any>undefined;
            (<any>this).lifecycle = _data["lifecycle"] ? Lifecycle.fromJS(_data["lifecycle"]) : <any>undefined;
            (<any>this).nextBillingDate = _data["nextBillingDate"] ? new Date(_data["nextBillingDate"].toString()) : <any>undefined;
            (<any>this).plan = _data["plan"] ? Plan.fromJS(_data["plan"]) : <any>undefined;
            (<any>this).pricing = _data["pricing"] ? Pricing.fromJS(_data["pricing"]) : <any>undefined;
            (<any>this).renew = _data["renew"] ? Renew.fromJS(_data["renew"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Billing {
        data = typeof data === 'object' ? data : {};
        let result = new Billing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["engagement"] = this.engagement ? this.engagement.toJSON() : <any>undefined;
        data["engagementRequest"] = this.engagementRequest ? this.engagementRequest.toJSON() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["lifecycle"] = this.lifecycle ? this.lifecycle.toJSON() : <any>undefined;
        data["nextBillingDate"] = this.nextBillingDate ? this.nextBillingDate.toISOString() : <any>undefined;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["pricing"] = this.pricing ? this.pricing.toJSON() : <any>undefined;
        data["renew"] = this.renew ? this.renew.toJSON() : <any>undefined;
        return data;
    }
}

/** Billing information of the service */
export interface IBilling {
    /** Engagement summary for this Service */
    engagement?: EngagementSummary | undefined;
    /** Ongoing engagement request summary for this Service */
    engagementRequest?: EngagementRequestSummary | undefined;
    /** Expiration date */
    expirationDate?: Date | undefined;
    /** Group information */
    group?: Group | undefined;
    /** Service life cycle */
    lifecycle?: Lifecycle | undefined;
    /** Next billing date */
    nextBillingDate?: Date | undefined;
    /** Service Plan */
    plan?: Plan | undefined;
    /** Service current Pricing */
    pricing?: Pricing | undefined;
    /** Service life renew */
    renew?: Renew | undefined;

    [key: string]: any;
}

/** Customer service relative information */
export class Customer implements ICustomer {
    /** Customer contact list */
    readonly contacts?: Contact[];

    [key: string]: any;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["contacts"])) {
                (<any>this).contacts = [] as any;
                for (let item of _data["contacts"])
                    (<any>this).contacts!.push(Contact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.contacts)) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        return data;
    }
}

/** Customer service relative information */
export interface ICustomer {
    /** Customer contact list */
    contacts?: Contact[];

    [key: string]: any;
}

/** Customer contact service relative information */
export class Contact implements IContact {
    /** Customer code */
    readonly customerCode?: string;
    /** Type of customer contact */
    readonly type?: TypeEnum2;

    [key: string]: any;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).customerCode = _data["customerCode"];
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["customerCode"] = this.customerCode;
        data["type"] = this.type;
        return data;
    }
}

/** Customer contact service relative information */
export interface IContact {
    /** Customer code */
    customerCode?: string;
    /** Type of customer contact */
    type?: TypeEnum2;

    [key: string]: any;
}

/** Typology of customer contact */
export enum TypeEnum2 {
    Administrator = "administrator",
    Billing = "billing",
    Technical = "technical",
}

/** Engagement request summary for a Service */
export class EngagementRequestSummary implements IEngagementRequestSummary {
    /** Future pricing mode of the service, when the request has been processed */
    readonly pricingMode?: string;
    /** Date on which the request has been made */
    readonly requestDate?: Date;

    [key: string]: any;

    constructor(data?: IEngagementRequestSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).pricingMode = _data["pricingMode"];
            (<any>this).requestDate = _data["requestDate"] ? parseDateOnly(_data["requestDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EngagementRequestSummary {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementRequestSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["pricingMode"] = this.pricingMode;
        data["requestDate"] = this.requestDate ? formatDate(this.requestDate) : <any>undefined;
        return data;
    }
}

/** Engagement request summary for a Service */
export interface IEngagementRequestSummary {
    /** Future pricing mode of the service, when the request has been processed */
    pricingMode?: string;
    /** Date on which the request has been made */
    requestDate?: Date;

    [key: string]: any;
}

/** Engagement summary for a Service */
export class EngagementSummary implements IEngagementSummary {
    /** Engagement end date */
    readonly endDate?: Date | undefined;
    /** Describes the rule applied at the end of the Engagement */
    readonly endRule?: EndRule | undefined;

    [key: string]: any;

    constructor(data?: IEngagementSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).endDate = _data["endDate"] ? parseDateOnly(_data["endDate"].toString()) : <any>undefined;
            (<any>this).endRule = _data["endRule"] ? EndRule.fromJS(_data["endRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EngagementSummary {
        data = typeof data === 'object' ? data : {};
        let result = new EngagementSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["endRule"] = this.endRule ? this.endRule.toJSON() : <any>undefined;
        return data;
    }
}

/** Engagement summary for a Service */
export interface IEngagementSummary {
    /** Engagement end date */
    endDate?: Date | undefined;
    /** Describes the rule applied at the end of the Engagement */
    endRule?: EndRule | undefined;

    [key: string]: any;
}

/** Billing group of the service */
export class Group implements IGroup {
    /** Billing group id */
    readonly id?: number;

    [key: string]: any;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

/** Billing group of the service */
export interface IGroup {
    /** Billing group id */
    id?: number;

    [key: string]: any;
}

/** Service life cycle */
export class Lifecycle implements ILifecycle {
    /** Life cycle capacities */
    readonly capacities?: Capacities;
    /** Current life cycle configuration */
    readonly current?: Current;

    [key: string]: any;

    constructor(data?: ILifecycle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).capacities = _data["capacities"] ? Capacities.fromJS(_data["capacities"]) : <any>undefined;
            (<any>this).current = _data["current"] ? Current.fromJS(_data["current"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Lifecycle {
        data = typeof data === 'object' ? data : {};
        let result = new Lifecycle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["capacities"] = this.capacities ? this.capacities.toJSON() : <any>undefined;
        data["current"] = this.current ? this.current.toJSON() : <any>undefined;
        return data;
    }
}

/** Service life cycle */
export interface ILifecycle {
    /** Life cycle capacities */
    capacities?: Capacities;
    /** Current life cycle configuration */
    current?: Current;

    [key: string]: any;
}

/** Life cycle action */
export enum ActionEnum {
    EarlyRenewal = "earlyRenewal",
    Terminate = "terminate",
    TerminateAtEngagementDate = "terminateAtEngagementDate",
    TerminateAtExpirationDate = "terminateAtExpirationDate",
}

/** Service life cycle options */
export class Capacities implements ICapacities {
    /** Possible actions */
    readonly actions?: ActionEnum[];

    [key: string]: any;

    constructor(data?: ICapacities) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["actions"])) {
                (<any>this).actions = [] as any;
                for (let item of _data["actions"])
                    (<any>this).actions!.push(item);
            }
        }
    }

    static fromJS(data: any): Capacities {
        data = typeof data === 'object' ? data : {};
        let result = new Capacities();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        return data;
    }
}

/** Service life cycle options */
export interface ICapacities {
    /** Possible actions */
    actions?: ActionEnum[];

    [key: string]: any;
}

/** Current life cycle configuration */
export class Current implements ICurrent {
    /** Service creation date */
    readonly creationDate?: Date | undefined;
    /** Pending actions */
    readonly pendingActions?: ActionEnum[];
    /** Current life cycle state */
    readonly state?: StateEnum2;
    /** Scheduled termination date */
    readonly terminationDate?: Date | undefined;

    [key: string]: any;

    constructor(data?: ICurrent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["pendingActions"])) {
                (<any>this).pendingActions = [] as any;
                for (let item of _data["pendingActions"])
                    (<any>this).pendingActions!.push(item);
            }
            (<any>this).state = _data["state"];
            (<any>this).terminationDate = _data["terminationDate"] ? new Date(_data["terminationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Current {
        data = typeof data === 'object' ? data : {};
        let result = new Current();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.pendingActions)) {
            data["pendingActions"] = [];
            for (let item of this.pendingActions)
                data["pendingActions"].push(item);
        }
        data["state"] = this.state;
        data["terminationDate"] = this.terminationDate ? this.terminationDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Current life cycle configuration */
export interface ICurrent {
    /** Service creation date */
    creationDate?: Date | undefined;
    /** Pending actions */
    pendingActions?: ActionEnum[];
    /** Current life cycle state */
    state?: StateEnum2;
    /** Scheduled termination date */
    terminationDate?: Date | undefined;

    [key: string]: any;
}

/** Life cycle service state */
export enum StateEnum2 {
    Active = "active",
    Error = "error",
    Rupture = "rupture",
    Terminated = "terminated",
    ToRenew = "toRenew",
    Unpaid = "unpaid",
    Unrenewed = "unrenewed",
}

/** Plan of the service */
export class Plan implements IPlan {
    /** Plan code */
    readonly code?: string;
    /** Invoice Name */
    readonly invoiceName?: string;

    [key: string]: any;

    constructor(data?: IPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).code = _data["code"];
            (<any>this).invoiceName = _data["invoiceName"];
        }
    }

    static fromJS(data: any): Plan {
        data = typeof data === 'object' ? data : {};
        let result = new Plan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["invoiceName"] = this.invoiceName;
        return data;
    }
}

/** Plan of the service */
export interface IPlan {
    /** Plan code */
    code?: string;
    /** Invoice Name */
    invoiceName?: string;

    [key: string]: any;
}

/** Product of the service */
export class Product implements IProduct {
    /** Product description */
    readonly description?: string;
    /** Product name */
    readonly name?: string;

    [key: string]: any;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).description = _data["description"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Product of the service */
export interface IProduct {
    /** Product description */
    description?: string;
    /** Product name */
    name?: string;

    [key: string]: any;
}

/** Service renew information */
export class Renew implements IRenew {
    /** Renew capacities */
    readonly capacities?: Capacities2;
    /** Current renew configuration */
    readonly current?: Current2;

    [key: string]: any;

    constructor(data?: IRenew) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).capacities = _data["capacities"] ? Capacities2.fromJS(_data["capacities"]) : <any>undefined;
            (<any>this).current = _data["current"] ? Current2.fromJS(_data["current"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Renew {
        data = typeof data === 'object' ? data : {};
        let result = new Renew();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["capacities"] = this.capacities ? this.capacities.toJSON() : <any>undefined;
        data["current"] = this.current ? this.current.toJSON() : <any>undefined;
        return data;
    }
}

/** Service renew information */
export interface IRenew {
    /** Renew capacities */
    capacities?: Capacities2;
    /** Current renew configuration */
    current?: Current2;

    [key: string]: any;
}

/** Service renew capacities */
export class Capacities2 implements ICapacities2 {
    /** Renew mode capacities */
    readonly mode?: ModeEnum[];

    [key: string]: any;

    constructor(data?: ICapacities2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["mode"])) {
                (<any>this).mode = [] as any;
                for (let item of _data["mode"])
                    (<any>this).mode!.push(item);
            }
        }
    }

    static fromJS(data: any): Capacities2 {
        data = typeof data === 'object' ? data : {};
        let result = new Capacities2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.mode)) {
            data["mode"] = [];
            for (let item of this.mode)
                data["mode"].push(item);
        }
        return data;
    }
}

/** Service renew capacities */
export interface ICapacities2 {
    /** Renew mode capacities */
    mode?: ModeEnum[];

    [key: string]: any;
}

/** Current renew configuration */
export class Current2 implements ICurrent2 {
    /** Renew mode */
    readonly mode?: ModeEnum | undefined;
    /** Scheduled renew date */
    readonly nextDate?: Date | undefined;
    /** Next renewal duration */
    readonly period?: string | undefined;

    [key: string]: any;

    constructor(data?: ICurrent2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).mode = _data["mode"];
            (<any>this).nextDate = _data["nextDate"] ? new Date(_data["nextDate"].toString()) : <any>undefined;
            (<any>this).period = _data["period"];
        }
    }

    static fromJS(data: any): Current2 {
        data = typeof data === 'object' ? data : {};
        let result = new Current2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mode"] = this.mode;
        data["nextDate"] = this.nextDate ? this.nextDate.toISOString() : <any>undefined;
        data["period"] = this.period;
        return data;
    }
}

/** Current renew configuration */
export interface ICurrent2 {
    /** Renew mode */
    mode?: ModeEnum | undefined;
    /** Scheduled renew date */
    nextDate?: Date | undefined;
    /** Next renewal duration */
    period?: string | undefined;

    [key: string]: any;
}

/** Renew mode */
export enum ModeEnum {
    Automatic = "automatic",
    Manual = "manual",
}

/** Reselling providers a service can be provided from */
export enum ResellingProviderEnum {
    Ovh_ca = "ovh.ca",
    Ovh_eu = "ovh.eu",
}

/** Resource of the service */
export class Resource implements IResource {
    /** Display name of the resource */
    readonly displayName?: string;
    /** Name of the resource */
    readonly name?: string;
    /** Product */
    readonly product?: Product | undefined;
    /** Reselling provider providing the service */
    readonly resellingProvider?: ResellingProviderEnum | undefined;
    /** Resource state */
    readonly state?: StateEnum3;

    [key: string]: any;

    constructor(data?: IResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).displayName = _data["displayName"];
            (<any>this).name = _data["name"];
            (<any>this).product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            (<any>this).resellingProvider = _data["resellingProvider"];
            (<any>this).state = _data["state"];
        }
    }

    static fromJS(data: any): Resource {
        data = typeof data === 'object' ? data : {};
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["resellingProvider"] = this.resellingProvider;
        data["state"] = this.state;
        return data;
    }
}

/** Resource of the service */
export interface IResource {
    /** Display name of the resource */
    displayName?: string;
    /** Name of the resource */
    name?: string;
    /** Product */
    product?: Product | undefined;
    /** Reselling provider providing the service */
    resellingProvider?: ResellingProviderEnum | undefined;
    /** Resource state */
    state?: StateEnum3;

    [key: string]: any;
}

/** Resource state */
export enum StateEnum3 {
    Active = "active",
    Deleted = "deleted",
    Suspended = "suspended",
    ToActivate = "toActivate",
    ToDelete = "toDelete",
    ToSuspend = "toSuspend",
}

/** Route of the service */
export class Route implements IRoute {
    /** Path to use in API */
    readonly path?: string | undefined;
    /** Path with variables applied */
    readonly url?: string | undefined;
    /** Variables to use in the path */
    readonly vars?: SafeKeyValue_string[];

    [key: string]: any;

    constructor(data?: IRoute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).path = _data["path"];
            (<any>this).url = _data["url"];
            if (Array.isArray(_data["vars"])) {
                (<any>this).vars = [] as any;
                for (let item of _data["vars"])
                    (<any>this).vars!.push(SafeKeyValue_string.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Route {
        data = typeof data === 'object' ? data : {};
        let result = new Route();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["path"] = this.path;
        data["url"] = this.url;
        if (Array.isArray(this.vars)) {
            data["vars"] = [];
            for (let item of this.vars)
                data["vars"].push(item.toJSON());
        }
        return data;
    }
}

/** Route of the service */
export interface IRoute {
    /** Path to use in API */
    path?: string | undefined;
    /** Path with variables applied */
    url?: string | undefined;
    /** Variables to use in the path */
    vars?: SafeKeyValue_string[];

    [key: string]: any;
}

/** Description of a service */
export class Service2 implements IService2 {
    /** Billing information */
    readonly billing?: Billing;
    /** Customer information */
    readonly customer?: Customer;
    /** Parent service ID */
    readonly parentServiceId?: number | undefined;
    /** Resource */
    readonly resource?: Resource;
    /** Route */
    readonly route?: Route | undefined;
    /** Service ID */
    readonly serviceId?: number;
    /** Service tags */
    readonly tags?: string[];

    [key: string]: any;

    constructor(data?: IService2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).billing = _data["billing"] ? Billing.fromJS(_data["billing"]) : <any>undefined;
            (<any>this).customer = _data["customer"] ? Customer.fromJS(_data["customer"]) : <any>undefined;
            (<any>this).parentServiceId = _data["parentServiceId"];
            (<any>this).resource = _data["resource"] ? Resource.fromJS(_data["resource"]) : <any>undefined;
            (<any>this).route = _data["route"] ? Route.fromJS(_data["route"]) : <any>undefined;
            (<any>this).serviceId = _data["serviceId"];
            if (Array.isArray(_data["tags"])) {
                (<any>this).tags = [] as any;
                for (let item of _data["tags"])
                    (<any>this).tags!.push(item);
            }
        }
    }

    static fromJS(data: any): Service2 {
        data = typeof data === 'object' ? data : {};
        let result = new Service2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["parentServiceId"] = this.parentServiceId;
        data["resource"] = this.resource ? this.resource.toJSON() : <any>undefined;
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["serviceId"] = this.serviceId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

/** Description of a service */
export interface IService2 {
    /** Billing information */
    billing?: Billing;
    /** Customer information */
    customer?: Customer;
    /** Parent service ID */
    parentServiceId?: number | undefined;
    /** Resource */
    resource?: Resource;
    /** Route */
    route?: Route | undefined;
    /** Service ID */
    serviceId?: number;
    /** Service tags */
    tags?: string[];

    [key: string]: any;
}

/** Technical information of a baremetal service */
export class TechnicalDetails implements ITechnicalDetails {
    readonly baremetalServers?: BaremetalServer | undefined;
    readonly nutanixCluster?: NutanixCluster | undefined;

    [key: string]: any;

    constructor(data?: ITechnicalDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).baremetalServers = _data["baremetalServers"] ? BaremetalServer.fromJS(_data["baremetalServers"]) : <any>undefined;
            (<any>this).nutanixCluster = _data["nutanixCluster"] ? NutanixCluster.fromJS(_data["nutanixCluster"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TechnicalDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TechnicalDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["baremetalServers"] = this.baremetalServers ? this.baremetalServers.toJSON() : <any>undefined;
        data["nutanixCluster"] = this.nutanixCluster ? this.nutanixCluster.toJSON() : <any>undefined;
        return data;
    }
}

/** Technical information of a baremetal service */
export interface ITechnicalDetails {
    baremetalServers?: BaremetalServer | undefined;
    nutanixCluster?: NutanixCluster | undefined;

    [key: string]: any;
}

/** Technical information on baremetal service */
export class BaremetalServer implements IBaremetalServer {
    /** Technical information on server bandwidth */
    readonly bandwidth?: Bandwidth | undefined;
    /** Technical information on server gpu */
    readonly gpu?: Gpu | undefined;
    /** Technical information on server memory */
    readonly memory?: Memory | undefined;
    /** Technical information on server type */
    readonly server?: Server | undefined;
    /** Technical information on server storage */
    readonly storage?: Storage | undefined;
    /** Technical information on server vrack */
    readonly vrack?: Vrack | undefined;

    [key: string]: any;

    constructor(data?: IBaremetalServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).bandwidth = _data["bandwidth"] ? Bandwidth.fromJS(_data["bandwidth"]) : <any>undefined;
            (<any>this).gpu = _data["gpu"] ? Gpu.fromJS(_data["gpu"]) : <any>undefined;
            (<any>this).memory = _data["memory"] ? Memory.fromJS(_data["memory"]) : <any>undefined;
            (<any>this).server = _data["server"] ? Server.fromJS(_data["server"]) : <any>undefined;
            (<any>this).storage = _data["storage"] ? Storage.fromJS(_data["storage"]) : <any>undefined;
            (<any>this).vrack = _data["vrack"] ? Vrack.fromJS(_data["vrack"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaremetalServer {
        data = typeof data === 'object' ? data : {};
        let result = new BaremetalServer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["bandwidth"] = this.bandwidth ? this.bandwidth.toJSON() : <any>undefined;
        data["gpu"] = this.gpu ? this.gpu.toJSON() : <any>undefined;
        data["memory"] = this.memory ? this.memory.toJSON() : <any>undefined;
        data["server"] = this.server ? this.server.toJSON() : <any>undefined;
        data["storage"] = this.storage ? this.storage.toJSON() : <any>undefined;
        data["vrack"] = this.vrack ? this.vrack.toJSON() : <any>undefined;
        return data;
    }
}

/** Technical information on baremetal service */
export interface IBaremetalServer {
    /** Technical information on server bandwidth */
    bandwidth?: Bandwidth | undefined;
    /** Technical information on server gpu */
    gpu?: Gpu | undefined;
    /** Technical information on server memory */
    memory?: Memory | undefined;
    /** Technical information on server type */
    server?: Server | undefined;
    /** Technical information on server storage */
    storage?: Storage | undefined;
    /** Technical information on server vrack */
    vrack?: Vrack | undefined;

    [key: string]: any;
}

/** Technical information on nutanix cluster service */
export class NutanixCluster implements INutanixCluster {
    /** Technical information on nutanix cluster */
    readonly cluster?: Cluster | undefined;
    /** Features of a cluster */
    readonly features?: Features[] | undefined;
    /** Technical details of the license of a cluster */
    readonly license?: License | undefined;
    /** Details about the service (SLA, ..) */
    readonly service?: Service3 | undefined;

    [key: string]: any;

    constructor(data?: INutanixCluster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).cluster = _data["cluster"] ? Cluster.fromJS(_data["cluster"]) : <any>undefined;
            if (Array.isArray(_data["features"])) {
                (<any>this).features = [] as any;
                for (let item of _data["features"])
                    (<any>this).features!.push(Features.fromJS(item));
            }
            (<any>this).license = _data["license"] ? License.fromJS(_data["license"]) : <any>undefined;
            (<any>this).service = _data["service"] ? Service3.fromJS(_data["service"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NutanixCluster {
        data = typeof data === 'object' ? data : {};
        let result = new NutanixCluster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["cluster"] = this.cluster ? this.cluster.toJSON() : <any>undefined;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        data["license"] = this.license ? this.license.toJSON() : <any>undefined;
        data["service"] = this.service ? this.service.toJSON() : <any>undefined;
        return data;
    }
}

/** Technical information on nutanix cluster service */
export interface INutanixCluster {
    /** Technical information on nutanix cluster */
    cluster?: Cluster | undefined;
    /** Features of a cluster */
    features?: Features[] | undefined;
    /** Technical details of the license of a cluster */
    license?: License | undefined;
    /** Details about the service (SLA, ..) */
    service?: Service3 | undefined;

    [key: string]: any;
}

/** Aggregation information */
export class Aggregation implements IAggregation {
    /** Maximum aggregated bandwidth (in Mbps) */
    readonly upTo?: number;

    [key: string]: any;

    constructor(data?: IAggregation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).upTo = _data["upTo"];
        }
    }

    static fromJS(data: any): Aggregation {
        data = typeof data === 'object' ? data : {};
        let result = new Aggregation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["upTo"] = this.upTo;
        return data;
    }
}

/** Aggregation information */
export interface IAggregation {
    /** Maximum aggregated bandwidth (in Mbps) */
    upTo?: number;

    [key: string]: any;
}

/** Technical information on bandwidth of a baremetal service */
export class Bandwidth implements IBandwidth {
    /** Aggregation information */
    readonly aggregation?: Aggregation | undefined;
    /** Bandwidth burst */
    readonly burst?: number;
    /** Guaranteed bandwith of the server */
    readonly guaranteed?: boolean;
    /** Level width of Band */
    readonly level?: number;
    /** Bandwidth limit */
    readonly limit?: number;

    [key: string]: any;

    constructor(data?: IBandwidth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).aggregation = _data["aggregation"] ? Aggregation.fromJS(_data["aggregation"]) : <any>undefined;
            (<any>this).burst = _data["burst"];
            (<any>this).guaranteed = _data["guaranteed"];
            (<any>this).level = _data["level"];
            (<any>this).limit = _data["limit"];
        }
    }

    static fromJS(data: any): Bandwidth {
        data = typeof data === 'object' ? data : {};
        let result = new Bandwidth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["aggregation"] = this.aggregation ? this.aggregation.toJSON() : <any>undefined;
        data["burst"] = this.burst;
        data["guaranteed"] = this.guaranteed;
        data["level"] = this.level;
        data["limit"] = this.limit;
        return data;
    }
}

/** Technical information on bandwidth of a baremetal service */
export interface IBandwidth {
    /** Aggregation information */
    aggregation?: Aggregation | undefined;
    /** Bandwidth burst */
    burst?: number;
    /** Guaranteed bandwith of the server */
    guaranteed?: boolean;
    /** Level width of Band */
    level?: number;
    /** Bandwidth limit */
    limit?: number;

    [key: string]: any;
}

/** Technical details for a GPU */
export class Gpu implements IGpu {
    /** GPU brand */
    readonly brand?: string;
    /** GPU memory */
    readonly memory?: GpuMemory;
    /** GPU model */
    readonly model?: string;
    /** Number of GPUs */
    readonly number?: number;

    [key: string]: any;

    constructor(data?: IGpu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).brand = _data["brand"];
            (<any>this).memory = _data["memory"] ? GpuMemory.fromJS(_data["memory"]) : <any>undefined;
            (<any>this).model = _data["model"];
            (<any>this).number = _data["number"];
        }
    }

    static fromJS(data: any): Gpu {
        data = typeof data === 'object' ? data : {};
        let result = new Gpu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["brand"] = this.brand;
        data["memory"] = this.memory ? this.memory.toJSON() : <any>undefined;
        data["model"] = this.model;
        data["number"] = this.number;
        return data;
    }
}

/** Technical details for a GPU */
export interface IGpu {
    /** GPU brand */
    brand?: string;
    /** GPU memory */
    memory?: GpuMemory;
    /** GPU model */
    model?: string;
    /** Number of GPUs */
    number?: number;

    [key: string]: any;
}

/** Technical details for a GPU Memory */
export class GpuMemory implements IGpuMemory {
    /** Memory size (in GB) */
    readonly size?: number;

    [key: string]: any;

    constructor(data?: IGpuMemory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).size = _data["size"];
        }
    }

    static fromJS(data: any): GpuMemory {
        data = typeof data === 'object' ? data : {};
        let result = new GpuMemory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["size"] = this.size;
        return data;
    }
}

/** Technical details for a GPU Memory */
export interface IGpuMemory {
    /** Memory size (in GB) */
    size?: number;

    [key: string]: any;
}

/** Technical information on memory of a baremetal service */
export class Memory implements IMemory {
    /** Is ECC feature is enabled on memory */
    readonly ecc?: boolean;
    /** Memory frequency */
    readonly frequency?: number;
    /** Type of memory */
    readonly ramType?: string;
    /** Memory size */
    readonly size?: number;

    [key: string]: any;

    constructor(data?: IMemory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).ecc = _data["ecc"];
            (<any>this).frequency = _data["frequency"];
            (<any>this).ramType = _data["ramType"];
            (<any>this).size = _data["size"];
        }
    }

    static fromJS(data: any): Memory {
        data = typeof data === 'object' ? data : {};
        let result = new Memory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ecc"] = this.ecc;
        data["frequency"] = this.frequency;
        data["ramType"] = this.ramType;
        data["size"] = this.size;
        return data;
    }
}

/** Technical information on memory of a baremetal service */
export interface IMemory {
    /** Is ECC feature is enabled on memory */
    ecc?: boolean;
    /** Memory frequency */
    frequency?: number;
    /** Type of memory */
    ramType?: string;
    /** Memory size */
    size?: number;

    [key: string]: any;
}

/** Technical information of a baremetal server service */
export class Server implements IServer {
    /** Server Cpu */
    readonly cpu?: Cpu;
    /** Technical details for a server extension card */
    readonly extensionCard?: ExtensionCard | undefined;
    /** Server frame */
    readonly frame?: Frame;
    /** Technical details for a server network */
    readonly network?: Network | undefined;
    /** Server's range */
    readonly range?: string;
    /** Technical details for a server service */
    readonly services?: Services | undefined;
    readonly useCase?: string | undefined;

    [key: string]: any;

    constructor(data?: IServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).cpu = _data["cpu"] ? Cpu.fromJS(_data["cpu"]) : <any>undefined;
            (<any>this).extensionCard = _data["extensionCard"] ? ExtensionCard.fromJS(_data["extensionCard"]) : <any>undefined;
            (<any>this).frame = _data["frame"] ? Frame.fromJS(_data["frame"]) : <any>undefined;
            (<any>this).network = _data["network"] ? Network.fromJS(_data["network"]) : <any>undefined;
            (<any>this).range = _data["range"];
            (<any>this).services = _data["services"] ? Services.fromJS(_data["services"]) : <any>undefined;
            (<any>this).useCase = _data["useCase"];
        }
    }

    static fromJS(data: any): Server {
        data = typeof data === 'object' ? data : {};
        let result = new Server();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["cpu"] = this.cpu ? this.cpu.toJSON() : <any>undefined;
        data["extensionCard"] = this.extensionCard ? this.extensionCard.toJSON() : <any>undefined;
        data["frame"] = this.frame ? this.frame.toJSON() : <any>undefined;
        data["network"] = this.network ? this.network.toJSON() : <any>undefined;
        data["range"] = this.range;
        data["services"] = this.services ? this.services.toJSON() : <any>undefined;
        data["useCase"] = this.useCase;
        return data;
    }
}

/** Technical information of a baremetal server service */
export interface IServer {
    /** Server Cpu */
    cpu?: Cpu;
    /** Technical details for a server extension card */
    extensionCard?: ExtensionCard | undefined;
    /** Server frame */
    frame?: Frame;
    /** Technical details for a server network */
    network?: Network | undefined;
    /** Server's range */
    range?: string;
    /** Technical details for a server service */
    services?: Services | undefined;
    useCase?: string | undefined;

    [key: string]: any;
}

/** Technical information of storage of a baremetal service */
export class Storage implements IStorage {
    /** List of storage disks */
    readonly disks?: Disk[];
    /** If disk is hot swapable */
    readonly hotSwap?: boolean;
    /** Storage raid type */
    readonly raid?: string;
    /** Server raid storage details */
    readonly raidDetails?: Raid | undefined;

    [key: string]: any;

    constructor(data?: IStorage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["disks"])) {
                (<any>this).disks = [] as any;
                for (let item of _data["disks"])
                    (<any>this).disks!.push(Disk.fromJS(item));
            }
            (<any>this).hotSwap = _data["hotSwap"];
            (<any>this).raid = _data["raid"];
            (<any>this).raidDetails = _data["raidDetails"] ? Raid.fromJS(_data["raidDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Storage {
        data = typeof data === 'object' ? data : {};
        let result = new Storage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.disks)) {
            data["disks"] = [];
            for (let item of this.disks)
                data["disks"].push(item.toJSON());
        }
        data["hotSwap"] = this.hotSwap;
        data["raid"] = this.raid;
        data["raidDetails"] = this.raidDetails ? this.raidDetails.toJSON() : <any>undefined;
        return data;
    }
}

/** Technical information of storage of a baremetal service */
export interface IStorage {
    /** List of storage disks */
    disks?: Disk[];
    /** If disk is hot swapable */
    hotSwap?: boolean;
    /** Storage raid type */
    raid?: string;
    /** Server raid storage details */
    raidDetails?: Raid | undefined;

    [key: string]: any;
}

/** Technical information of vrack of a baremetal service */
export class Vrack implements IVrack {
    /** Aggregation information */
    readonly aggregation?: Aggregation | undefined;
    /** Bandwidth burst */
    readonly burst?: number;
    /** Guaranteed bandwith on the Vrack */
    readonly guaranteed?: boolean;
    /** Level width of Band */
    readonly level?: number;
    /** Bandwidth limit */
    readonly limit?: number;

    [key: string]: any;

    constructor(data?: IVrack) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).aggregation = _data["aggregation"] ? Aggregation.fromJS(_data["aggregation"]) : <any>undefined;
            (<any>this).burst = _data["burst"];
            (<any>this).guaranteed = _data["guaranteed"];
            (<any>this).level = _data["level"];
            (<any>this).limit = _data["limit"];
        }
    }

    static fromJS(data: any): Vrack {
        data = typeof data === 'object' ? data : {};
        let result = new Vrack();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["aggregation"] = this.aggregation ? this.aggregation.toJSON() : <any>undefined;
        data["burst"] = this.burst;
        data["guaranteed"] = this.guaranteed;
        data["level"] = this.level;
        data["limit"] = this.limit;
        return data;
    }
}

/** Technical information of vrack of a baremetal service */
export interface IVrack {
    /** Aggregation information */
    aggregation?: Aggregation | undefined;
    /** Bandwidth burst */
    burst?: number;
    /** Guaranteed bandwith on the Vrack */
    guaranteed?: boolean;
    /** Level width of Band */
    level?: number;
    /** Bandwidth limit */
    limit?: number;

    [key: string]: any;
}

/** Technical information on cpu of a baremetal server service */
export class Cpu implements ICpu {
    /** Server Cpu boost */
    readonly boost?: number;
    /** Server Cpu brand name */
    readonly brand?: string;
    /** Cpu number of cores */
    readonly cores?: number;
    /** Server */
    readonly frequency?: number;
    /** Server Cpu model name */
    readonly model?: string;
    /** CPU number */
    readonly number?: number;
    /** Score of cpu */
    readonly score?: number;
    /** Server Cpu number of threads */
    readonly threads?: number;

    [key: string]: any;

    constructor(data?: ICpu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).boost = _data["boost"];
            (<any>this).brand = _data["brand"];
            (<any>this).cores = _data["cores"];
            (<any>this).frequency = _data["frequency"];
            (<any>this).model = _data["model"];
            (<any>this).number = _data["number"];
            (<any>this).score = _data["score"];
            (<any>this).threads = _data["threads"];
        }
    }

    static fromJS(data: any): Cpu {
        data = typeof data === 'object' ? data : {};
        let result = new Cpu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["boost"] = this.boost;
        data["brand"] = this.brand;
        data["cores"] = this.cores;
        data["frequency"] = this.frequency;
        data["model"] = this.model;
        data["number"] = this.number;
        data["score"] = this.score;
        data["threads"] = this.threads;
        return data;
    }
}

/** Technical information on cpu of a baremetal server service */
export interface ICpu {
    /** Server Cpu boost */
    boost?: number;
    /** Server Cpu brand name */
    brand?: string;
    /** Cpu number of cores */
    cores?: number;
    /** Server */
    frequency?: number;
    /** Server Cpu model name */
    model?: string;
    /** CPU number */
    number?: number;
    /** Score of cpu */
    score?: number;
    /** Server Cpu number of threads */
    threads?: number;

    [key: string]: any;
}

/** Technical details for a server extension card */
export class ExtensionCard implements IExtensionCard {
    /** Model of the extension card */
    readonly model?: string;
    /** Number of available ports */
    readonly size?: string;

    [key: string]: any;

    constructor(data?: IExtensionCard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).model = _data["model"];
            (<any>this).size = _data["size"];
        }
    }

    static fromJS(data: any): ExtensionCard {
        data = typeof data === 'object' ? data : {};
        let result = new ExtensionCard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["model"] = this.model;
        data["size"] = this.size;
        return data;
    }
}

/** Technical details for a server extension card */
export interface IExtensionCard {
    /** Model of the extension card */
    model?: string;
    /** Number of available ports */
    size?: string;

    [key: string]: any;
}

/** Technical information on frame of a baremetal server service */
export class Frame implements IFrame {
    /** Server with dual power supply */
    readonly dualPowerSupply?: boolean;
    /** Maximum number of disks */
    readonly maxNbDisks?: number | undefined;
    /** Server frame Model */
    readonly model?: string;
    /** Server frame size */
    readonly size?: string;

    [key: string]: any;

    constructor(data?: IFrame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).dualPowerSupply = _data["dualPowerSupply"];
            (<any>this).maxNbDisks = _data["maxNbDisks"];
            (<any>this).model = _data["model"];
            (<any>this).size = _data["size"];
        }
    }

    static fromJS(data: any): Frame {
        data = typeof data === 'object' ? data : {};
        let result = new Frame();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dualPowerSupply"] = this.dualPowerSupply;
        data["maxNbDisks"] = this.maxNbDisks;
        data["model"] = this.model;
        data["size"] = this.size;
        return data;
    }
}

/** Technical information on frame of a baremetal server service */
export interface IFrame {
    /** Server with dual power supply */
    dualPowerSupply?: boolean;
    /** Maximum number of disks */
    maxNbDisks?: number | undefined;
    /** Server frame Model */
    model?: string;
    /** Server frame size */
    size?: string;

    [key: string]: any;
}

/** Technical details for a server network */
export class Network implements INetwork {
    /** Network card capacity (in Gbps) */
    readonly capacity?: number;
    /** Number of network links */
    readonly interfaces?: number;

    [key: string]: any;

    constructor(data?: INetwork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).capacity = _data["capacity"];
            (<any>this).interfaces = _data["interfaces"];
        }
    }

    static fromJS(data: any): Network {
        data = typeof data === 'object' ? data : {};
        let result = new Network();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["capacity"] = this.capacity;
        data["interfaces"] = this.interfaces;
        return data;
    }
}

/** Technical details for a server network */
export interface INetwork {
    /** Network card capacity (in Gbps) */
    capacity?: number;
    /** Number of network links */
    interfaces?: number;

    [key: string]: any;
}

/** Technical details for a server services */
export class Services implements IServices {
    /** AntiDDOS provided by the service */
    readonly antiddos?: string;
    /** FTP Backup size in GB */
    readonly includedBackup?: number;
    /** Is IPMI available */
    readonly ipmiAvailable?: boolean;
    /** ipv4 range included */
    readonly ipv4RangeIncluded?: string | undefined;
    /** ipv6 range included */
    readonly ipv6RangeIncluded?: string | undefined;
    /** Is KVMIP available */
    readonly kvmipAvailable?: boolean;
    /** Define if the product is eligible to the OVHcloud Link aggregation feature */
    readonly olaAvailable?: boolean;
    /** Which secure computing technology is used */
    readonly secureComputingTechnology?: SecureComputingTechnologyEnum | undefined;
    /** SLA of the service (in percent) */
    readonly sla?: number;
    /** Which support level of service is included */
    readonly supportLevel?: SupportLevelEnum | undefined;

    [key: string]: any;

    constructor(data?: IServices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).antiddos = _data["antiddos"];
            (<any>this).includedBackup = _data["includedBackup"];
            (<any>this).ipmiAvailable = _data["ipmiAvailable"];
            (<any>this).ipv4RangeIncluded = _data["ipv4RangeIncluded"];
            (<any>this).ipv6RangeIncluded = _data["ipv6RangeIncluded"];
            (<any>this).kvmipAvailable = _data["kvmipAvailable"];
            (<any>this).olaAvailable = _data["olaAvailable"];
            (<any>this).secureComputingTechnology = _data["secureComputingTechnology"];
            (<any>this).sla = _data["sla"];
            (<any>this).supportLevel = _data["supportLevel"];
        }
    }

    static fromJS(data: any): Services {
        data = typeof data === 'object' ? data : {};
        let result = new Services();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["antiddos"] = this.antiddos;
        data["includedBackup"] = this.includedBackup;
        data["ipmiAvailable"] = this.ipmiAvailable;
        data["ipv4RangeIncluded"] = this.ipv4RangeIncluded;
        data["ipv6RangeIncluded"] = this.ipv6RangeIncluded;
        data["kvmipAvailable"] = this.kvmipAvailable;
        data["olaAvailable"] = this.olaAvailable;
        data["secureComputingTechnology"] = this.secureComputingTechnology;
        data["sla"] = this.sla;
        data["supportLevel"] = this.supportLevel;
        return data;
    }
}

/** Technical details for a server services */
export interface IServices {
    /** AntiDDOS provided by the service */
    antiddos?: string;
    /** FTP Backup size in GB */
    includedBackup?: number;
    /** Is IPMI available */
    ipmiAvailable?: boolean;
    /** ipv4 range included */
    ipv4RangeIncluded?: string | undefined;
    /** ipv6 range included */
    ipv6RangeIncluded?: string | undefined;
    /** Is KVMIP available */
    kvmipAvailable?: boolean;
    /** Define if the product is eligible to the OVHcloud Link aggregation feature */
    olaAvailable?: boolean;
    /** Which secure computing technology is used */
    secureComputingTechnology?: SecureComputingTechnologyEnum | undefined;
    /** SLA of the service (in percent) */
    sla?: number;
    /** Which support level of service is included */
    supportLevel?: SupportLevelEnum | undefined;

    [key: string]: any;
}

/** Type of secure computing technology */
export enum SecureComputingTechnologyEnum {
    AMDInfinity = "AMDInfinity",
    IntelSGX = "IntelSGX",
}

/** Type of support level */
export enum SupportLevelEnum {
    Business = "business",
    Enterprise = "enterprise",
    Premium = "premium",
    PremiumAccredited = "premium-accredited",
    Standard = "standard",
}

/** Technical information of storage disk of a baremetal service */
export class Disk implements IDisk {
    /** Maximum disk capacity */
    readonly capacity?: number;
    /** Drive Writes Per Day */
    readonly dwpd?: number | undefined;
    /** Interface identifier */
    readonly interface?: string;
    /** Latency (in us) */
    readonly latency?: number | undefined;
    /** Number of interfaces */
    readonly number?: number;
    /** Average number of random read I/O operations per second */
    readonly read?: number | undefined;
    /** Form factor of the hardware */
    readonly specs?: string;
    /** Type of disk */
    readonly technology?: string;
    /** Disk's usage */
    readonly usage?: UsageEnum | undefined;
    /** Average number of random write I/O operations per second */
    readonly write?: number | undefined;

    [key: string]: any;

    constructor(data?: IDisk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).capacity = _data["capacity"];
            (<any>this).dwpd = _data["dwpd"];
            (<any>this).interface = _data["interface"];
            (<any>this).latency = _data["latency"];
            (<any>this).number = _data["number"];
            (<any>this).read = _data["read"];
            (<any>this).specs = _data["specs"];
            (<any>this).technology = _data["technology"];
            (<any>this).usage = _data["usage"];
            (<any>this).write = _data["write"];
        }
    }

    static fromJS(data: any): Disk {
        data = typeof data === 'object' ? data : {};
        let result = new Disk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["capacity"] = this.capacity;
        data["dwpd"] = this.dwpd;
        data["interface"] = this.interface;
        data["latency"] = this.latency;
        data["number"] = this.number;
        data["read"] = this.read;
        data["specs"] = this.specs;
        data["technology"] = this.technology;
        data["usage"] = this.usage;
        data["write"] = this.write;
        return data;
    }
}

/** Technical information of storage disk of a baremetal service */
export interface IDisk {
    /** Maximum disk capacity */
    capacity?: number;
    /** Drive Writes Per Day */
    dwpd?: number | undefined;
    /** Interface identifier */
    interface?: string;
    /** Latency (in us) */
    latency?: number | undefined;
    /** Number of interfaces */
    number?: number;
    /** Average number of random read I/O operations per second */
    read?: number | undefined;
    /** Form factor of the hardware */
    specs?: string;
    /** Type of disk */
    technology?: string;
    /** Disk's usage */
    usage?: UsageEnum | undefined;
    /** Average number of random write I/O operations per second */
    write?: number | undefined;

    [key: string]: any;
}

/** Type of disk's usage */
export enum UsageEnum {
    Cache = "cache",
    Data = "data",
    Os = "os",
}

/** Server raid storage type */
export class Raid implements IRaid {
    /** Name of the hardraid card model */
    readonly cardModel?: string | undefined;
    /** Number of slots */
    readonly cardSize?: string | undefined;
    readonly type?: TypeEnum3;

    [key: string]: any;

    constructor(data?: IRaid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).cardModel = _data["cardModel"];
            (<any>this).cardSize = _data["cardSize"];
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): Raid {
        data = typeof data === 'object' ? data : {};
        let result = new Raid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["cardModel"] = this.cardModel;
        data["cardSize"] = this.cardSize;
        data["type"] = this.type;
        return data;
    }
}

/** Server raid storage type */
export interface IRaid {
    /** Name of the hardraid card model */
    cardModel?: string | undefined;
    /** Number of slots */
    cardSize?: string | undefined;
    type?: TypeEnum3;

    [key: string]: any;
}

/** RAID type */
export enum TypeEnum3 {
    Hard_RAID = "Hard RAID",
    Soft_RAID = "Soft RAID",
    None = "none",
}

/** Technical information on nutanix cluster service */
export class Cluster implements ICluster {
    /** Nutanix cluster range */
    readonly range?: string;
    /** Nutanix cluster server */
    readonly server?: string;

    [key: string]: any;

    constructor(data?: ICluster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).range = _data["range"];
            (<any>this).server = _data["server"];
        }
    }

    static fromJS(data: any): Cluster {
        data = typeof data === 'object' ? data : {};
        let result = new Cluster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["range"] = this.range;
        data["server"] = this.server;
        return data;
    }
}

/** Technical information on nutanix cluster service */
export interface ICluster {
    /** Nutanix cluster range */
    range?: string;
    /** Nutanix cluster server */
    server?: string;

    [key: string]: any;
}

/** Nutanix feature */
export class Features implements IFeatures {
    /** Feature name */
    readonly name?: string;
    /** Feature value */
    readonly value?: string;

    [key: string]: any;

    constructor(data?: IFeatures) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).name = _data["name"];
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): Features {
        data = typeof data === 'object' ? data : {};
        let result = new Features();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

/** Nutanix feature */
export interface IFeatures {
    /** Feature name */
    name?: string;
    /** Feature value */
    value?: string;

    [key: string]: any;
}

/** Nutanix cluster license */
export class License implements ILicense {
    /** Feature name */
    readonly distribution?: string;
    /** Feature value */
    readonly edition?: string;
    /** List of license features */
    readonly features?: Features[] | undefined;

    [key: string]: any;

    constructor(data?: ILicense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).distribution = _data["distribution"];
            (<any>this).edition = _data["edition"];
            if (Array.isArray(_data["features"])) {
                (<any>this).features = [] as any;
                for (let item of _data["features"])
                    (<any>this).features!.push(Features.fromJS(item));
            }
        }
    }

    static fromJS(data: any): License {
        data = typeof data === 'object' ? data : {};
        let result = new License();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["distribution"] = this.distribution;
        data["edition"] = this.edition;
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

/** Nutanix cluster license */
export interface ILicense {
    /** Feature name */
    distribution?: string;
    /** Feature value */
    edition?: string;
    /** List of license features */
    features?: Features[] | undefined;

    [key: string]: any;
}

/** Nutanix cluser services */
export class Service3 implements IService3 {
    /** Nutanix SLA service */
    readonly sla?: number;

    [key: string]: any;

    constructor(data?: IService3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).sla = _data["sla"];
        }
    }

    static fromJS(data: any): Service3 {
        data = typeof data === 'object' ? data : {};
        let result = new Service3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sla"] = this.sla;
        return data;
    }
}

/** Nutanix cluser services */
export interface IService3 {
    /** Nutanix SLA service */
    sla?: number;

    [key: string]: any;
}

/** Termination policies */
export enum TerminationPolicyEnum {
    Empty = "empty",
    TerminateAtEngagementDate = "terminateAtEngagementDate",
    TerminateAtExpirationDate = "terminateAtExpirationDate",
}

/** Answer to a form */
export class Answer implements IAnswer {
    /** Question of the answer */
    question?: string;
    /** Answer value to the question */
    value?: string;

    [key: string]: any;

    constructor(data?: IAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.question = _data["question"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Answer {
        data = typeof data === 'object' ? data : {};
        let result = new Answer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["question"] = this.question;
        data["value"] = this.value;
        return data;
    }
}

/** Answer to a form */
export interface IAnswer {
    /** Question of the answer */
    question?: string;
    /** Answer value to the question */
    value?: string;

    [key: string]: any;
}

/** Possible value for an answer to the question */
export class AnswerAllowedValue implements IAnswerAllowedValue {
    /** Possible answer to the question */
    readonly key?: string;

    [key: string]: any;

    constructor(data?: IAnswerAllowedValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).key = _data["key"];
        }
    }

    static fromJS(data: any): AnswerAllowedValue {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerAllowedValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        return data;
    }
}

/** Possible value for an answer to the question */
export interface IAnswerAllowedValue {
    /** Possible answer to the question */
    key?: string;

    [key: string]: any;
}

/** Type of the answer */
export enum AnswerTypeEnum {
    Boolean = "boolean",
    Date = "date",
    Datetime = "datetime",
    Double = "double",
    Enum = "enum",
    Long = "long",
    String = "string",
    Text = "text",
}

/** Description of a form */
export class Description implements IDescription {
    /** Name of the form */
    readonly name?: string;
    /** List of available questions for the form */
    readonly questions?: Question[];

    [key: string]: any;

    constructor(data?: IDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["questions"])) {
                (<any>this).questions = [] as any;
                for (let item of _data["questions"])
                    (<any>this).questions!.push(Question.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Description {
        data = typeof data === 'object' ? data : {};
        let result = new Description();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

/** Description of a form */
export interface IDescription {
    /** Name of the form */
    name?: string;
    /** List of available questions for the form */
    questions?: Question[];

    [key: string]: any;
}

/** Input body for posting a form */
export class Form implements IForm {
    /** Answers to the form */
    answers!: Answer[];

    [key: string]: any;

    constructor(data?: IForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.answers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(Answer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Form {
        data = typeof data === 'object' ? data : {};
        let result = new Form();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        return data;
    }
}

/** Input body for posting a form */
export interface IForm {
    /** Answers to the form */
    answers: Answer[];

    [key: string]: any;
}

/** Question description for a churn form */
export class Question implements IQuestion {
    /** List of available values for answer */
    readonly answers?: AnswerAllowedValue[] | undefined;
    /** Is the Question mandatory for the form ? */
    readonly mandatory?: boolean;
    /** Question name */
    readonly question?: string;
    /** Type of the expected answer : text, enum, number... */
    readonly type?: AnswerTypeEnum;

    [key: string]: any;

    constructor(data?: IQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["answers"])) {
                (<any>this).answers = [] as any;
                for (let item of _data["answers"])
                    (<any>this).answers!.push(AnswerAllowedValue.fromJS(item));
            }
            (<any>this).mandatory = _data["mandatory"];
            (<any>this).question = _data["question"];
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): Question {
        data = typeof data === 'object' ? data : {};
        let result = new Question();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["mandatory"] = this.mandatory;
        data["question"] = this.question;
        data["type"] = this.type;
        return data;
    }
}

/** Question description for a churn form */
export interface IQuestion {
    /** List of available values for answer */
    answers?: AnswerAllowedValue[] | undefined;
    /** Is the Question mandatory for the form ? */
    mandatory?: boolean;
    /** Question name */
    question?: string;
    /** Type of the expected answer : text, enum, number... */
    type?: AnswerTypeEnum;

    [key: string]: any;
}

/** Response ack for posting a form */
export class Response implements IResponse {
    /** Message after posting a form */
    readonly message?: string;

    [key: string]: any;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).message = _data["message"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["message"] = this.message;
        return data;
    }
}

/** Response ack for posting a form */
export interface IResponse {
    /** Message after posting a form */
    message?: string;

    [key: string]: any;
}

/** Contains all information for the given addon in order to be detached */
export class AddonDetachExecutionRequest implements IAddonDetachExecutionRequest {
    /** Duration selected for the operation execution */
    duration!: string;
    /** Commercial offer to detach the service to */
    planCode!: string;
    /** Pricing mode selected for the operation execution */
    pricingMode!: string;
    /** Quantity for the operation execution */
    quantity!: number;
    /** ID of the service that will be detached */
    serviceId!: number;

    [key: string]: any;

    constructor(data?: IAddonDetachExecutionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.duration = _data["duration"];
            this.planCode = _data["planCode"];
            this.pricingMode = _data["pricingMode"];
            this.quantity = _data["quantity"];
            this.serviceId = _data["serviceId"];
        }
    }

    static fromJS(data: any): AddonDetachExecutionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddonDetachExecutionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["duration"] = this.duration;
        data["planCode"] = this.planCode;
        data["pricingMode"] = this.pricingMode;
        data["quantity"] = this.quantity;
        data["serviceId"] = this.serviceId;
        return data;
    }
}

/** Contains all information for the given addon in order to be detached */
export interface IAddonDetachExecutionRequest {
    /** Duration selected for the operation execution */
    duration: string;
    /** Commercial offer to detach the service to */
    planCode: string;
    /** Pricing mode selected for the operation execution */
    pricingMode: string;
    /** Quantity for the operation execution */
    quantity: number;
    /** ID of the service that will be detached */
    serviceId: number;

    [key: string]: any;
}

/** Request allowing the detachment of a service from its parent */
export class DetachExecutionRequest implements IDetachExecutionRequest {
    /** Addons information for the operation execution */
    addons?: AddonDetachExecutionRequest[] | undefined;
    /** Indicates that order, if needed, will be automatically paid with preferred payment method */
    autoPayWithPreferredPaymentMethod?: boolean;
    /** Duration selected for the operation execution */
    duration!: string;
    /** Pricing mode selected for the operation execution */
    pricingMode!: string;
    /** Quantity for the operation execution */
    quantity!: number;

    [key: string]: any;

    constructor(data?: IDetachExecutionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["addons"])) {
                this.addons = [] as any;
                for (let item of _data["addons"])
                    this.addons!.push(AddonDetachExecutionRequest.fromJS(item));
            }
            this.autoPayWithPreferredPaymentMethod = _data["autoPayWithPreferredPaymentMethod"];
            this.duration = _data["duration"];
            this.pricingMode = _data["pricingMode"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): DetachExecutionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DetachExecutionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.addons)) {
            data["addons"] = [];
            for (let item of this.addons)
                data["addons"].push(item.toJSON());
        }
        data["autoPayWithPreferredPaymentMethod"] = this.autoPayWithPreferredPaymentMethod;
        data["duration"] = this.duration;
        data["pricingMode"] = this.pricingMode;
        data["quantity"] = this.quantity;
        return data;
    }
}

/** Request allowing the detachment of a service from its parent */
export interface IDetachExecutionRequest {
    /** Addons information for the operation execution */
    addons?: AddonDetachExecutionRequest[] | undefined;
    /** Indicates that order, if needed, will be automatically paid with preferred payment method */
    autoPayWithPreferredPaymentMethod?: boolean;
    /** Duration selected for the operation execution */
    duration: string;
    /** Pricing mode selected for the operation execution */
    pricingMode: string;
    /** Quantity for the operation execution */
    quantity: number;

    [key: string]: any;
}

/** All possible detachment offers for the given service options */
export class DetachOptionsDefinition implements IDetachOptionsDefinition {
    /** Possible options for the given service */
    readonly plans?: GenericProductDefinition[];
    /** ID of the service */
    readonly serviceId?: number;

    [key: string]: any;

    constructor(data?: IDetachOptionsDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["plans"])) {
                (<any>this).plans = [] as any;
                for (let item of _data["plans"])
                    (<any>this).plans!.push(GenericProductDefinition.fromJS(item));
            }
            (<any>this).serviceId = _data["serviceId"];
        }
    }

    static fromJS(data: any): DetachOptionsDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new DetachOptionsDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.plans)) {
            data["plans"] = [];
            for (let item of this.plans)
                data["plans"].push(item.toJSON());
        }
        data["serviceId"] = this.serviceId;
        return data;
    }
}

/** All possible detachment offers for the given service options */
export interface IDetachOptionsDefinition {
    /** Possible options for the given service */
    plans?: GenericProductDefinition[];
    /** ID of the service */
    serviceId?: number;

    [key: string]: any;
}

/** Missing description */
export class ExecutionRequest implements IExecutionRequest {
    /** Indicates that order, if needed, will be automatically paid with preferred payment method */
    autoPayWithPreferredPaymentMethod?: boolean;
    /** Duration selected for the operation execution */
    duration!: string;
    /** Pricing mode selected for the operation execution */
    pricingMode!: string;
    /** Quantity for the operation execution */
    quantity!: number;

    [key: string]: any;

    constructor(data?: IExecutionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.autoPayWithPreferredPaymentMethod = _data["autoPayWithPreferredPaymentMethod"];
            this.duration = _data["duration"];
            this.pricingMode = _data["pricingMode"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): ExecutionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExecutionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["autoPayWithPreferredPaymentMethod"] = this.autoPayWithPreferredPaymentMethod;
        data["duration"] = this.duration;
        data["pricingMode"] = this.pricingMode;
        data["quantity"] = this.quantity;
        return data;
    }
}

/** Missing description */
export interface IExecutionRequest {
    /** Indicates that order, if needed, will be automatically paid with preferred payment method */
    autoPayWithPreferredPaymentMethod?: boolean;
    /** Duration selected for the operation execution */
    duration: string;
    /** Pricing mode selected for the operation execution */
    pricingMode: string;
    /** Quantity for the operation execution */
    quantity: number;

    [key: string]: any;
}

/** Order created by an Operation to modify a Service */
export class Order2 implements IOrder2 {
    /** Order created, if any */
    readonly order?: Order | undefined;

    [key: string]: any;

    constructor(data?: IOrder2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Order2 {
        data = typeof data === 'object' ? data : {};
        let result = new Order2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        return data;
    }
}

/** Order created by an Operation to modify a Service */
export interface IOrder2 {
    /** Order created, if any */
    order?: Order | undefined;

    [key: string]: any;
}

/** Change periodEndAction request for a Savings Plan period */
export class ChangePeriodEndAction implements IChangePeriodEndAction {
    /** Action performed at the end of the period */
    periodEndAction!: PeriodEndActionEnum;

    [key: string]: any;

    constructor(data?: IChangePeriodEndAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.periodEndAction = _data["periodEndAction"];
        }
    }

    static fromJS(data: any): ChangePeriodEndAction {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePeriodEndAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["periodEndAction"] = this.periodEndAction;
        return data;
    }
}

/** Change periodEndAction request for a Savings Plan period */
export interface IChangePeriodEndAction {
    /** Action performed at the end of the period */
    periodEndAction: PeriodEndActionEnum;

    [key: string]: any;
}

/** Resize request for a Savings Plan */
export class ChangeSize implements IChangeSize {
    /** Size of the Savings Plan */
    size!: number;

    [key: string]: any;

    constructor(data?: IChangeSize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): ChangeSize {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeSize();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["size"] = this.size;
        return data;
    }
}

/** Resize request for a Savings Plan */
export interface IChangeSize {
    /** Size of the Savings Plan */
    size: number;

    [key: string]: any;
}

/** Action performed when a Savings Plan reaches the end of the period */
export enum PeriodEndActionEnum {
    REACTIVATE = "REACTIVATE",
    TERMINATE = "TERMINATE",
}

/** Change planned on a Savings Plan */
export class PlannedChange implements IPlannedChange {
    /** Date when the change will occur */
    readonly plannedOn?: Date;
    /** Properties of the Savings Plan changing on planned date */
    readonly properties?: PlannedChangeProperties;

    [key: string]: any;

    constructor(data?: IPlannedChange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).plannedOn = _data["plannedOn"] ? parseDateOnly(_data["plannedOn"].toString()) : <any>undefined;
            (<any>this).properties = _data["properties"] ? PlannedChangeProperties.fromJS(_data["properties"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PlannedChange {
        data = typeof data === 'object' ? data : {};
        let result = new PlannedChange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["plannedOn"] = this.plannedOn ? formatDate(this.plannedOn) : <any>undefined;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        return data;
    }
}

/** Change planned on a Savings Plan */
export interface IPlannedChange {
    /** Date when the change will occur */
    plannedOn?: Date;
    /** Properties of the Savings Plan changing on planned date */
    properties?: PlannedChangeProperties;

    [key: string]: any;
}

/** Properties changing during a planned change */
export class PlannedChangeProperties implements IPlannedChangeProperties {
    /** Status of the Savings Plan */
    readonly status?: StatusEnum;

    [key: string]: any;

    constructor(data?: IPlannedChangeProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).status = _data["status"];
        }
    }

    static fromJS(data: any): PlannedChangeProperties {
        data = typeof data === 'object' ? data : {};
        let result = new PlannedChangeProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        return data;
    }
}

/** Properties changing during a planned change */
export interface IPlannedChangeProperties {
    /** Status of the Savings Plan */
    status?: StatusEnum;

    [key: string]: any;
}

/** Savings Plan subscribed */
export class SavingsPlan implements ISavingsPlan {
    /** Custom display name, used in invoices */
    displayName!: string;
    /** End date of the Savings Plan */
    readonly endDate?: Date;
    /** Savings Plan flavor */
    readonly flavor?: string;
    /** Unique identifier of the Savings Plan */
    readonly id?: string;
    /** Savings Plan commercial offer identifier */
    readonly offerId?: string;
    /** Periodicity of the Savings Plan */
    readonly period?: string;
    /** Action performed when reaching the end of the period */
    readonly periodEndAction?: PeriodEndActionEnum;
    /** End date of the current period */
    readonly periodEndDate?: Date;
    /** Start date of the current period */
    readonly periodStartDate?: Date;
    /** Changes planned on the Savings Plan */
    readonly plannedChanges?: PlannedChange[];
    /** Size of the Savings Plan */
    readonly size?: number;
    /** Start date of the Savings Plan */
    readonly startDate?: Date;
    /** Status of the Savings Plan */
    readonly status?: StatusEnum;
    /** Date at which the Savings Plan is scheduled to be terminated. A null value means the Savings Plan is not scheduled for termination */
    readonly terminationDate?: Date | undefined;

    [key: string]: any;

    constructor(data?: ISavingsPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.displayName = _data["displayName"];
            (<any>this).endDate = _data["endDate"] ? parseDateOnly(_data["endDate"].toString()) : <any>undefined;
            (<any>this).flavor = _data["flavor"];
            (<any>this).id = _data["id"];
            (<any>this).offerId = _data["offerId"];
            (<any>this).period = _data["period"];
            (<any>this).periodEndAction = _data["periodEndAction"];
            (<any>this).periodEndDate = _data["periodEndDate"] ? parseDateOnly(_data["periodEndDate"].toString()) : <any>undefined;
            (<any>this).periodStartDate = _data["periodStartDate"] ? parseDateOnly(_data["periodStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["plannedChanges"])) {
                (<any>this).plannedChanges = [] as any;
                for (let item of _data["plannedChanges"])
                    (<any>this).plannedChanges!.push(PlannedChange.fromJS(item));
            }
            (<any>this).size = _data["size"];
            (<any>this).startDate = _data["startDate"] ? parseDateOnly(_data["startDate"].toString()) : <any>undefined;
            (<any>this).status = _data["status"];
            (<any>this).terminationDate = _data["terminationDate"] ? parseDateOnly(_data["terminationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SavingsPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SavingsPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["flavor"] = this.flavor;
        data["id"] = this.id;
        data["offerId"] = this.offerId;
        data["period"] = this.period;
        data["periodEndAction"] = this.periodEndAction;
        data["periodEndDate"] = this.periodEndDate ? formatDate(this.periodEndDate) : <any>undefined;
        data["periodStartDate"] = this.periodStartDate ? formatDate(this.periodStartDate) : <any>undefined;
        if (Array.isArray(this.plannedChanges)) {
            data["plannedChanges"] = [];
            for (let item of this.plannedChanges)
                data["plannedChanges"].push(item.toJSON());
        }
        data["size"] = this.size;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["status"] = this.status;
        data["terminationDate"] = this.terminationDate ? formatDate(this.terminationDate) : <any>undefined;
        return data;
    }
}

/** Savings Plan subscribed */
export interface ISavingsPlan {
    /** Custom display name, used in invoices */
    displayName: string;
    /** End date of the Savings Plan */
    endDate?: Date;
    /** Savings Plan flavor */
    flavor?: string;
    /** Unique identifier of the Savings Plan */
    id?: string;
    /** Savings Plan commercial offer identifier */
    offerId?: string;
    /** Periodicity of the Savings Plan */
    period?: string;
    /** Action performed when reaching the end of the period */
    periodEndAction?: PeriodEndActionEnum;
    /** End date of the current period */
    periodEndDate?: Date;
    /** Start date of the current period */
    periodStartDate?: Date;
    /** Changes planned on the Savings Plan */
    plannedChanges?: PlannedChange[];
    /** Size of the Savings Plan */
    size?: number;
    /** Start date of the Savings Plan */
    startDate?: Date;
    /** Status of the Savings Plan */
    status?: StatusEnum;
    /** Date at which the Savings Plan is scheduled to be terminated. A null value means the Savings Plan is not scheduled for termination */
    terminationDate?: Date | undefined;

    [key: string]: any;
}

/** Savings Plan Period history */
export class Period implements IPeriod {
    /** Unique identifier of the Period */
    readonly id?: string;
    /** Savings Plan commercial offer identifier */
    readonly offerId?: string;
    /** End date of the Period */
    readonly periodEndDate?: Date;
    /** Start date of the Period */
    readonly periodStartDate?: Date;
    /** Unique identifier of the Savings Plan */
    readonly savingsPlanId?: string;
    /** Size of the Savings Plan during the period */
    readonly size?: number;
    /** Status of the Period */
    readonly status?: StatusEnum;
    /** Savings Plan commercial offer unit price */
    readonly unitPrice?: number;

    [key: string]: any;

    constructor(data?: IPeriod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).id = _data["id"];
            (<any>this).offerId = _data["offerId"];
            (<any>this).periodEndDate = _data["periodEndDate"] ? parseDateOnly(_data["periodEndDate"].toString()) : <any>undefined;
            (<any>this).periodStartDate = _data["periodStartDate"] ? parseDateOnly(_data["periodStartDate"].toString()) : <any>undefined;
            (<any>this).savingsPlanId = _data["savingsPlanId"];
            (<any>this).size = _data["size"];
            (<any>this).status = _data["status"];
            (<any>this).unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): Period {
        data = typeof data === 'object' ? data : {};
        let result = new Period();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["offerId"] = this.offerId;
        data["periodEndDate"] = this.periodEndDate ? formatDate(this.periodEndDate) : <any>undefined;
        data["periodStartDate"] = this.periodStartDate ? formatDate(this.periodStartDate) : <any>undefined;
        data["savingsPlanId"] = this.savingsPlanId;
        data["size"] = this.size;
        data["status"] = this.status;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

/** Savings Plan Period history */
export interface IPeriod {
    /** Unique identifier of the Period */
    id?: string;
    /** Savings Plan commercial offer identifier */
    offerId?: string;
    /** End date of the Period */
    periodEndDate?: Date;
    /** Start date of the Period */
    periodStartDate?: Date;
    /** Unique identifier of the Savings Plan */
    savingsPlanId?: string;
    /** Size of the Savings Plan during the period */
    size?: number;
    /** Status of the Period */
    status?: StatusEnum;
    /** Savings Plan commercial offer unit price */
    unitPrice?: number;

    [key: string]: any;
}

/** Simulated Savings Plan subscribed */
export class SimulatedSavingsPlan implements ISimulatedSavingsPlan {
    /** Custom display name, used in invoices */
    readonly displayName?: string;
    /** End date of the Savings Plan */
    readonly endDate?: Date;
    /** Savings Plan flavor */
    readonly flavor?: string;
    /** Savings Plan commercial offer identifier */
    readonly offerId?: string;
    /** Periodicity of the Savings Plan */
    readonly period?: string;
    /** Action performed when reaching the end of the period */
    readonly periodEndAction?: PeriodEndActionEnum;
    /** End date of the current period */
    readonly periodEndDate?: Date;
    /** Start date of the current period */
    readonly periodStartDate?: Date;
    /** Size of the Savings Plan */
    readonly size?: number;
    /** Start date of the Savings Plan */
    readonly startDate?: Date;
    /** Status of the Savings Plan */
    readonly status?: StatusEnum;

    [key: string]: any;

    constructor(data?: ISimulatedSavingsPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).displayName = _data["displayName"];
            (<any>this).endDate = _data["endDate"] ? parseDateOnly(_data["endDate"].toString()) : <any>undefined;
            (<any>this).flavor = _data["flavor"];
            (<any>this).offerId = _data["offerId"];
            (<any>this).period = _data["period"];
            (<any>this).periodEndAction = _data["periodEndAction"];
            (<any>this).periodEndDate = _data["periodEndDate"] ? parseDateOnly(_data["periodEndDate"].toString()) : <any>undefined;
            (<any>this).periodStartDate = _data["periodStartDate"] ? parseDateOnly(_data["periodStartDate"].toString()) : <any>undefined;
            (<any>this).size = _data["size"];
            (<any>this).startDate = _data["startDate"] ? parseDateOnly(_data["startDate"].toString()) : <any>undefined;
            (<any>this).status = _data["status"];
        }
    }

    static fromJS(data: any): SimulatedSavingsPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SimulatedSavingsPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["endDate"] = this.endDate ? formatDate(this.endDate) : <any>undefined;
        data["flavor"] = this.flavor;
        data["offerId"] = this.offerId;
        data["period"] = this.period;
        data["periodEndAction"] = this.periodEndAction;
        data["periodEndDate"] = this.periodEndDate ? formatDate(this.periodEndDate) : <any>undefined;
        data["periodStartDate"] = this.periodStartDate ? formatDate(this.periodStartDate) : <any>undefined;
        data["size"] = this.size;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

/** Simulated Savings Plan subscribed */
export interface ISimulatedSavingsPlan {
    /** Custom display name, used in invoices */
    displayName?: string;
    /** End date of the Savings Plan */
    endDate?: Date;
    /** Savings Plan flavor */
    flavor?: string;
    /** Savings Plan commercial offer identifier */
    offerId?: string;
    /** Periodicity of the Savings Plan */
    period?: string;
    /** Action performed when reaching the end of the period */
    periodEndAction?: PeriodEndActionEnum;
    /** End date of the current period */
    periodEndDate?: Date;
    /** Start date of the current period */
    periodStartDate?: Date;
    /** Size of the Savings Plan */
    size?: number;
    /** Start date of the Savings Plan */
    startDate?: Date;
    /** Status of the Savings Plan */
    status?: StatusEnum;

    [key: string]: any;
}

/** Status of the Savings Plan */
export enum StatusEnum {
    ACTIVE = "ACTIVE",
    PENDING = "PENDING",
    TERMINATED = "TERMINATED",
}

/** Subscribable Savings Plan offer */
export class SubscribableSavingsPlanOffer implements ISubscribableSavingsPlanOffer {
    /** Identifier of the Savings Plan commercial offer */
    readonly offerId?: string;

    [key: string]: any;

    constructor(data?: ISubscribableSavingsPlanOffer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).offerId = _data["offerId"];
        }
    }

    static fromJS(data: any): SubscribableSavingsPlanOffer {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableSavingsPlanOffer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["offerId"] = this.offerId;
        return data;
    }
}

/** Subscribable Savings Plan offer */
export interface ISubscribableSavingsPlanOffer {
    /** Identifier of the Savings Plan commercial offer */
    offerId?: string;

    [key: string]: any;
}

/** Savings Plan subscription */
export class Subscribe implements ISubscribe {
    /** Custom display name, used in invoices */
    displayName!: string;
    /** Identifier of the Savings Plan commercial offer */
    offerId!: string;
    /** Size of the Savings Plan */
    size!: number;

    [key: string]: any;

    constructor(data?: ISubscribe) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.displayName = _data["displayName"];
            this.offerId = _data["offerId"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): Subscribe {
        data = typeof data === 'object' ? data : {};
        let result = new Subscribe();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["offerId"] = this.offerId;
        data["size"] = this.size;
        return data;
    }
}

/** Savings Plan subscription */
export interface ISubscribe {
    /** Custom display name, used in invoices */
    displayName: string;
    /** Identifier of the Savings Plan commercial offer */
    offerId: string;
    /** Size of the Savings Plan */
    size: number;

    [key: string]: any;
}

/** Confirm service termination request */
export class ConfirmServiceTerminationRequest implements IConfirmServiceTerminationRequest {
    /** The termination token sent by mail to the admin contact */
    token!: string;

    [key: string]: any;

    constructor(data?: IConfirmServiceTerminationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmServiceTerminationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmServiceTerminationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["token"] = this.token;
        return data;
    }
}

/** Confirm service termination request */
export interface IConfirmServiceTerminationRequest {
    /** The termination token sent by mail to the admin contact */
    token: string;

    [key: string]: any;
}

/** Termination instructions */
export class TerminationAnswer implements ITerminationAnswer {
    /** Termination instructions to be followed */
    readonly message?: string;

    [key: string]: any;

    constructor(data?: ITerminationAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).message = _data["message"];
        }
    }

    static fromJS(data: any): TerminationAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new TerminationAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["message"] = this.message;
        return data;
    }
}

/** Termination instructions */
export interface ITerminationAnswer {
    /** Termination instructions to be followed */
    message?: string;

    [key: string]: any;
}

/** Update of a service */
export class Service4 implements IService4 {
    /** Display name for the service */
    displayName?: string | undefined;
    /** Renew information */
    renew?: Renew2 | undefined;
    /** Termination policy */
    terminationPolicy?: TerminationPolicyEnum | undefined;

    [key: string]: any;

    constructor(data?: IService4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.displayName = _data["displayName"];
            this.renew = _data["renew"] ? Renew2.fromJS(_data["renew"]) : <any>undefined;
            this.terminationPolicy = _data["terminationPolicy"];
        }
    }

    static fromJS(data: any): Service4 {
        data = typeof data === 'object' ? data : {};
        let result = new Service4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["renew"] = this.renew ? this.renew.toJSON() : <any>undefined;
        data["terminationPolicy"] = this.terminationPolicy;
        return data;
    }
}

/** Update of a service */
export interface IService4 {
    /** Display name for the service */
    displayName?: string | undefined;
    /** Renew information */
    renew?: Renew2 | undefined;
    /** Termination policy */
    terminationPolicy?: TerminationPolicyEnum | undefined;

    [key: string]: any;
}

/** Update renew information of a service */
export class Renew2 implements IRenew2 {
    /** Renew mode for next renewal */
    mode?: ModeEnum;
    /** Renew period for next renewal */
    period?: string;

    [key: string]: any;

    constructor(data?: IRenew2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.mode = _data["mode"];
            this.period = _data["period"];
        }
    }

    static fromJS(data: any): Renew2 {
        data = typeof data === 'object' ? data : {};
        let result = new Renew2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mode"] = this.mode;
        data["period"] = this.period;
        return data;
    }
}

/** Update renew information of a service */
export interface IRenew2 {
    /** Renew mode for next renewal */
    mode?: ModeEnum;
    /** Renew period for next renewal */
    period?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous implements IAnonymous {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous2 implements IAnonymous2 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous2 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous3 implements IAnonymous3 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous3 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous3 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous4 implements IAnonymous4 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous4 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous4 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous5 implements IAnonymous5 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous5 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous5 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous6 implements IAnonymous6 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous6 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous6 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous7 implements IAnonymous7 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous7 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous7 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous8 implements IAnonymous8 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous8 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous8 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous9 implements IAnonymous9 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous9 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous9 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous10 implements IAnonymous10 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous10 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous10 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous11 implements IAnonymous11 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous11 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous11 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous12 implements IAnonymous12 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous12 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous12 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous13 implements IAnonymous13 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous13 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous13 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous14 implements IAnonymous14 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous14 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous14 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous15 implements IAnonymous15 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous15 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous15 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous16 implements IAnonymous16 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous16 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous16 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous17 implements IAnonymous17 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous17 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous17 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous18 implements IAnonymous18 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous18 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous18 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous19 implements IAnonymous19 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous19 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous19 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous20 implements IAnonymous20 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous20) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous20 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous20();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous20 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous21 implements IAnonymous21 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous21) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous21 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous21();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous21 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous22 implements IAnonymous22 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous22) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous22 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous22();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous22 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

/** Common error model */
export class Anonymous23 implements IAnonymous23 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;

    constructor(data?: IAnonymous23) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.class = _data["class"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Anonymous23 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous23();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["class"] = this.class;
        data["message"] = this.message;
        return data;
    }
}

/** Common error model */
export interface IAnonymous23 {
    /** Class of the error */
    class?: string;
    /** Error message */
    message?: string;

    [key: string]: any;
}

export function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

function parseDateOnly(s: string) {
    const date = new Date(s);
    return new Date(date.getTime() + 
        date.getTimezoneOffset() * 60000);
}
//-----/CustomTypes.File-----

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

//-----/Types.File-----

import { addResultTypeFactory } from './helpers';
export { setBaseUrl, getBaseUrl } from './helpers';
export { setAxiosFactory, getAxios } from './helpers';


//-----PersistorHydrator.File-----
import type { PersistedClient } from '@tanstack/react-query-persist-client';
import type { DehydratedState, QueryKey } from '@tanstack/react-query'
import { getResultTypeFactory } from './helpers';

/*
 * If you have Dates in QueryKeys (i.e. in request parameters), you need to deserialize them to Dates correctly
 * (otherwise they are deserialized as strings by default, and your queries are broken).
 */
export function deserializeDate(str: unknown) {
  if (!str || typeof str !== 'string') return str;
  if (!/^\d\d\d\d\-\d\d\-\d\d/.test(str)) return str;
  
  const date = new Date(str);
  const isDate = date instanceof Date && !isNaN(date as any);
  
  return isDate ? date : str;
}

export function deserializeDatesInQueryKeys(queryKey: QueryKey) {
  return queryKey
    // We need to replace `null` with `undefined` in query key, because
    // `undefined` is serialized as `null`.
    // And most probably if we have `null` in QueryKey it actually means `undefined`.
    // We can't keep nulls, because they have a different meaning, and e.g. boolean parameters are not allowed to be null.
    .map(x => (x === null ? undefined : x))
    .map(x => deserializeDate(x));
}

export function deserializeClassesInQueryData(queryKey: QueryKey, data: any) {
  if (!data) {
    return data;
  } else if (typeof data !== 'object') {
    return data;
  } else if ('pages' in data && 'pageParams' in data && Array.isArray(data.pages) && Array.isArray(data.pageParams)) {
    // infinite query
    data.pages = data.pages.map((page:any) => deserializeClassesInQueryData(queryKey, page));
  } else if (Array.isArray(data)) {
    return data.map(elem => constructDtoClass(queryKey, elem));
  } else {
    return constructDtoClass(queryKey, data);
  }
}

/*
 * Pass this function as `deserialize` option to createSyncStoragePersister/createAsyncStoragePersister
 * to correctly deserialize your DTOs (including Dates)
 */
export function persisterDeserialize(cache: string): PersistedClient {
  const client: PersistedClient = JSON.parse(cache);
  client.clientState.queries.forEach((query) => {
    query.state.data = deserializeClassesInQueryData(query.queryKey, query.state.data);
    query.queryKey = deserializeDatesInQueryKeys(query.queryKey);
  });

  return client;
}

export function constructDtoClass(queryKey: QueryKey, data: any): unknown {
  const resultTypeKey = getResultTypeClassKey(queryKey);
  const constructorFunction = getResultTypeFactory(resultTypeKey);

  if (!data || !constructorFunction)
    return data;

  return constructorFunction(data);
}

export function getResultTypeClassKey(queryKey: QueryKey): string {
  if (!Array.isArray(queryKey)) {
    return queryKey as unknown as string;
  }
  if (queryKey.length >= 2) {
    // We concatenate first and second elements, because they uniquely identify the query.
    // All other QueryKey elements are query parameters
    return `${queryKey[0]}___${queryKey[1]}`;
  }

  // We actually should never reach this point :)
  return queryKey.join('___');
}

export function initPersister() {
  
  addResultTypeFactory('Client___servicesGET', (data: any) => { const result = new Service2(); result.init(data); return result; });
  addResultTypeFactory('Client___engagement', (data: any) => { const result = new Engagement(); result.init(data); return result; });
  addResultTypeFactory('Client___available', (data: any) => { const result = new Pricing(); result.init(data); return result; });
  addResultTypeFactory('Client___requestGET', (data: any) => { const result = new EngagementRequest(); result.init(data); return result; });
  addResultTypeFactory('Client___invoices', (data: any) => { const result = new Invoice(); result.init(data); return result; });
  addResultTypeFactory('Client___consumption', (data: any) => { const result = new Summary(); result.init(data); return result; });
  addResultTypeFactory('Client___element', (data: any) => { const result = new Element(); result.init(data); return result; });
  addResultTypeFactory('Client___forecast', (data: any) => { const result = new Summary(); result.init(data); return result; });
  addResultTypeFactory('Client___element2', (data: any) => { const result = new Element(); result.init(data); return result; });
  addResultTypeFactory('Client___history', (data: any) => { const result = new Summary(); result.init(data); return result; });
  addResultTypeFactory('Client___element3', (data: any) => { const result = new Element(); result.init(data); return result; });
  addResultTypeFactory('Client___detachAll', (data: any) => { const result = new GenericProductDefinition(); result.init(data); return result; });
  addResultTypeFactory('Client___detach', (data: any) => { const result = new GenericProductDefinition(); result.init(data); return result; });
  addResultTypeFactory('Client___options', (data: any) => { const result = new DetachOptionsDefinition(); result.init(data); return result; });
  addResultTypeFactory('Client___formAll', (data: any) => { const result = new Description(); result.init(data); return result; });
  addResultTypeFactory('Client___form', (data: any) => { const result = new Description(); result.init(data); return result; });
  addResultTypeFactory('Client___options2', (data: any) => { const result = new Service2(); result.init(data); return result; });
  addResultTypeFactory('Client___contracts', (data: any) => { const result = new Contract(); result.init(data); return result; });
  addResultTypeFactory('Client___subscribable', (data: any) => { const result = new SubscribableSavingsPlanOffer(); result.init(data); return result; });
  addResultTypeFactory('Client___subscribedAll', (data: any) => { const result = new SavingsPlan(); result.init(data); return result; });
  addResultTypeFactory('Client___subscribedGET', (data: any) => { const result = new SavingsPlan(); result.init(data); return result; });
  addResultTypeFactory('Client___periods', (data: any) => { const result = new Period(); result.init(data); return result; });
  addResultTypeFactory('Client___technicalDetails', (data: any) => { const result = new TechnicalDetails(); result.init(data); return result; });
  addResultTypeFactory('Client___upgradeAll', (data: any) => { const result = new GenericProductDefinition(); result.init(data); return result; });
  addResultTypeFactory('Client___upgrade', (data: any) => { const result = new GenericProductDefinition(); result.init(data); return result; });


}
//-----/PersistorHydrator.File----