//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from './axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from './axios-client';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);
import type { AxiosRequestConfig } from 'axios';

export type ServicesAllQueryParameters = {
  orderBy: string | undefined ;
  resourceName: string | undefined ;
  routes: string | undefined ;
  sort: string | undefined ;
}

export type ServicesGETQueryParameters = {
  serviceId: number ;
}

export type ServicesPUTQueryParameters = {
  serviceId: number ;
}

export type EngagementQueryParameters = {
  serviceId: number ;
}

export type AvailableQueryParameters = {
  serviceId: number ;
}

export type EndRuleQueryParameters = {
  serviceId: number ;
}

export type FlushQueryParameters = {
  serviceId: number ;
}

export type RequestDELETEQueryParameters = {
  serviceId: number ;
}

export type RequestGETQueryParameters = {
  serviceId: number ;
}

export type RequestPOSTQueryParameters = {
  serviceId: number ;
}

export type InvoicesAllQueryParameters = {
  serviceId: number ;
}

export type InvoicesQueryParameters = {
  invoiceId: string ;
  serviceId: number ;
}

export type ConsumptionQueryParameters = {
  serviceId: number ;
}

export type ElementQueryParameters = {
  planFamily: string | undefined ;
  serviceId: number ;
  uniqueId: string | undefined ;
}

export type ForecastQueryParameters = {
  serviceId: number ;
}

export type Element2QueryParameters = {
  planFamily: string | undefined ;
  serviceId: number ;
  uniqueId: string | undefined ;
}

export type HistoryAllQueryParameters = {
  planFamily: string | undefined ;
  serviceId: number ;
  uniqueId: string | undefined ;
}

export type HistoryQueryParameters = {
  id: number ;
  serviceId: number ;
}

export type Element3QueryParameters = {
  id: number ;
  planFamily: string | undefined ;
  serviceId: number ;
  uniqueId: string | undefined ;
}

export type ContactsQueryParameters = {
  serviceId: number ;
}

export type DetachAllQueryParameters = {
  serviceId: number ;
}

export type DetachQueryParameters = {
  planCode: string ;
  serviceId: number ;
}

export type ExecuteQueryParameters = {
  planCode: string ;
  serviceId: number ;
}

export type OptionsQueryParameters = {
  planCode: string ;
  serviceId: number ;
}

export type SimulateQueryParameters = {
  planCode: string ;
  serviceId: number ;
}

export type FormAllQueryParameters = {
  serviceId: number ;
}

export type FormQueryParameters = {
  formName: string ;
  serviceId: number ;
}

export type AnswerQueryParameters = {
  formName: string ;
  serviceId: number ;
}

export type Options2QueryParameters = {
  serviceId: number ;
}

export type RenewPeriodCapacitiesQueryParameters = {
  serviceId: number ;
}

export type ContractsQueryParameters = {
  serviceId: number ;
}

export type SubscribableQueryParameters = {
  productCode: string | undefined ;
  serviceId: number ;
}

export type Execute2QueryParameters = {
  serviceId: number ;
}

export type Simulate2QueryParameters = {
  serviceId: number ;
}

export type SubscribedAllQueryParameters = {
  serviceId: number ;
}

export type SubscribedGETQueryParameters = {
  savingsPlanId: string ;
  serviceId: number ;
}

export type SubscribedPUTQueryParameters = {
  savingsPlanId: string ;
  serviceId: number ;
}

export type ChangePeriodEndActionQueryParameters = {
  savingsPlanId: string ;
  serviceId: number ;
}

export type ChangeSizeQueryParameters = {
  savingsPlanId: string ;
  serviceId: number ;
}

export type PeriodsQueryParameters = {
  savingsPlanId: string ;
  serviceId: number ;
}

export type TechnicalDetailsQueryParameters = {
  serviceId: number ;
}

export type TerminateQueryParameters = {
  serviceId: number ;
}

export type ConfirmQueryParameters = {
  serviceId: number ;
}

export type UpgradeAllQueryParameters = {
  serviceId: number ;
}

export type UpgradeQueryParameters = {
  planCode: string ;
  serviceId: number ;
}

export type Execute3QueryParameters = {
  planCode: string ;
  serviceId: number ;
}

export type Simulate3QueryParameters = {
  planCode: string ;
  serviceId: number ;
}

export function servicesAllUrl(orderBy: string | undefined, resourceName: string | undefined, routes: string | undefined, sort: string | undefined): string {
  let url_ = getBaseUrl() + "/services?";
if (orderBy === null)
    throw new Error("The parameter 'orderBy' cannot be null.");
else if (orderBy !== undefined)
    url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
if (resourceName === null)
    throw new Error("The parameter 'resourceName' cannot be null.");
else if (resourceName !== undefined)
    url_ += "resourceName=" + encodeURIComponent("" + resourceName) + "&";
if (routes === null)
    throw new Error("The parameter 'routes' cannot be null.");
else if (routes !== undefined)
    url_ += "routes=" + encodeURIComponent("" + routes) + "&";
if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
else if (sort !== undefined)
    url_ += "sort=" + encodeURIComponent("" + sort) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let servicesAllDefaultOptions: Omit<UseQueryOptions<number[], unknown, number[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<number[], unknown, number[]>, 'queryFn'>> = {
};
export function getServicesAllDefaultOptions() {
  return servicesAllDefaultOptions;
};
export function setServicesAllDefaultOptions(options: typeof servicesAllDefaultOptions) {
  servicesAllDefaultOptions = options;
}

export function servicesAllQueryKey(dto: ServicesAllQueryParameters): QueryKey;
export function servicesAllQueryKey(orderBy: string | undefined, resourceName: string | undefined, routes: string | undefined, sort: string | undefined): QueryKey;
export function servicesAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { orderBy, resourceName, routes, sort,  } = params[0] as ServicesAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'servicesAll',
        orderBy as any,
        resourceName as any,
        routes as any,
        sort as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'servicesAll',
        ...params
      ]);
  }
}
export function __servicesAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().servicesAll(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as string | undefined);
}

export function useServicesAllQuery<TSelectData = number[], TError = unknown>(dto: ServicesAllQueryParameters, options?: Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List available services
 * @param orderBy (optional) Order services by services.expanded.Service properties
 * @param resourceName (optional) Filter services by their resourceName (resource.name)
 * @param routes (optional) Filter services by API route path (comma separated)
 * @param sort (optional) Sort results generated by 'orderBy'
 * @return successful operation
 */
export function useServicesAllQuery<TSelectData = number[], TError = unknown>(orderBy: string | undefined, resourceName: string | undefined, routes: string | undefined, sort: string | undefined, options?: Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useServicesAllQuery<TSelectData = number[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<number[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let orderBy: any = undefined;
  let resourceName: any = undefined;
  let routes: any = undefined;
  let sort: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ orderBy, resourceName, routes, sort,  } = params[0] as ServicesAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [orderBy, resourceName, routes, sort, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<number[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __servicesAll(context, axiosConfig) : __servicesAll,
    queryKey: servicesAllQueryKey(orderBy, resourceName, routes, sort),
    ...servicesAllDefaultOptions as unknown as Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List available services
 * @param orderBy (optional) Order services by services.expanded.Service properties
 * @param resourceName (optional) Filter services by their resourceName (resource.name)
 * @param routes (optional) Filter services by API route path (comma separated)
 * @param sort (optional) Sort results generated by 'orderBy'
 * @return successful operation
 */
export function setServicesAllData(queryClient: QueryClient, updater: (data: number[] | undefined) => number[], orderBy: string | undefined, resourceName: string | undefined, routes: string | undefined, sort: string | undefined) {
  queryClient.setQueryData(servicesAllQueryKey(orderBy, resourceName, routes, sort),
    updater
  );
}

/**
 * List available services
 * @param orderBy (optional) Order services by services.expanded.Service properties
 * @param resourceName (optional) Filter services by their resourceName (resource.name)
 * @param routes (optional) Filter services by API route path (comma separated)
 * @param sort (optional) Sort results generated by 'orderBy'
 * @return successful operation
 */
export function setServicesAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: number[] | undefined) => number[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function servicesGETUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let servicesGETDefaultOptions: Omit<UseQueryOptions<Types.Service2, unknown, Types.Service2>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Service2, unknown, Types.Service2>, 'queryFn'>> = {
};
export function getServicesGETDefaultOptions() {
  return servicesGETDefaultOptions;
};
export function setServicesGETDefaultOptions(options: typeof servicesGETDefaultOptions) {
  servicesGETDefaultOptions = options;
}

export function servicesGETQueryKey(serviceId: number): QueryKey;
export function servicesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as ServicesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'servicesGET',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'servicesGET',
        ...params
      ]);
  }
}
export function __servicesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().servicesGET(
      context.queryKey[2] as number);
}

export function useServicesGETQuery<TSelectData = Types.Service2, TError = unknown>(dto: ServicesGETQueryParameters, options?: Omit<UseQueryOptions<Types.Service2, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get details about a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useServicesGETQuery<TSelectData = Types.Service2, TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.Service2, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useServicesGETQuery<TSelectData = Types.Service2, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Service2, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as ServicesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Service2, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __servicesGET(context, axiosConfig) : __servicesGET,
    queryKey: servicesGETQueryKey(serviceId),
    ...servicesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.Service2, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get details about a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setServicesGETData(queryClient: QueryClient, updater: (data: Types.Service2 | undefined) => Types.Service2, serviceId: number) {
  queryClient.setQueryData(servicesGETQueryKey(serviceId),
    updater
  );
}

/**
 * Get details about a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setServicesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Service2 | undefined) => Types.Service2) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function servicesPUTUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function servicesPUTMutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'servicesPUT',
      serviceId as any,
    ]);
}

/**
 * Update service information
 * @param serviceId Service ID
 * @return successful operation
 */
export function useServicesPUTMutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<void, unknown, Types.Service4, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.Service4, TContext> {
  const key = servicesPUTMutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Service4) => Client().servicesPUT(serviceId, body),
    mutationKey: key,
  });
}
  
type ServicesPUT__MutationParameters = ServicesPUTQueryParameters & {
  body: Types.Service4;
}

/**
 * Update service information
 * @param serviceId Service ID
 * @return successful operation
 */
export function useServicesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, ServicesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ServicesPUTQueryParameters}): UseMutationResult<void, unknown, ServicesPUT__MutationParameters, TContext> {
  const key = servicesPUTMutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ServicesPUT__MutationParameters) => Client().servicesPUT(data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function engagementUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/engagement";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let engagementDefaultOptions: Omit<UseQueryOptions<Types.Engagement, unknown, Types.Engagement>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Engagement, unknown, Types.Engagement>, 'queryFn'>> = {
};
export function getEngagementDefaultOptions() {
  return engagementDefaultOptions;
};
export function setEngagementDefaultOptions(options: typeof engagementDefaultOptions) {
  engagementDefaultOptions = options;
}

export function engagementQueryKey(serviceId: number): QueryKey;
export function engagementQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as EngagementQueryParameters;

    return trimArrayEnd([
        'Client',
        'engagement',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'engagement',
        ...params
      ]);
  }
}
export function __engagement(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().engagement(
      context.queryKey[2] as number);
}

export function useEngagementQuery<TSelectData = Types.Engagement, TError = unknown>(dto: EngagementQueryParameters, options?: Omit<UseQueryOptions<Types.Engagement, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get engagement details
 * @param serviceId Service ID
 * @return successful operation
 */
export function useEngagementQuery<TSelectData = Types.Engagement, TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.Engagement, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useEngagementQuery<TSelectData = Types.Engagement, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Engagement, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as EngagementQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Engagement, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __engagement(context, axiosConfig) : __engagement,
    queryKey: engagementQueryKey(serviceId),
    ...engagementDefaultOptions as unknown as Omit<UseQueryOptions<Types.Engagement, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get engagement details
 * @param serviceId Service ID
 * @return successful operation
 */
export function setEngagementData(queryClient: QueryClient, updater: (data: Types.Engagement | undefined) => Types.Engagement, serviceId: number) {
  queryClient.setQueryData(engagementQueryKey(serviceId),
    updater
  );
}

/**
 * Get engagement details
 * @param serviceId Service ID
 * @return successful operation
 */
export function setEngagementDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Engagement | undefined) => Types.Engagement) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function availableUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/engagement/available";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let availableDefaultOptions: Omit<UseQueryOptions<Types.Pricing[], unknown, Types.Pricing[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Pricing[], unknown, Types.Pricing[]>, 'queryFn'>> = {
};
export function getAvailableDefaultOptions() {
  return availableDefaultOptions;
};
export function setAvailableDefaultOptions(options: typeof availableDefaultOptions) {
  availableDefaultOptions = options;
}

export function availableQueryKey(serviceId: number): QueryKey;
export function availableQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as AvailableQueryParameters;

    return trimArrayEnd([
        'Client',
        'available',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'available',
        ...params
      ]);
  }
}
export function __available(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().available(
      context.queryKey[2] as number);
}

export function useAvailableQuery<TSelectData = Types.Pricing[], TError = unknown>(dto: AvailableQueryParameters, options?: Omit<UseQueryOptions<Types.Pricing[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List all available engagements a given service can subscribe to
 * @param serviceId Service ID
 * @return successful operation
 */
export function useAvailableQuery<TSelectData = Types.Pricing[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.Pricing[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAvailableQuery<TSelectData = Types.Pricing[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Pricing[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as AvailableQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Pricing[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __available(context, axiosConfig) : __available,
    queryKey: availableQueryKey(serviceId),
    ...availableDefaultOptions as unknown as Omit<UseQueryOptions<Types.Pricing[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List all available engagements a given service can subscribe to
 * @param serviceId Service ID
 * @return successful operation
 */
export function setAvailableData(queryClient: QueryClient, updater: (data: Types.Pricing[] | undefined) => Types.Pricing[], serviceId: number) {
  queryClient.setQueryData(availableQueryKey(serviceId),
    updater
  );
}

/**
 * List all available engagements a given service can subscribe to
 * @param serviceId Service ID
 * @return successful operation
 */
export function setAvailableDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Pricing[] | undefined) => Types.Pricing[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function endRuleUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/engagement/endRule";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function endRuleMutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'endRule',
      serviceId as any,
    ]);
}

/**
 * Change your Engagement end rules
 * @param serviceId Service ID
 * @return successful operation
 */
export function useEndRuleMutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<void, unknown, Types.UpdateEndRuleRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.UpdateEndRuleRequest, TContext> {
  const key = endRuleMutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UpdateEndRuleRequest) => Client().endRule(serviceId, body),
    mutationKey: key,
  });
}
  
type EndRule__MutationParameters = EndRuleQueryParameters & {
  body: Types.UpdateEndRuleRequest;
}

/**
 * Change your Engagement end rules
 * @param serviceId Service ID
 * @return successful operation
 */
export function useEndRuleMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, EndRule__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: EndRuleQueryParameters}): UseMutationResult<void, unknown, EndRule__MutationParameters, TContext> {
  const key = endRuleMutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: EndRule__MutationParameters) => Client().endRule(data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function flushUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/engagement/flush";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function flushMutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'flush',
      serviceId as any,
    ]);
}

/**
 * Flush the engagement of this service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useFlushMutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<Types.EngagementFlushOrder, unknown, Types.EngagementFlushRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.EngagementFlushOrder, unknown, Types.EngagementFlushRequest, TContext> {
  const key = flushMutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.EngagementFlushRequest) => Client().flush(serviceId, body),
    mutationKey: key,
  });
}
  
type Flush__MutationParameters = FlushQueryParameters & {
  body: Types.EngagementFlushRequest;
}

/**
 * Flush the engagement of this service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useFlushMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.EngagementFlushOrder, unknown, Flush__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: FlushQueryParameters}): UseMutationResult<Types.EngagementFlushOrder, unknown, Flush__MutationParameters, TContext> {
  const key = flushMutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Flush__MutationParameters) => Client().flush(data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function requestDELETEUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/engagement/request";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function requestDELETEMutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'requestDELETE',
      serviceId as any,
    ]);
}

/**
 * Delete the ongoing Engagement request on this Service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useRequestDELETEMutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = requestDELETEMutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().requestDELETE(serviceId),
    mutationKey: key,
  });
}
  
type RequestDELETE__MutationParameters = RequestDELETEQueryParameters

/**
 * Delete the ongoing Engagement request on this Service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useRequestDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, RequestDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: RequestDELETEQueryParameters}): UseMutationResult<void, unknown, RequestDELETE__MutationParameters, TContext> {
  const key = requestDELETEMutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: RequestDELETE__MutationParameters) => Client().requestDELETE(data.serviceId ?? options?.parameters?.serviceId!),
  mutationKey: key,
});
}
  
export function requestGETUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/engagement/request";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let requestGETDefaultOptions: Omit<UseQueryOptions<Types.EngagementRequest, unknown, Types.EngagementRequest>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EngagementRequest, unknown, Types.EngagementRequest>, 'queryFn'>> = {
};
export function getRequestGETDefaultOptions() {
  return requestGETDefaultOptions;
};
export function setRequestGETDefaultOptions(options: typeof requestGETDefaultOptions) {
  requestGETDefaultOptions = options;
}

export function requestGETQueryKey(serviceId: number): QueryKey;
export function requestGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as RequestGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'requestGET',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'requestGET',
        ...params
      ]);
  }
}
export function __requestGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().requestGET(
      context.queryKey[2] as number);
}

export function useRequestGETQuery<TSelectData = Types.EngagementRequest, TError = unknown>(dto: RequestGETQueryParameters, options?: Omit<UseQueryOptions<Types.EngagementRequest, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get the ongoing Engagement request on this Service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useRequestGETQuery<TSelectData = Types.EngagementRequest, TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.EngagementRequest, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRequestGETQuery<TSelectData = Types.EngagementRequest, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EngagementRequest, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as RequestGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EngagementRequest, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __requestGET(context, axiosConfig) : __requestGET,
    queryKey: requestGETQueryKey(serviceId),
    ...requestGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.EngagementRequest, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get the ongoing Engagement request on this Service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setRequestGETData(queryClient: QueryClient, updater: (data: Types.EngagementRequest | undefined) => Types.EngagementRequest, serviceId: number) {
  queryClient.setQueryData(requestGETQueryKey(serviceId),
    updater
  );
}

/**
 * Get the ongoing Engagement request on this Service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setRequestGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EngagementRequest | undefined) => Types.EngagementRequest) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function requestPOSTUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/engagement/request";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function requestPOSTMutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'requestPOST',
      serviceId as any,
    ]);
}

/**
 * Request an Engagement on this Service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useRequestPOSTMutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<Types.EngagementRequest, unknown, Types.EngagementRequestCreation, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.EngagementRequest, unknown, Types.EngagementRequestCreation, TContext> {
  const key = requestPOSTMutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.EngagementRequestCreation) => Client().requestPOST(serviceId, body),
    mutationKey: key,
  });
}
  
type RequestPOST__MutationParameters = RequestPOSTQueryParameters & {
  body: Types.EngagementRequestCreation;
}

/**
 * Request an Engagement on this Service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useRequestPOSTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.EngagementRequest, unknown, RequestPOST__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: RequestPOSTQueryParameters}): UseMutationResult<Types.EngagementRequest, unknown, RequestPOST__MutationParameters, TContext> {
  const key = requestPOSTMutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: RequestPOST__MutationParameters) => Client().requestPOST(data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function invoicesAllUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/invoices";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let invoicesAllDefaultOptions: Omit<UseQueryOptions<string[], unknown, string[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string[], unknown, string[]>, 'queryFn'>> = {
};
export function getInvoicesAllDefaultOptions() {
  return invoicesAllDefaultOptions;
};
export function setInvoicesAllDefaultOptions(options: typeof invoicesAllDefaultOptions) {
  invoicesAllDefaultOptions = options;
}

export function invoicesAllQueryKey(serviceId: number): QueryKey;
export function invoicesAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as InvoicesAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'invoicesAll',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'invoicesAll',
        ...params
      ]);
  }
}
export function __invoicesAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().invoicesAll(
      context.queryKey[2] as number);
}

export function useInvoicesAllQuery<TSelectData = string[], TError = unknown>(dto: InvoicesAllQueryParameters, options?: Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List available invoices
 * @param serviceId Service ID
 * @return successful operation
 */
export function useInvoicesAllQuery<TSelectData = string[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useInvoicesAllQuery<TSelectData = string[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as InvoicesAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __invoicesAll(context, axiosConfig) : __invoicesAll,
    queryKey: invoicesAllQueryKey(serviceId),
    ...invoicesAllDefaultOptions as unknown as Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List available invoices
 * @param serviceId Service ID
 * @return successful operation
 */
export function setInvoicesAllData(queryClient: QueryClient, updater: (data: string[] | undefined) => string[], serviceId: number) {
  queryClient.setQueryData(invoicesAllQueryKey(serviceId),
    updater
  );
}

/**
 * List available invoices
 * @param serviceId Service ID
 * @return successful operation
 */
export function setInvoicesAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string[] | undefined) => string[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function invoicesUrl(invoiceId: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/billing/invoices/{invoiceId}";
if (invoiceId === undefined || invoiceId === null)
  throw new Error("The parameter 'invoiceId' must be defined.");
url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let invoicesDefaultOptions: Omit<UseQueryOptions<Types.Invoice, unknown, Types.Invoice>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Invoice, unknown, Types.Invoice>, 'queryFn'>> = {
};
export function getInvoicesDefaultOptions() {
  return invoicesDefaultOptions;
};
export function setInvoicesDefaultOptions(options: typeof invoicesDefaultOptions) {
  invoicesDefaultOptions = options;
}

export function invoicesQueryKey(dto: InvoicesQueryParameters): QueryKey;
export function invoicesQueryKey(invoiceId: string, serviceId: number): QueryKey;
export function invoicesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { invoiceId, serviceId,  } = params[0] as InvoicesQueryParameters;

    return trimArrayEnd([
        'Client',
        'invoices',
        invoiceId as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'invoices',
        ...params
      ]);
  }
}
export function __invoices(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().invoices(
      context.queryKey[2] as string,       context.queryKey[3] as number);
}

export function useInvoicesQuery<TSelectData = Types.Invoice, TError = unknown>(dto: InvoicesQueryParameters, options?: Omit<UseQueryOptions<Types.Invoice, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get service's invoices
 * @param invoiceId Invoice ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function useInvoicesQuery<TSelectData = Types.Invoice, TError = unknown>(invoiceId: string, serviceId: number, options?: Omit<UseQueryOptions<Types.Invoice, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useInvoicesQuery<TSelectData = Types.Invoice, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Invoice, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let invoiceId: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ invoiceId, serviceId,  } = params[0] as InvoicesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [invoiceId, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Invoice, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __invoices(context, axiosConfig) : __invoices,
    queryKey: invoicesQueryKey(invoiceId, serviceId),
    ...invoicesDefaultOptions as unknown as Omit<UseQueryOptions<Types.Invoice, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get service's invoices
 * @param invoiceId Invoice ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function setInvoicesData(queryClient: QueryClient, updater: (data: Types.Invoice | undefined) => Types.Invoice, invoiceId: string, serviceId: number) {
  queryClient.setQueryData(invoicesQueryKey(invoiceId, serviceId),
    updater
  );
}

/**
 * Get service's invoices
 * @param invoiceId Invoice ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function setInvoicesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Invoice | undefined) => Types.Invoice) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function consumptionUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/consumption";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let consumptionDefaultOptions: Omit<UseQueryOptions<Types.Summary, unknown, Types.Summary>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Summary, unknown, Types.Summary>, 'queryFn'>> = {
};
export function getConsumptionDefaultOptions() {
  return consumptionDefaultOptions;
};
export function setConsumptionDefaultOptions(options: typeof consumptionDefaultOptions) {
  consumptionDefaultOptions = options;
}

export function consumptionQueryKey(serviceId: number): QueryKey;
export function consumptionQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as ConsumptionQueryParameters;

    return trimArrayEnd([
        'Client',
        'consumption',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'consumption',
        ...params
      ]);
  }
}
export function __consumption(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().consumption(
      context.queryKey[2] as number);
}

export function useConsumptionQuery<TSelectData = Types.Summary, TError = unknown>(dto: ConsumptionQueryParameters, options?: Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get a summary of the ongoing consumption of your service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useConsumptionQuery<TSelectData = Types.Summary, TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useConsumptionQuery<TSelectData = Types.Summary, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Summary, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as ConsumptionQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Summary, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __consumption(context, axiosConfig) : __consumption,
    queryKey: consumptionQueryKey(serviceId),
    ...consumptionDefaultOptions as unknown as Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get a summary of the ongoing consumption of your service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setConsumptionData(queryClient: QueryClient, updater: (data: Types.Summary | undefined) => Types.Summary, serviceId: number) {
  queryClient.setQueryData(consumptionQueryKey(serviceId),
    updater
  );
}

/**
 * Get a summary of the ongoing consumption of your service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setConsumptionDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Summary | undefined) => Types.Summary) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function elementUrl(serviceId: number, planFamily: string | undefined, uniqueId: string | undefined): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/consumption/element?";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
if (planFamily === null)
    throw new Error("The parameter 'planFamily' cannot be null.");
else if (planFamily !== undefined)
    url_ += "planFamily=" + encodeURIComponent("" + planFamily) + "&";
if (uniqueId === null)
    throw new Error("The parameter 'uniqueId' cannot be null.");
else if (uniqueId !== undefined)
    url_ += "uniqueId=" + encodeURIComponent("" + uniqueId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let elementDefaultOptions: Omit<UseQueryOptions<Types.Element[], unknown, Types.Element[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Element[], unknown, Types.Element[]>, 'queryFn'>> = {
};
export function getElementDefaultOptions() {
  return elementDefaultOptions;
};
export function setElementDefaultOptions(options: typeof elementDefaultOptions) {
  elementDefaultOptions = options;
}

export function elementQueryKey(dto: ElementQueryParameters): QueryKey;
export function elementQueryKey(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined): QueryKey;
export function elementQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { planFamily, serviceId, uniqueId,  } = params[0] as ElementQueryParameters;

    return trimArrayEnd([
        'Client',
        'element',
        planFamily as any,
        serviceId as any,
        uniqueId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'element',
        ...params
      ]);
  }
}
export function __element(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().element(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number,       context.queryKey[4] as string | undefined);
}

export function useElementQuery<TSelectData = Types.Element[], TError = unknown>(dto: ElementQueryParameters, options?: Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get each resource consumed by your service
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function useElementQuery<TSelectData = Types.Element[], TError = unknown>(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined, options?: Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useElementQuery<TSelectData = Types.Element[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Element[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let planFamily: any = undefined;
  let serviceId: any = undefined;
  let uniqueId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ planFamily, serviceId, uniqueId,  } = params[0] as ElementQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [planFamily, serviceId, uniqueId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Element[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __element(context, axiosConfig) : __element,
    queryKey: elementQueryKey(planFamily, serviceId, uniqueId),
    ...elementDefaultOptions as unknown as Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get each resource consumed by your service
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function setElementData(queryClient: QueryClient, updater: (data: Types.Element[] | undefined) => Types.Element[], planFamily: string | undefined, serviceId: number, uniqueId: string | undefined) {
  queryClient.setQueryData(elementQueryKey(planFamily, serviceId, uniqueId),
    updater
  );
}

/**
 * Get each resource consumed by your service
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function setElementDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Element[] | undefined) => Types.Element[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function forecastUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/consumption/forecast";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let forecastDefaultOptions: Omit<UseQueryOptions<Types.Summary, unknown, Types.Summary>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Summary, unknown, Types.Summary>, 'queryFn'>> = {
};
export function getForecastDefaultOptions() {
  return forecastDefaultOptions;
};
export function setForecastDefaultOptions(options: typeof forecastDefaultOptions) {
  forecastDefaultOptions = options;
}

export function forecastQueryKey(serviceId: number): QueryKey;
export function forecastQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as ForecastQueryParameters;

    return trimArrayEnd([
        'Client',
        'forecast',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'forecast',
        ...params
      ]);
  }
}
export function __forecast(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().forecast(
      context.queryKey[2] as number);
}

export function useForecastQuery<TSelectData = Types.Summary, TError = unknown>(dto: ForecastQueryParameters, options?: Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get a summary of the forecasted consumption of your service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useForecastQuery<TSelectData = Types.Summary, TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useForecastQuery<TSelectData = Types.Summary, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Summary, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as ForecastQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Summary, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __forecast(context, axiosConfig) : __forecast,
    queryKey: forecastQueryKey(serviceId),
    ...forecastDefaultOptions as unknown as Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get a summary of the forecasted consumption of your service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setForecastData(queryClient: QueryClient, updater: (data: Types.Summary | undefined) => Types.Summary, serviceId: number) {
  queryClient.setQueryData(forecastQueryKey(serviceId),
    updater
  );
}

/**
 * Get a summary of the forecasted consumption of your service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setForecastDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Summary | undefined) => Types.Summary) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function element2Url(serviceId: number, planFamily: string | undefined, uniqueId: string | undefined): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/consumption/forecast/element?";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
if (planFamily === null)
    throw new Error("The parameter 'planFamily' cannot be null.");
else if (planFamily !== undefined)
    url_ += "planFamily=" + encodeURIComponent("" + planFamily) + "&";
if (uniqueId === null)
    throw new Error("The parameter 'uniqueId' cannot be null.");
else if (uniqueId !== undefined)
    url_ += "uniqueId=" + encodeURIComponent("" + uniqueId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let element2DefaultOptions: Omit<UseQueryOptions<Types.Element[], unknown, Types.Element[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Element[], unknown, Types.Element[]>, 'queryFn'>> = {
};
export function getElement2DefaultOptions() {
  return element2DefaultOptions;
};
export function setElement2DefaultOptions(options: typeof element2DefaultOptions) {
  element2DefaultOptions = options;
}

export function element2QueryKey(dto: Element2QueryParameters): QueryKey;
export function element2QueryKey(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined): QueryKey;
export function element2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { planFamily, serviceId, uniqueId,  } = params[0] as Element2QueryParameters;

    return trimArrayEnd([
        'Client',
        'element2',
        planFamily as any,
        serviceId as any,
        uniqueId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'element2',
        ...params
      ]);
  }
}
export function __element2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().element2(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number,       context.queryKey[4] as string | undefined);
}

export function useElement2Query<TSelectData = Types.Element[], TError = unknown>(dto: Element2QueryParameters, options?: Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get each resource forecasted consumption of your service
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function useElement2Query<TSelectData = Types.Element[], TError = unknown>(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined, options?: Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useElement2Query<TSelectData = Types.Element[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Element[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let planFamily: any = undefined;
  let serviceId: any = undefined;
  let uniqueId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ planFamily, serviceId, uniqueId,  } = params[0] as Element2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [planFamily, serviceId, uniqueId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Element[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __element2(context, axiosConfig) : __element2,
    queryKey: element2QueryKey(planFamily, serviceId, uniqueId),
    ...element2DefaultOptions as unknown as Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get each resource forecasted consumption of your service
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function setElement2Data(queryClient: QueryClient, updater: (data: Types.Element[] | undefined) => Types.Element[], planFamily: string | undefined, serviceId: number, uniqueId: string | undefined) {
  queryClient.setQueryData(element2QueryKey(planFamily, serviceId, uniqueId),
    updater
  );
}

/**
 * Get each resource forecasted consumption of your service
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function setElement2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Element[] | undefined) => Types.Element[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function historyAllUrl(serviceId: number, planFamily: string | undefined, uniqueId: string | undefined): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/consumption/history?";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
if (planFamily === null)
    throw new Error("The parameter 'planFamily' cannot be null.");
else if (planFamily !== undefined)
    url_ += "planFamily=" + encodeURIComponent("" + planFamily) + "&";
if (uniqueId === null)
    throw new Error("The parameter 'uniqueId' cannot be null.");
else if (uniqueId !== undefined)
    url_ += "uniqueId=" + encodeURIComponent("" + uniqueId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let historyAllDefaultOptions: Omit<UseQueryOptions<number[], unknown, number[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<number[], unknown, number[]>, 'queryFn'>> = {
};
export function getHistoryAllDefaultOptions() {
  return historyAllDefaultOptions;
};
export function setHistoryAllDefaultOptions(options: typeof historyAllDefaultOptions) {
  historyAllDefaultOptions = options;
}

export function historyAllQueryKey(dto: HistoryAllQueryParameters): QueryKey;
export function historyAllQueryKey(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined): QueryKey;
export function historyAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { planFamily, serviceId, uniqueId,  } = params[0] as HistoryAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'historyAll',
        planFamily as any,
        serviceId as any,
        uniqueId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'historyAll',
        ...params
      ]);
  }
}
export function __historyAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().historyAll(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number,       context.queryKey[4] as string | undefined);
}

export function useHistoryAllQuery<TSelectData = number[], TError = unknown>(dto: HistoryAllQueryParameters, options?: Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List consumption history of your service
 * @param planFamily (optional) Order services by services.expanded.Service properties
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter services by API route path (comma separated)
 * @return successful operation
 */
export function useHistoryAllQuery<TSelectData = number[], TError = unknown>(planFamily: string | undefined, serviceId: number, uniqueId: string | undefined, options?: Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHistoryAllQuery<TSelectData = number[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<number[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let planFamily: any = undefined;
  let serviceId: any = undefined;
  let uniqueId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ planFamily, serviceId, uniqueId,  } = params[0] as HistoryAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [planFamily, serviceId, uniqueId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<number[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __historyAll(context, axiosConfig) : __historyAll,
    queryKey: historyAllQueryKey(planFamily, serviceId, uniqueId),
    ...historyAllDefaultOptions as unknown as Omit<UseQueryOptions<number[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List consumption history of your service
 * @param planFamily (optional) Order services by services.expanded.Service properties
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter services by API route path (comma separated)
 * @return successful operation
 */
export function setHistoryAllData(queryClient: QueryClient, updater: (data: number[] | undefined) => number[], planFamily: string | undefined, serviceId: number, uniqueId: string | undefined) {
  queryClient.setQueryData(historyAllQueryKey(planFamily, serviceId, uniqueId),
    updater
  );
}

/**
 * List consumption history of your service
 * @param planFamily (optional) Order services by services.expanded.Service properties
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter services by API route path (comma separated)
 * @return successful operation
 */
export function setHistoryAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: number[] | undefined) => number[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function historyUrl(id: number, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/consumption/history/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let historyDefaultOptions: Omit<UseQueryOptions<Types.Summary, unknown, Types.Summary>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Summary, unknown, Types.Summary>, 'queryFn'>> = {
};
export function getHistoryDefaultOptions() {
  return historyDefaultOptions;
};
export function setHistoryDefaultOptions(options: typeof historyDefaultOptions) {
  historyDefaultOptions = options;
}

export function historyQueryKey(dto: HistoryQueryParameters): QueryKey;
export function historyQueryKey(id: number, serviceId: number): QueryKey;
export function historyQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, serviceId,  } = params[0] as HistoryQueryParameters;

    return trimArrayEnd([
        'Client',
        'history',
        id as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'history',
        ...params
      ]);
  }
}
export function __history(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().history(
      context.queryKey[2] as number,       context.queryKey[3] as number);
}

export function useHistoryQuery<TSelectData = Types.Summary, TError = unknown>(dto: HistoryQueryParameters, options?: Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get a summary of the past consumption of your service
 * @param id Id
 * @param serviceId Service ID
 * @return successful operation
 */
export function useHistoryQuery<TSelectData = Types.Summary, TError = unknown>(id: number, serviceId: number, options?: Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHistoryQuery<TSelectData = Types.Summary, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Summary, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, serviceId,  } = params[0] as HistoryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Summary, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __history(context, axiosConfig) : __history,
    queryKey: historyQueryKey(id, serviceId),
    ...historyDefaultOptions as unknown as Omit<UseQueryOptions<Types.Summary, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get a summary of the past consumption of your service
 * @param id Id
 * @param serviceId Service ID
 * @return successful operation
 */
export function setHistoryData(queryClient: QueryClient, updater: (data: Types.Summary | undefined) => Types.Summary, id: number, serviceId: number) {
  queryClient.setQueryData(historyQueryKey(id, serviceId),
    updater
  );
}

/**
 * Get a summary of the past consumption of your service
 * @param id Id
 * @param serviceId Service ID
 * @return successful operation
 */
export function setHistoryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Summary | undefined) => Types.Summary) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function element3Url(id: number, serviceId: number, planFamily: string | undefined, uniqueId: string | undefined): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/consumption/history/{id}/element?";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
if (planFamily === null)
    throw new Error("The parameter 'planFamily' cannot be null.");
else if (planFamily !== undefined)
    url_ += "planFamily=" + encodeURIComponent("" + planFamily) + "&";
if (uniqueId === null)
    throw new Error("The parameter 'uniqueId' cannot be null.");
else if (uniqueId !== undefined)
    url_ += "uniqueId=" + encodeURIComponent("" + uniqueId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let element3DefaultOptions: Omit<UseQueryOptions<Types.Element[], unknown, Types.Element[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Element[], unknown, Types.Element[]>, 'queryFn'>> = {
};
export function getElement3DefaultOptions() {
  return element3DefaultOptions;
};
export function setElement3DefaultOptions(options: typeof element3DefaultOptions) {
  element3DefaultOptions = options;
}

export function element3QueryKey(dto: Element3QueryParameters): QueryKey;
export function element3QueryKey(id: number, planFamily: string | undefined, serviceId: number, uniqueId: string | undefined): QueryKey;
export function element3QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, planFamily, serviceId, uniqueId,  } = params[0] as Element3QueryParameters;

    return trimArrayEnd([
        'Client',
        'element3',
        id as any,
        planFamily as any,
        serviceId as any,
        uniqueId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'element3',
        ...params
      ]);
  }
}
export function __element3(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().element3(
      context.queryKey[2] as number,       context.queryKey[3] as string | undefined,       context.queryKey[4] as number,       context.queryKey[5] as string | undefined);
}

export function useElement3Query<TSelectData = Types.Element[], TError = unknown>(dto: Element3QueryParameters, options?: Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get each resource consumed for the given history
 * @param id Id
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function useElement3Query<TSelectData = Types.Element[], TError = unknown>(id: number, planFamily: string | undefined, serviceId: number, uniqueId: string | undefined, options?: Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useElement3Query<TSelectData = Types.Element[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Element[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  let planFamily: any = undefined;
  let serviceId: any = undefined;
  let uniqueId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, planFamily, serviceId, uniqueId,  } = params[0] as Element3QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, planFamily, serviceId, uniqueId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Element[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __element3(context, axiosConfig) : __element3,
    queryKey: element3QueryKey(id, planFamily, serviceId, uniqueId),
    ...element3DefaultOptions as unknown as Omit<UseQueryOptions<Types.Element[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get each resource consumed for the given history
 * @param id Id
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function setElement3Data(queryClient: QueryClient, updater: (data: Types.Element[] | undefined) => Types.Element[], id: number, planFamily: string | undefined, serviceId: number, uniqueId: string | undefined) {
  queryClient.setQueryData(element3QueryKey(id, planFamily, serviceId, uniqueId),
    updater
  );
}

/**
 * Get each resource consumed for the given history
 * @param id Id
 * @param planFamily (optional) Filter elements on a commercial offer's family
 * @param serviceId Service ID
 * @param uniqueId (optional) Filter elements on a given uniqueId
 * @return successful operation
 */
export function setElement3DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Element[] | undefined) => Types.Element[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function contactsUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/contacts";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function contactsMutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'contacts',
      serviceId as any,
    ]);
}

/**
 * Update service contacts
 * @param serviceId Service ID
 * @return successful operation
 */
export function useContactsMutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<Types.Task, unknown, Types.ContactChangeRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Task, unknown, Types.ContactChangeRequest, TContext> {
  const key = contactsMutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ContactChangeRequest) => Client().contacts(serviceId, body),
    mutationKey: key,
  });
}
  
type Contacts__MutationParameters = ContactsQueryParameters & {
  body: Types.ContactChangeRequest;
}

/**
 * Update service contacts
 * @param serviceId Service ID
 * @return successful operation
 */
export function useContactsMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Task, unknown, Contacts__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ContactsQueryParameters}): UseMutationResult<Types.Task, unknown, Contacts__MutationParameters, TContext> {
  const key = contactsMutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Contacts__MutationParameters) => Client().contacts(data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function detachAllUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/detach";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let detachAllDefaultOptions: Omit<UseQueryOptions<Types.GenericProductDefinition[], unknown, Types.GenericProductDefinition[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.GenericProductDefinition[], unknown, Types.GenericProductDefinition[]>, 'queryFn'>> = {
};
export function getDetachAllDefaultOptions() {
  return detachAllDefaultOptions;
};
export function setDetachAllDefaultOptions(options: typeof detachAllDefaultOptions) {
  detachAllDefaultOptions = options;
}

export function detachAllQueryKey(serviceId: number): QueryKey;
export function detachAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as DetachAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'detachAll',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'detachAll',
        ...params
      ]);
  }
}
export function __detachAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().detachAll(
      context.queryKey[2] as number);
}

export function useDetachAllQuery<TSelectData = Types.GenericProductDefinition[], TError = unknown>(dto: DetachAllQueryParameters, options?: Omit<UseQueryOptions<Types.GenericProductDefinition[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List offers this option can be converted to
 * @param serviceId Service ID
 * @return successful operation
 */
export function useDetachAllQuery<TSelectData = Types.GenericProductDefinition[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.GenericProductDefinition[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDetachAllQuery<TSelectData = Types.GenericProductDefinition[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GenericProductDefinition[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as DetachAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.GenericProductDefinition[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __detachAll(context, axiosConfig) : __detachAll,
    queryKey: detachAllQueryKey(serviceId),
    ...detachAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.GenericProductDefinition[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List offers this option can be converted to
 * @param serviceId Service ID
 * @return successful operation
 */
export function setDetachAllData(queryClient: QueryClient, updater: (data: Types.GenericProductDefinition[] | undefined) => Types.GenericProductDefinition[], serviceId: number) {
  queryClient.setQueryData(detachAllQueryKey(serviceId),
    updater
  );
}

/**
 * List offers this option can be converted to
 * @param serviceId Service ID
 * @return successful operation
 */
export function setDetachAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GenericProductDefinition[] | undefined) => Types.GenericProductDefinition[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function detachUrl(planCode: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/detach/{planCode}";
if (planCode === undefined || planCode === null)
  throw new Error("The parameter 'planCode' must be defined.");
url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let detachDefaultOptions: Omit<UseQueryOptions<Types.GenericProductDefinition, unknown, Types.GenericProductDefinition>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.GenericProductDefinition, unknown, Types.GenericProductDefinition>, 'queryFn'>> = {
};
export function getDetachDefaultOptions() {
  return detachDefaultOptions;
};
export function setDetachDefaultOptions(options: typeof detachDefaultOptions) {
  detachDefaultOptions = options;
}

export function detachQueryKey(dto: DetachQueryParameters): QueryKey;
export function detachQueryKey(planCode: string, serviceId: number): QueryKey;
export function detachQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { planCode, serviceId,  } = params[0] as DetachQueryParameters;

    return trimArrayEnd([
        'Client',
        'detach',
        planCode as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'detach',
        ...params
      ]);
  }
}
export function __detach(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().detach(
      context.queryKey[2] as string,       context.queryKey[3] as number);
}

export function useDetachQuery<TSelectData = Types.GenericProductDefinition, TError = unknown>(dto: DetachQueryParameters, options?: Omit<UseQueryOptions<Types.GenericProductDefinition, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * View an offer this option can be converted to
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useDetachQuery<TSelectData = Types.GenericProductDefinition, TError = unknown>(planCode: string, serviceId: number, options?: Omit<UseQueryOptions<Types.GenericProductDefinition, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDetachQuery<TSelectData = Types.GenericProductDefinition, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GenericProductDefinition, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let planCode: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ planCode, serviceId,  } = params[0] as DetachQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [planCode, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.GenericProductDefinition, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __detach(context, axiosConfig) : __detach,
    queryKey: detachQueryKey(planCode, serviceId),
    ...detachDefaultOptions as unknown as Omit<UseQueryOptions<Types.GenericProductDefinition, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * View an offer this option can be converted to
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function setDetachData(queryClient: QueryClient, updater: (data: Types.GenericProductDefinition | undefined) => Types.GenericProductDefinition, planCode: string, serviceId: number) {
  queryClient.setQueryData(detachQueryKey(planCode, serviceId),
    updater
  );
}

/**
 * View an offer this option can be converted to
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function setDetachDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GenericProductDefinition | undefined) => Types.GenericProductDefinition) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function executeUrl(planCode: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/detach/{planCode}/execute";
if (planCode === undefined || planCode === null)
  throw new Error("The parameter 'planCode' must be defined.");
url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function executeMutationKey(planCode: string, serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'execute',
      planCode as any,
      serviceId as any,
    ]);
}

/**
 * Perform the migration to a standalone offer. May require you to pay an Order
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useExecuteMutation<TContext>(planCode: string, serviceId: number, options?: Omit<UseMutationOptions<Types.Order2, unknown, Types.DetachExecutionRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Order2, unknown, Types.DetachExecutionRequest, TContext> {
  const key = executeMutationKey(planCode, serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DetachExecutionRequest) => Client().execute(planCode, serviceId, body),
    mutationKey: key,
  });
}
  
type Execute__MutationParameters = ExecuteQueryParameters & {
  body: Types.DetachExecutionRequest;
}

/**
 * Perform the migration to a standalone offer. May require you to pay an Order
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useExecuteMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Order2, unknown, Execute__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ExecuteQueryParameters}): UseMutationResult<Types.Order2, unknown, Execute__MutationParameters, TContext> {
  const key = executeMutationKey(options?.parameters?.planCode!, options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Execute__MutationParameters) => Client().execute(data.planCode ?? options?.parameters?.planCode!, data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function optionsUrl(planCode: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/detach/{planCode}/options";
if (planCode === undefined || planCode === null)
  throw new Error("The parameter 'planCode' must be defined.");
url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let optionsDefaultOptions: Omit<UseQueryOptions<Types.DetachOptionsDefinition[], unknown, Types.DetachOptionsDefinition[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DetachOptionsDefinition[], unknown, Types.DetachOptionsDefinition[]>, 'queryFn'>> = {
};
export function getOptionsDefaultOptions() {
  return optionsDefaultOptions;
};
export function setOptionsDefaultOptions(options: typeof optionsDefaultOptions) {
  optionsDefaultOptions = options;
}

export function optionsQueryKey(dto: OptionsQueryParameters): QueryKey;
export function optionsQueryKey(planCode: string, serviceId: number): QueryKey;
export function optionsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { planCode, serviceId,  } = params[0] as OptionsQueryParameters;

    return trimArrayEnd([
        'Client',
        'options',
        planCode as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'options',
        ...params
      ]);
  }
}
export function __options(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().options(
      context.queryKey[2] as string,       context.queryKey[3] as number);
}

export function useOptionsQuery<TSelectData = Types.DetachOptionsDefinition[], TError = unknown>(dto: OptionsQueryParameters, options?: Omit<UseQueryOptions<Types.DetachOptionsDefinition[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * View all offers compatible for the detachment for the given option offer
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useOptionsQuery<TSelectData = Types.DetachOptionsDefinition[], TError = unknown>(planCode: string, serviceId: number, options?: Omit<UseQueryOptions<Types.DetachOptionsDefinition[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useOptionsQuery<TSelectData = Types.DetachOptionsDefinition[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DetachOptionsDefinition[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let planCode: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ planCode, serviceId,  } = params[0] as OptionsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [planCode, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DetachOptionsDefinition[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __options(context, axiosConfig) : __options,
    queryKey: optionsQueryKey(planCode, serviceId),
    ...optionsDefaultOptions as unknown as Omit<UseQueryOptions<Types.DetachOptionsDefinition[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * View all offers compatible for the detachment for the given option offer
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function setOptionsData(queryClient: QueryClient, updater: (data: Types.DetachOptionsDefinition[] | undefined) => Types.DetachOptionsDefinition[], planCode: string, serviceId: number) {
  queryClient.setQueryData(optionsQueryKey(planCode, serviceId),
    updater
  );
}

/**
 * View all offers compatible for the detachment for the given option offer
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function setOptionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DetachOptionsDefinition[] | undefined) => Types.DetachOptionsDefinition[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function simulateUrl(planCode: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/detach/{planCode}/simulate";
if (planCode === undefined || planCode === null)
  throw new Error("The parameter 'planCode' must be defined.");
url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function simulateMutationKey(planCode: string, serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'simulate',
      planCode as any,
      serviceId as any,
    ]);
}

/**
 * Simulate the migration to a standalone offer
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSimulateMutation<TContext>(planCode: string, serviceId: number, options?: Omit<UseMutationOptions<Types.Order2, unknown, Types.DetachExecutionRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Order2, unknown, Types.DetachExecutionRequest, TContext> {
  const key = simulateMutationKey(planCode, serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DetachExecutionRequest) => Client().simulate(planCode, serviceId, body),
    mutationKey: key,
  });
}
  
type Simulate__MutationParameters = SimulateQueryParameters & {
  body: Types.DetachExecutionRequest;
}

/**
 * Simulate the migration to a standalone offer
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSimulateMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Order2, unknown, Simulate__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SimulateQueryParameters}): UseMutationResult<Types.Order2, unknown, Simulate__MutationParameters, TContext> {
  const key = simulateMutationKey(options?.parameters?.planCode!, options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Simulate__MutationParameters) => Client().simulate(data.planCode ?? options?.parameters?.planCode!, data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function formAllUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/form";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let formAllDefaultOptions: Omit<UseQueryOptions<Types.Description[], unknown, Types.Description[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Description[], unknown, Types.Description[]>, 'queryFn'>> = {
};
export function getFormAllDefaultOptions() {
  return formAllDefaultOptions;
};
export function setFormAllDefaultOptions(options: typeof formAllDefaultOptions) {
  formAllDefaultOptions = options;
}

export function formAllQueryKey(serviceId: number): QueryKey;
export function formAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as FormAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'formAll',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'formAll',
        ...params
      ]);
  }
}
export function __formAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().formAll(
      context.queryKey[2] as number);
}

export function useFormAllQuery<TSelectData = Types.Description[], TError = unknown>(dto: FormAllQueryParameters, options?: Omit<UseQueryOptions<Types.Description[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List available forms for service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useFormAllQuery<TSelectData = Types.Description[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.Description[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFormAllQuery<TSelectData = Types.Description[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Description[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as FormAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Description[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __formAll(context, axiosConfig) : __formAll,
    queryKey: formAllQueryKey(serviceId),
    ...formAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.Description[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List available forms for service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setFormAllData(queryClient: QueryClient, updater: (data: Types.Description[] | undefined) => Types.Description[], serviceId: number) {
  queryClient.setQueryData(formAllQueryKey(serviceId),
    updater
  );
}

/**
 * List available forms for service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setFormAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Description[] | undefined) => Types.Description[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function formUrl(formName: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/form/{formName}";
if (formName === undefined || formName === null)
  throw new Error("The parameter 'formName' must be defined.");
url_ = url_.replace("{formName}", encodeURIComponent("" + formName));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let formDefaultOptions: Omit<UseQueryOptions<Types.Description, unknown, Types.Description>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Description, unknown, Types.Description>, 'queryFn'>> = {
};
export function getFormDefaultOptions() {
  return formDefaultOptions;
};
export function setFormDefaultOptions(options: typeof formDefaultOptions) {
  formDefaultOptions = options;
}

export function formQueryKey(dto: FormQueryParameters): QueryKey;
export function formQueryKey(formName: string, serviceId: number): QueryKey;
export function formQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { formName, serviceId,  } = params[0] as FormQueryParameters;

    return trimArrayEnd([
        'Client',
        'form',
        formName as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'form',
        ...params
      ]);
  }
}
export function __form(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().form(
      context.queryKey[2] as string,       context.queryKey[3] as number);
}

export function useFormQuery<TSelectData = Types.Description, TError = unknown>(dto: FormQueryParameters, options?: Omit<UseQueryOptions<Types.Description, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get specified form description for service
 * @param formName Form name
 * @param serviceId Service ID
 * @return successful operation
 */
export function useFormQuery<TSelectData = Types.Description, TError = unknown>(formName: string, serviceId: number, options?: Omit<UseQueryOptions<Types.Description, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFormQuery<TSelectData = Types.Description, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Description, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let formName: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ formName, serviceId,  } = params[0] as FormQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [formName, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Description, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __form(context, axiosConfig) : __form,
    queryKey: formQueryKey(formName, serviceId),
    ...formDefaultOptions as unknown as Omit<UseQueryOptions<Types.Description, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get specified form description for service
 * @param formName Form name
 * @param serviceId Service ID
 * @return successful operation
 */
export function setFormData(queryClient: QueryClient, updater: (data: Types.Description | undefined) => Types.Description, formName: string, serviceId: number) {
  queryClient.setQueryData(formQueryKey(formName, serviceId),
    updater
  );
}

/**
 * Get specified form description for service
 * @param formName Form name
 * @param serviceId Service ID
 * @return successful operation
 */
export function setFormDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Description | undefined) => Types.Description) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function answerUrl(formName: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/form/{formName}/answer";
if (formName === undefined || formName === null)
  throw new Error("The parameter 'formName' must be defined.");
url_ = url_.replace("{formName}", encodeURIComponent("" + formName));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function answerMutationKey(formName: string, serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'answer',
      formName as any,
      serviceId as any,
    ]);
}

/**
 * Post answers to the form for your service
 * @param formName Form name
 * @param serviceId Service ID
 * @return successful operation
 */
export function useAnswerMutation<TContext>(formName: string, serviceId: number, options?: Omit<UseMutationOptions<Types.Response, unknown, Types.Form, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Response, unknown, Types.Form, TContext> {
  const key = answerMutationKey(formName, serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Form) => Client().answer(formName, serviceId, body),
    mutationKey: key,
  });
}
  
type Answer__MutationParameters = AnswerQueryParameters & {
  body: Types.Form;
}

/**
 * Post answers to the form for your service
 * @param formName Form name
 * @param serviceId Service ID
 * @return successful operation
 */
export function useAnswerMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Response, unknown, Answer__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AnswerQueryParameters}): UseMutationResult<Types.Response, unknown, Answer__MutationParameters, TContext> {
  const key = answerMutationKey(options?.parameters?.formName!, options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Answer__MutationParameters) => Client().answer(data.formName ?? options?.parameters?.formName!, data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function options2Url(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/options";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let options2DefaultOptions: Omit<UseQueryOptions<Types.Service2[], unknown, Types.Service2[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Service2[], unknown, Types.Service2[]>, 'queryFn'>> = {
};
export function getOptions2DefaultOptions() {
  return options2DefaultOptions;
};
export function setOptions2DefaultOptions(options: typeof options2DefaultOptions) {
  options2DefaultOptions = options;
}

export function options2QueryKey(serviceId: number): QueryKey;
export function options2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as Options2QueryParameters;

    return trimArrayEnd([
        'Client',
        'options2',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'options2',
        ...params
      ]);
  }
}
export function __options2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().options2(
      context.queryKey[2] as number);
}

export function useOptions2Query<TSelectData = Types.Service2[], TError = unknown>(dto: Options2QueryParameters, options?: Omit<UseQueryOptions<Types.Service2[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get options of a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useOptions2Query<TSelectData = Types.Service2[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.Service2[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useOptions2Query<TSelectData = Types.Service2[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Service2[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as Options2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Service2[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __options2(context, axiosConfig) : __options2,
    queryKey: options2QueryKey(serviceId),
    ...options2DefaultOptions as unknown as Omit<UseQueryOptions<Types.Service2[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get options of a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setOptions2Data(queryClient: QueryClient, updater: (data: Types.Service2[] | undefined) => Types.Service2[], serviceId: number) {
  queryClient.setQueryData(options2QueryKey(serviceId),
    updater
  );
}

/**
 * Get options of a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setOptions2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Service2[] | undefined) => Types.Service2[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function renewPeriodCapacitiesUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/renewPeriodCapacities";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let renewPeriodCapacitiesDefaultOptions: Omit<UseQueryOptions<string[], unknown, string[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string[], unknown, string[]>, 'queryFn'>> = {
};
export function getRenewPeriodCapacitiesDefaultOptions() {
  return renewPeriodCapacitiesDefaultOptions;
};
export function setRenewPeriodCapacitiesDefaultOptions(options: typeof renewPeriodCapacitiesDefaultOptions) {
  renewPeriodCapacitiesDefaultOptions = options;
}

export function renewPeriodCapacitiesQueryKey(serviceId: number): QueryKey;
export function renewPeriodCapacitiesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as RenewPeriodCapacitiesQueryParameters;

    return trimArrayEnd([
        'Client',
        'renewPeriodCapacities',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'renewPeriodCapacities',
        ...params
      ]);
  }
}
export function __renewPeriodCapacities(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().renewPeriodCapacities(
      context.queryKey[2] as number);
}

export function useRenewPeriodCapacitiesQuery<TSelectData = string[], TError = unknown>(dto: RenewPeriodCapacitiesQueryParameters, options?: Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get possible renew periods of a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useRenewPeriodCapacitiesQuery<TSelectData = string[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRenewPeriodCapacitiesQuery<TSelectData = string[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as RenewPeriodCapacitiesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __renewPeriodCapacities(context, axiosConfig) : __renewPeriodCapacities,
    queryKey: renewPeriodCapacitiesQueryKey(serviceId),
    ...renewPeriodCapacitiesDefaultOptions as unknown as Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get possible renew periods of a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setRenewPeriodCapacitiesData(queryClient: QueryClient, updater: (data: string[] | undefined) => string[], serviceId: number) {
  queryClient.setQueryData(renewPeriodCapacitiesQueryKey(serviceId),
    updater
  );
}

/**
 * Get possible renew periods of a service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setRenewPeriodCapacitiesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string[] | undefined) => string[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function contractsUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/contracts";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let contractsDefaultOptions: Omit<UseQueryOptions<Types.Contract[], unknown, Types.Contract[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Contract[], unknown, Types.Contract[]>, 'queryFn'>> = {
};
export function getContractsDefaultOptions() {
  return contractsDefaultOptions;
};
export function setContractsDefaultOptions(options: typeof contractsDefaultOptions) {
  contractsDefaultOptions = options;
}

export function contractsQueryKey(serviceId: number): QueryKey;
export function contractsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as ContractsQueryParameters;

    return trimArrayEnd([
        'Client',
        'contracts',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'contracts',
        ...params
      ]);
  }
}
export function __contracts(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().contracts(
      context.queryKey[2] as number);
}

export function useContractsQuery<TSelectData = Types.Contract[], TError = unknown>(dto: ContractsQueryParameters, options?: Omit<UseQueryOptions<Types.Contract[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List contracts automatically agreed when subscribing to savings plan for this project
 * @param serviceId Service ID
 * @return successful operation
 */
export function useContractsQuery<TSelectData = Types.Contract[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.Contract[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useContractsQuery<TSelectData = Types.Contract[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Contract[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as ContractsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Contract[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __contracts(context, axiosConfig) : __contracts,
    queryKey: contractsQueryKey(serviceId),
    ...contractsDefaultOptions as unknown as Omit<UseQueryOptions<Types.Contract[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List contracts automatically agreed when subscribing to savings plan for this project
 * @param serviceId Service ID
 * @return successful operation
 */
export function setContractsData(queryClient: QueryClient, updater: (data: Types.Contract[] | undefined) => Types.Contract[], serviceId: number) {
  queryClient.setQueryData(contractsQueryKey(serviceId),
    updater
  );
}

/**
 * List contracts automatically agreed when subscribing to savings plan for this project
 * @param serviceId Service ID
 * @return successful operation
 */
export function setContractsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Contract[] | undefined) => Types.Contract[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function subscribableUrl(serviceId: number, productCode: string | undefined): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribable?";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
if (productCode === null)
    throw new Error("The parameter 'productCode' cannot be null.");
else if (productCode !== undefined)
    url_ += "productCode=" + encodeURIComponent("" + productCode) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let subscribableDefaultOptions: Omit<UseQueryOptions<Types.SubscribableSavingsPlanOffer[], unknown, Types.SubscribableSavingsPlanOffer[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SubscribableSavingsPlanOffer[], unknown, Types.SubscribableSavingsPlanOffer[]>, 'queryFn'>> = {
};
export function getSubscribableDefaultOptions() {
  return subscribableDefaultOptions;
};
export function setSubscribableDefaultOptions(options: typeof subscribableDefaultOptions) {
  subscribableDefaultOptions = options;
}

export function subscribableQueryKey(dto: SubscribableQueryParameters): QueryKey;
export function subscribableQueryKey(productCode: string | undefined, serviceId: number): QueryKey;
export function subscribableQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { productCode, serviceId,  } = params[0] as SubscribableQueryParameters;

    return trimArrayEnd([
        'Client',
        'subscribable',
        productCode as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'subscribable',
        ...params
      ]);
  }
}
export function __subscribable(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().subscribable(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number);
}

export function useSubscribableQuery<TSelectData = Types.SubscribableSavingsPlanOffer[], TError = unknown>(dto: SubscribableQueryParameters, options?: Omit<UseQueryOptions<Types.SubscribableSavingsPlanOffer[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List subscribable Savings Plan commercial offers for a given Subscription
 * @param productCode (optional) Filter offers by product code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSubscribableQuery<TSelectData = Types.SubscribableSavingsPlanOffer[], TError = unknown>(productCode: string | undefined, serviceId: number, options?: Omit<UseQueryOptions<Types.SubscribableSavingsPlanOffer[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSubscribableQuery<TSelectData = Types.SubscribableSavingsPlanOffer[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SubscribableSavingsPlanOffer[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let productCode: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ productCode, serviceId,  } = params[0] as SubscribableQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [productCode, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SubscribableSavingsPlanOffer[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __subscribable(context, axiosConfig) : __subscribable,
    queryKey: subscribableQueryKey(productCode, serviceId),
    ...subscribableDefaultOptions as unknown as Omit<UseQueryOptions<Types.SubscribableSavingsPlanOffer[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List subscribable Savings Plan commercial offers for a given Subscription
 * @param productCode (optional) Filter offers by product code
 * @param serviceId Service ID
 * @return successful operation
 */
export function setSubscribableData(queryClient: QueryClient, updater: (data: Types.SubscribableSavingsPlanOffer[] | undefined) => Types.SubscribableSavingsPlanOffer[], productCode: string | undefined, serviceId: number) {
  queryClient.setQueryData(subscribableQueryKey(productCode, serviceId),
    updater
  );
}

/**
 * List subscribable Savings Plan commercial offers for a given Subscription
 * @param productCode (optional) Filter offers by product code
 * @param serviceId Service ID
 * @return successful operation
 */
export function setSubscribableDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SubscribableSavingsPlanOffer[] | undefined) => Types.SubscribableSavingsPlanOffer[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function execute2Url(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribe/execute";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function execute2MutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'execute2',
      serviceId as any,
    ]);
}

/**
 * Subscribe to a Savings Plan, applicable contracts will be automatically agreed to.
 * @param serviceId Service ID
 * @return successful operation
 */
export function useExecute2Mutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<Types.SavingsPlan, unknown, Types.Subscribe, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SavingsPlan, unknown, Types.Subscribe, TContext> {
  const key = execute2MutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Subscribe) => Client().execute2(serviceId, body),
    mutationKey: key,
  });
}
  
type Execute2__MutationParameters = Execute2QueryParameters & {
  body: Types.Subscribe;
}

/**
 * Subscribe to a Savings Plan, applicable contracts will be automatically agreed to.
 * @param serviceId Service ID
 * @return successful operation
 */
export function useExecute2MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SavingsPlan, unknown, Execute2__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: Execute2QueryParameters}): UseMutationResult<Types.SavingsPlan, unknown, Execute2__MutationParameters, TContext> {
  const key = execute2MutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Execute2__MutationParameters) => Client().execute2(data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function simulate2Url(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribe/simulate";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function simulate2MutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'simulate2',
      serviceId as any,
    ]);
}

/**
 * Simulate a Subscription to a Savings Plan
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSimulate2Mutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<Types.SimulatedSavingsPlan, unknown, Types.Subscribe, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SimulatedSavingsPlan, unknown, Types.Subscribe, TContext> {
  const key = simulate2MutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Subscribe) => Client().simulate2(serviceId, body),
    mutationKey: key,
  });
}
  
type Simulate2__MutationParameters = Simulate2QueryParameters & {
  body: Types.Subscribe;
}

/**
 * Simulate a Subscription to a Savings Plan
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSimulate2MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SimulatedSavingsPlan, unknown, Simulate2__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: Simulate2QueryParameters}): UseMutationResult<Types.SimulatedSavingsPlan, unknown, Simulate2__MutationParameters, TContext> {
  const key = simulate2MutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Simulate2__MutationParameters) => Client().simulate2(data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function subscribedAllUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribed";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let subscribedAllDefaultOptions: Omit<UseQueryOptions<Types.SavingsPlan[], unknown, Types.SavingsPlan[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SavingsPlan[], unknown, Types.SavingsPlan[]>, 'queryFn'>> = {
};
export function getSubscribedAllDefaultOptions() {
  return subscribedAllDefaultOptions;
};
export function setSubscribedAllDefaultOptions(options: typeof subscribedAllDefaultOptions) {
  subscribedAllDefaultOptions = options;
}

export function subscribedAllQueryKey(serviceId: number): QueryKey;
export function subscribedAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as SubscribedAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'subscribedAll',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'subscribedAll',
        ...params
      ]);
  }
}
export function __subscribedAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().subscribedAll(
      context.queryKey[2] as number);
}

export function useSubscribedAllQuery<TSelectData = Types.SavingsPlan[], TError = unknown>(dto: SubscribedAllQueryParameters, options?: Omit<UseQueryOptions<Types.SavingsPlan[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List subscribed Savings Plans
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSubscribedAllQuery<TSelectData = Types.SavingsPlan[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.SavingsPlan[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSubscribedAllQuery<TSelectData = Types.SavingsPlan[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SavingsPlan[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as SubscribedAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SavingsPlan[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __subscribedAll(context, axiosConfig) : __subscribedAll,
    queryKey: subscribedAllQueryKey(serviceId),
    ...subscribedAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.SavingsPlan[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List subscribed Savings Plans
 * @param serviceId Service ID
 * @return successful operation
 */
export function setSubscribedAllData(queryClient: QueryClient, updater: (data: Types.SavingsPlan[] | undefined) => Types.SavingsPlan[], serviceId: number) {
  queryClient.setQueryData(subscribedAllQueryKey(serviceId),
    updater
  );
}

/**
 * List subscribed Savings Plans
 * @param serviceId Service ID
 * @return successful operation
 */
export function setSubscribedAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SavingsPlan[] | undefined) => Types.SavingsPlan[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function subscribedGETUrl(savingsPlanId: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}";
if (savingsPlanId === undefined || savingsPlanId === null)
  throw new Error("The parameter 'savingsPlanId' must be defined.");
url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let subscribedGETDefaultOptions: Omit<UseQueryOptions<Types.SavingsPlan, unknown, Types.SavingsPlan>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SavingsPlan, unknown, Types.SavingsPlan>, 'queryFn'>> = {
};
export function getSubscribedGETDefaultOptions() {
  return subscribedGETDefaultOptions;
};
export function setSubscribedGETDefaultOptions(options: typeof subscribedGETDefaultOptions) {
  subscribedGETDefaultOptions = options;
}

export function subscribedGETQueryKey(dto: SubscribedGETQueryParameters): QueryKey;
export function subscribedGETQueryKey(savingsPlanId: string, serviceId: number): QueryKey;
export function subscribedGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { savingsPlanId, serviceId,  } = params[0] as SubscribedGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'subscribedGET',
        savingsPlanId as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'subscribedGET',
        ...params
      ]);
  }
}
export function __subscribedGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().subscribedGET(
      context.queryKey[2] as string,       context.queryKey[3] as number);
}

export function useSubscribedGETQuery<TSelectData = Types.SavingsPlan, TError = unknown>(dto: SubscribedGETQueryParameters, options?: Omit<UseQueryOptions<Types.SavingsPlan, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Fetch a subscribed Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSubscribedGETQuery<TSelectData = Types.SavingsPlan, TError = unknown>(savingsPlanId: string, serviceId: number, options?: Omit<UseQueryOptions<Types.SavingsPlan, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSubscribedGETQuery<TSelectData = Types.SavingsPlan, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SavingsPlan, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let savingsPlanId: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ savingsPlanId, serviceId,  } = params[0] as SubscribedGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [savingsPlanId, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SavingsPlan, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __subscribedGET(context, axiosConfig) : __subscribedGET,
    queryKey: subscribedGETQueryKey(savingsPlanId, serviceId),
    ...subscribedGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.SavingsPlan, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Fetch a subscribed Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function setSubscribedGETData(queryClient: QueryClient, updater: (data: Types.SavingsPlan | undefined) => Types.SavingsPlan, savingsPlanId: string, serviceId: number) {
  queryClient.setQueryData(subscribedGETQueryKey(savingsPlanId, serviceId),
    updater
  );
}

/**
 * Fetch a subscribed Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function setSubscribedGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SavingsPlan | undefined) => Types.SavingsPlan) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function subscribedPUTUrl(savingsPlanId: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}";
if (savingsPlanId === undefined || savingsPlanId === null)
  throw new Error("The parameter 'savingsPlanId' must be defined.");
url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function subscribedPUTMutationKey(savingsPlanId: string, serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'subscribedPUT',
      savingsPlanId as any,
      serviceId as any,
    ]);
}

/**
 * Update a subscribed Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSubscribedPUTMutation<TContext>(savingsPlanId: string, serviceId: number, options?: Omit<UseMutationOptions<Types.SavingsPlan, unknown, Types.SavingsPlan, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SavingsPlan, unknown, Types.SavingsPlan, TContext> {
  const key = subscribedPUTMutationKey(savingsPlanId, serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SavingsPlan) => Client().subscribedPUT(savingsPlanId, serviceId, body),
    mutationKey: key,
  });
}
  
type SubscribedPUT__MutationParameters = SubscribedPUTQueryParameters & {
  body: Types.SavingsPlan;
}

/**
 * Update a subscribed Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSubscribedPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SavingsPlan, unknown, SubscribedPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SubscribedPUTQueryParameters}): UseMutationResult<Types.SavingsPlan, unknown, SubscribedPUT__MutationParameters, TContext> {
  const key = subscribedPUTMutationKey(options?.parameters?.savingsPlanId!, options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SubscribedPUT__MutationParameters) => Client().subscribedPUT(data.savingsPlanId ?? options?.parameters?.savingsPlanId!, data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function changePeriodEndActionUrl(savingsPlanId: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}/changePeriodEndAction";
if (savingsPlanId === undefined || savingsPlanId === null)
  throw new Error("The parameter 'savingsPlanId' must be defined.");
url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function changePeriodEndActionMutationKey(savingsPlanId: string, serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'changePeriodEndAction',
      savingsPlanId as any,
      serviceId as any,
    ]);
}

/**
 * Change the action occurring at the end of the Savings Plan period
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function useChangePeriodEndActionMutation<TContext>(savingsPlanId: string, serviceId: number, options?: Omit<UseMutationOptions<Types.SavingsPlan, unknown, Types.ChangePeriodEndAction, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SavingsPlan, unknown, Types.ChangePeriodEndAction, TContext> {
  const key = changePeriodEndActionMutationKey(savingsPlanId, serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ChangePeriodEndAction) => Client().changePeriodEndAction(savingsPlanId, serviceId, body),
    mutationKey: key,
  });
}
  
type ChangePeriodEndAction__MutationParameters = ChangePeriodEndActionQueryParameters & {
  body: Types.ChangePeriodEndAction;
}

/**
 * Change the action occurring at the end of the Savings Plan period
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function useChangePeriodEndActionMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SavingsPlan, unknown, ChangePeriodEndAction__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ChangePeriodEndActionQueryParameters}): UseMutationResult<Types.SavingsPlan, unknown, ChangePeriodEndAction__MutationParameters, TContext> {
  const key = changePeriodEndActionMutationKey(options?.parameters?.savingsPlanId!, options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ChangePeriodEndAction__MutationParameters) => Client().changePeriodEndAction(data.savingsPlanId ?? options?.parameters?.savingsPlanId!, data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function changeSizeUrl(savingsPlanId: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}/changeSize";
if (savingsPlanId === undefined || savingsPlanId === null)
  throw new Error("The parameter 'savingsPlanId' must be defined.");
url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function changeSizeMutationKey(savingsPlanId: string, serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'changeSize',
      savingsPlanId as any,
      serviceId as any,
    ]);
}

/**
 * Resize the Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function useChangeSizeMutation<TContext>(savingsPlanId: string, serviceId: number, options?: Omit<UseMutationOptions<Types.SavingsPlan, unknown, Types.ChangeSize, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SavingsPlan, unknown, Types.ChangeSize, TContext> {
  const key = changeSizeMutationKey(savingsPlanId, serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ChangeSize) => Client().changeSize(savingsPlanId, serviceId, body),
    mutationKey: key,
  });
}
  
type ChangeSize__MutationParameters = ChangeSizeQueryParameters & {
  body: Types.ChangeSize;
}

/**
 * Resize the Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function useChangeSizeMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SavingsPlan, unknown, ChangeSize__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ChangeSizeQueryParameters}): UseMutationResult<Types.SavingsPlan, unknown, ChangeSize__MutationParameters, TContext> {
  const key = changeSizeMutationKey(options?.parameters?.savingsPlanId!, options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ChangeSize__MutationParameters) => Client().changeSize(data.savingsPlanId ?? options?.parameters?.savingsPlanId!, data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function periodsUrl(savingsPlanId: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/savingsPlans/subscribed/{savingsPlanId}/periods";
if (savingsPlanId === undefined || savingsPlanId === null)
  throw new Error("The parameter 'savingsPlanId' must be defined.");
url_ = url_.replace("{savingsPlanId}", encodeURIComponent("" + savingsPlanId));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let periodsDefaultOptions: Omit<UseQueryOptions<Types.Period[], unknown, Types.Period[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Period[], unknown, Types.Period[]>, 'queryFn'>> = {
};
export function getPeriodsDefaultOptions() {
  return periodsDefaultOptions;
};
export function setPeriodsDefaultOptions(options: typeof periodsDefaultOptions) {
  periodsDefaultOptions = options;
}

export function periodsQueryKey(dto: PeriodsQueryParameters): QueryKey;
export function periodsQueryKey(savingsPlanId: string, serviceId: number): QueryKey;
export function periodsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { savingsPlanId, serviceId,  } = params[0] as PeriodsQueryParameters;

    return trimArrayEnd([
        'Client',
        'periods',
        savingsPlanId as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'periods',
        ...params
      ]);
  }
}
export function __periods(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().periods(
      context.queryKey[2] as string,       context.queryKey[3] as number);
}

export function usePeriodsQuery<TSelectData = Types.Period[], TError = unknown>(dto: PeriodsQueryParameters, options?: Omit<UseQueryOptions<Types.Period[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List the period history of a given Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function usePeriodsQuery<TSelectData = Types.Period[], TError = unknown>(savingsPlanId: string, serviceId: number, options?: Omit<UseQueryOptions<Types.Period[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePeriodsQuery<TSelectData = Types.Period[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Period[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let savingsPlanId: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ savingsPlanId, serviceId,  } = params[0] as PeriodsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [savingsPlanId, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Period[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __periods(context, axiosConfig) : __periods,
    queryKey: periodsQueryKey(savingsPlanId, serviceId),
    ...periodsDefaultOptions as unknown as Omit<UseQueryOptions<Types.Period[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List the period history of a given Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function setPeriodsData(queryClient: QueryClient, updater: (data: Types.Period[] | undefined) => Types.Period[], savingsPlanId: string, serviceId: number) {
  queryClient.setQueryData(periodsQueryKey(savingsPlanId, serviceId),
    updater
  );
}

/**
 * List the period history of a given Savings Plan
 * @param savingsPlanId Savings plan ID
 * @param serviceId Service ID
 * @return successful operation
 */
export function setPeriodsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Period[] | undefined) => Types.Period[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function technicalDetailsUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/technicalDetails";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let technicalDetailsDefaultOptions: Omit<UseQueryOptions<Types.TechnicalDetails, unknown, Types.TechnicalDetails>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.TechnicalDetails, unknown, Types.TechnicalDetails>, 'queryFn'>> = {
};
export function getTechnicalDetailsDefaultOptions() {
  return technicalDetailsDefaultOptions;
};
export function setTechnicalDetailsDefaultOptions(options: typeof technicalDetailsDefaultOptions) {
  technicalDetailsDefaultOptions = options;
}

export function technicalDetailsQueryKey(serviceId: number): QueryKey;
export function technicalDetailsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as TechnicalDetailsQueryParameters;

    return trimArrayEnd([
        'Client',
        'technicalDetails',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'technicalDetails',
        ...params
      ]);
  }
}
export function __technicalDetails(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().technicalDetails(
      context.queryKey[2] as number);
}

export function useTechnicalDetailsQuery<TSelectData = Types.TechnicalDetails, TError = unknown>(dto: TechnicalDetailsQueryParameters, options?: Omit<UseQueryOptions<Types.TechnicalDetails, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * View the technical details of the service
 * @param serviceId Service ID
 * @return successful operation
 */
export function useTechnicalDetailsQuery<TSelectData = Types.TechnicalDetails, TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.TechnicalDetails, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTechnicalDetailsQuery<TSelectData = Types.TechnicalDetails, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.TechnicalDetails, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as TechnicalDetailsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.TechnicalDetails, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __technicalDetails(context, axiosConfig) : __technicalDetails,
    queryKey: technicalDetailsQueryKey(serviceId),
    ...technicalDetailsDefaultOptions as unknown as Omit<UseQueryOptions<Types.TechnicalDetails, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * View the technical details of the service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setTechnicalDetailsData(queryClient: QueryClient, updater: (data: Types.TechnicalDetails | undefined) => Types.TechnicalDetails, serviceId: number) {
  queryClient.setQueryData(technicalDetailsQueryKey(serviceId),
    updater
  );
}

/**
 * View the technical details of the service
 * @param serviceId Service ID
 * @return successful operation
 */
export function setTechnicalDetailsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.TechnicalDetails | undefined) => Types.TechnicalDetails) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function terminateUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/terminate";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function terminateMutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'terminate',
      serviceId as any,
    ]);
}

/**
 * Request service termination
 * @param serviceId Service ID
 * @return successful operation
 */
export function useTerminateMutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<Types.TerminationAnswer, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.TerminationAnswer, unknown, void, TContext> {
  const key = terminateMutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().terminate(serviceId),
    mutationKey: key,
  });
}
  
type Terminate__MutationParameters = TerminateQueryParameters

/**
 * Request service termination
 * @param serviceId Service ID
 * @return successful operation
 */
export function useTerminateMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.TerminationAnswer, unknown, Terminate__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: TerminateQueryParameters}): UseMutationResult<Types.TerminationAnswer, unknown, Terminate__MutationParameters, TContext> {
  const key = terminateMutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Terminate__MutationParameters) => Client().terminate(data.serviceId ?? options?.parameters?.serviceId!),
  mutationKey: key,
});
}
  
export function confirmUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/terminate/confirm";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function confirmMutationKey(serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'confirm',
      serviceId as any,
    ]);
}

/**
 * Confirm service termination
 * @param serviceId Service ID
 * @return successful operation
 */
export function useConfirmMutation<TContext>(serviceId: number, options?: Omit<UseMutationOptions<Types.TerminationAnswer, unknown, Types.ConfirmServiceTerminationRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.TerminationAnswer, unknown, Types.ConfirmServiceTerminationRequest, TContext> {
  const key = confirmMutationKey(serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ConfirmServiceTerminationRequest) => Client().confirm(serviceId, body),
    mutationKey: key,
  });
}
  
type Confirm__MutationParameters = ConfirmQueryParameters & {
  body: Types.ConfirmServiceTerminationRequest;
}

/**
 * Confirm service termination
 * @param serviceId Service ID
 * @return successful operation
 */
export function useConfirmMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.TerminationAnswer, unknown, Confirm__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ConfirmQueryParameters}): UseMutationResult<Types.TerminationAnswer, unknown, Confirm__MutationParameters, TContext> {
  const key = confirmMutationKey(options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Confirm__MutationParameters) => Client().confirm(data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function upgradeAllUrl(serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/upgrade";
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let upgradeAllDefaultOptions: Omit<UseQueryOptions<Types.GenericProductDefinition[], unknown, Types.GenericProductDefinition[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.GenericProductDefinition[], unknown, Types.GenericProductDefinition[]>, 'queryFn'>> = {
};
export function getUpgradeAllDefaultOptions() {
  return upgradeAllDefaultOptions;
};
export function setUpgradeAllDefaultOptions(options: typeof upgradeAllDefaultOptions) {
  upgradeAllDefaultOptions = options;
}

export function upgradeAllQueryKey(serviceId: number): QueryKey;
export function upgradeAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { serviceId,  } = params[0] as UpgradeAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'upgradeAll',
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'upgradeAll',
        ...params
      ]);
  }
}
export function __upgradeAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().upgradeAll(
      context.queryKey[2] as number);
}

export function useUpgradeAllQuery<TSelectData = Types.GenericProductDefinition[], TError = unknown>(dto: UpgradeAllQueryParameters, options?: Omit<UseQueryOptions<Types.GenericProductDefinition[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * List offers this option can be converted to
 * @param serviceId Service ID
 * @return successful operation
 */
export function useUpgradeAllQuery<TSelectData = Types.GenericProductDefinition[], TError = unknown>(serviceId: number, options?: Omit<UseQueryOptions<Types.GenericProductDefinition[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUpgradeAllQuery<TSelectData = Types.GenericProductDefinition[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GenericProductDefinition[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ serviceId,  } = params[0] as UpgradeAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.GenericProductDefinition[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __upgradeAll(context, axiosConfig) : __upgradeAll,
    queryKey: upgradeAllQueryKey(serviceId),
    ...upgradeAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.GenericProductDefinition[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * List offers this option can be converted to
 * @param serviceId Service ID
 * @return successful operation
 */
export function setUpgradeAllData(queryClient: QueryClient, updater: (data: Types.GenericProductDefinition[] | undefined) => Types.GenericProductDefinition[], serviceId: number) {
  queryClient.setQueryData(upgradeAllQueryKey(serviceId),
    updater
  );
}

/**
 * List offers this option can be converted to
 * @param serviceId Service ID
 * @return successful operation
 */
export function setUpgradeAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GenericProductDefinition[] | undefined) => Types.GenericProductDefinition[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function upgradeUrl(planCode: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/upgrade/{planCode}";
if (planCode === undefined || planCode === null)
  throw new Error("The parameter 'planCode' must be defined.");
url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let upgradeDefaultOptions: Omit<UseQueryOptions<Types.GenericProductDefinition, unknown, Types.GenericProductDefinition>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.GenericProductDefinition, unknown, Types.GenericProductDefinition>, 'queryFn'>> = {
};
export function getUpgradeDefaultOptions() {
  return upgradeDefaultOptions;
};
export function setUpgradeDefaultOptions(options: typeof upgradeDefaultOptions) {
  upgradeDefaultOptions = options;
}

export function upgradeQueryKey(dto: UpgradeQueryParameters): QueryKey;
export function upgradeQueryKey(planCode: string, serviceId: number): QueryKey;
export function upgradeQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { planCode, serviceId,  } = params[0] as UpgradeQueryParameters;

    return trimArrayEnd([
        'Client',
        'upgrade',
        planCode as any,
        serviceId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'upgrade',
        ...params
      ]);
  }
}
export function __upgrade(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().upgrade(
      context.queryKey[2] as string,       context.queryKey[3] as number);
}

export function useUpgradeQuery<TSelectData = Types.GenericProductDefinition, TError = unknown>(dto: UpgradeQueryParameters, options?: Omit<UseQueryOptions<Types.GenericProductDefinition, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * View an offer this option can be converted to
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useUpgradeQuery<TSelectData = Types.GenericProductDefinition, TError = unknown>(planCode: string, serviceId: number, options?: Omit<UseQueryOptions<Types.GenericProductDefinition, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUpgradeQuery<TSelectData = Types.GenericProductDefinition, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GenericProductDefinition, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let planCode: any = undefined;
  let serviceId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ planCode, serviceId,  } = params[0] as UpgradeQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [planCode, serviceId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.GenericProductDefinition, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __upgrade(context, axiosConfig) : __upgrade,
    queryKey: upgradeQueryKey(planCode, serviceId),
    ...upgradeDefaultOptions as unknown as Omit<UseQueryOptions<Types.GenericProductDefinition, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * View an offer this option can be converted to
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function setUpgradeData(queryClient: QueryClient, updater: (data: Types.GenericProductDefinition | undefined) => Types.GenericProductDefinition, planCode: string, serviceId: number) {
  queryClient.setQueryData(upgradeQueryKey(planCode, serviceId),
    updater
  );
}

/**
 * View an offer this option can be converted to
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function setUpgradeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GenericProductDefinition | undefined) => Types.GenericProductDefinition) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function execute3Url(planCode: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/upgrade/{planCode}/execute";
if (planCode === undefined || planCode === null)
  throw new Error("The parameter 'planCode' must be defined.");
url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function execute3MutationKey(planCode: string, serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'execute3',
      planCode as any,
      serviceId as any,
    ]);
}

/**
 * Perform the migration to another offer. May require you to pay an Order
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useExecute3Mutation<TContext>(planCode: string, serviceId: number, options?: Omit<UseMutationOptions<Types.Order2, unknown, Types.ExecutionRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Order2, unknown, Types.ExecutionRequest, TContext> {
  const key = execute3MutationKey(planCode, serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ExecutionRequest) => Client().execute3(planCode, serviceId, body),
    mutationKey: key,
  });
}
  
type Execute3__MutationParameters = Execute3QueryParameters & {
  body: Types.ExecutionRequest;
}

/**
 * Perform the migration to another offer. May require you to pay an Order
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useExecute3MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Order2, unknown, Execute3__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: Execute3QueryParameters}): UseMutationResult<Types.Order2, unknown, Execute3__MutationParameters, TContext> {
  const key = execute3MutationKey(options?.parameters?.planCode!, options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Execute3__MutationParameters) => Client().execute3(data.planCode ?? options?.parameters?.planCode!, data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}
  
export function simulate3Url(planCode: string, serviceId: number): string {
  let url_ = getBaseUrl() + "/services/{serviceId}/upgrade/{planCode}/simulate";
if (planCode === undefined || planCode === null)
  throw new Error("The parameter 'planCode' must be defined.");
url_ = url_.replace("{planCode}", encodeURIComponent("" + planCode));
if (serviceId === undefined || serviceId === null)
  throw new Error("The parameter 'serviceId' must be defined.");
url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function simulate3MutationKey(planCode: string, serviceId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'simulate3',
      planCode as any,
      serviceId as any,
    ]);
}

/**
 * Simulate the conversion to another offer
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSimulate3Mutation<TContext>(planCode: string, serviceId: number, options?: Omit<UseMutationOptions<Types.Order2, unknown, Types.ExecutionRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Order2, unknown, Types.ExecutionRequest, TContext> {
  const key = simulate3MutationKey(planCode, serviceId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ExecutionRequest) => Client().simulate3(planCode, serviceId, body),
    mutationKey: key,
  });
}
  
type Simulate3__MutationParameters = Simulate3QueryParameters & {
  body: Types.ExecutionRequest;
}

/**
 * Simulate the conversion to another offer
 * @param planCode Plan code
 * @param serviceId Service ID
 * @return successful operation
 */
export function useSimulate3MutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.Order2, unknown, Simulate3__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: Simulate3QueryParameters}): UseMutationResult<Types.Order2, unknown, Simulate3__MutationParameters, TContext> {
  const key = simulate3MutationKey(options?.parameters?.planCode!, options?.parameters?.serviceId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Simulate3__MutationParameters) => Client().simulate3(data.planCode ?? options?.parameters?.planCode!, data.serviceId ?? options?.parameters?.serviceId!, data.body),
  mutationKey: key,
});
}