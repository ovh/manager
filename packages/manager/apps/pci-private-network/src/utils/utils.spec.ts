import {
  getAutoGeneratedName,
  getDefaultCIDR,
  getNextAvailableVlanId,
  getLocalZoneRegions,
  groupedPrivateNetworkByVlanId,
  paginateResults,
} from './utils';
import { regions, globalRegions } from '@/__mocks__/regions';
import { localZoneNetworks, networks } from '@/__mocks__/network';

describe('getAutoGeneratedName', () => {
  it('should return auto generated name with prefix', () => {
    const result = getAutoGeneratedName('prefix');
    expect(result).toMatch(/^prefix-\d+-.{5}$/);
  });

  it('should return auto generated name without prefix', () => {
    const result = getAutoGeneratedName();
    expect(result).toMatch(/^\d+-.{5}$/);
  });
});

describe('getNextAvailableVlanId', () => {
  it.each([
    { allocatedIds: [1, 2, 100], expected: 3 },
    { allocatedIds: [1, 2, 3, 4, 1100], expected: 5 },
    { allocatedIds: [], expected: 1 },
  ])(
    'should return $expected from possible VLAN ID values when $allocatedIds are allocated ',
    ({ allocatedIds, expected }) => {
      expect(getNextAvailableVlanId(allocatedIds)).toBe(expected);
    },
  );
});

describe('getDefaultCIDR', () => {
  it.each([
    [256, '10.1.0.0/16'],
    [511, '10.1.0.0/16'],
    [15, '10.15.0.0/16'],
    [255, '10.0.0.0/16'],
    [0, '10.0.0.0/16'],
  ])(
    'replaces {vlanId} in DEFAULT_CIDR correctly for vlanId %i modulo 255',
    (vlanId, expected) => {
      expect(getDefaultCIDR(vlanId)).toBe(expected);
    },
  );
});

describe('getLocalZoneRegions', () => {
  it('should return local zone regions', () => {
    const result = getLocalZoneRegions(regions);

    expect(result).toEqual([
      { name: 'region1', type: 'localzone' },
      { name: 'region3', type: 'localzone' },
    ]);
  });

  it('should return empty array if no local zone regions', () => {
    const result = getLocalZoneRegions(globalRegions);
    expect(result).toEqual([]);
  });
});

describe('groupPrivateNetworkByVlanId', () => {
  it('should return empty array when networks have not vlanId', () => {
    const result = groupedPrivateNetworkByVlanId(localZoneNetworks);

    expect(result).toEqual([]);
  });

  it('should grouped by vlanId', () => {
    const result = groupedPrivateNetworkByVlanId(networks);

    expect(result).toEqual([
      {
        vlanId: 1,
        name: 'net3',
        regions: ['region3'],
        search: '1 net3 region3',
      },
      {
        vlanId: 34,
        name: 'net1',
        regions: ['region1', 'region2', 'region5', 'region6'],
        search: '34 net1 region1 region2 region5 region6',
      },
    ]);
  });
});

describe('paginateResults', () => {
  it('should return paginated results', () => {
    const items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const pagination = { pageIndex: 1, pageSize: 3 };
    const result = paginateResults(items, pagination);
    expect(result).toEqual({
      rows: [4, 5, 6],
      pageCount: 4,
      totalRows: 10,
    });
  });

  it('should return empty rows if no items', () => {
    const items = [];
    const pagination = { pageIndex: 1, pageSize: 3 };
    const result = paginateResults(items, pagination);
    expect(result).toEqual({
      rows: [],
      pageCount: 0,
      totalRows: 0,
    });
  });
});
