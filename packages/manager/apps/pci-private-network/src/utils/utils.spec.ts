import { TRegion } from '@ovh-ux/manager-pci-common';
import {
  getAutoGeneratedName,
  getNextAvailableVlanId,
  getLocalZoneRegions,
  groupedPrivateNetworkByVlanId,
  paginateResults,
} from './utils';
import { NetworkVisibility } from '@/types/network.type';

describe('getAutoGeneratedName', () => {
  it('should return auto generated name with prefix', () => {
    const result = getAutoGeneratedName('prefix');
    expect(result).toMatch(/^prefix-\d+-\d+$/);
  });

  it('should return auto generated name without prefix', () => {
    const result = getAutoGeneratedName();
    expect(result).toMatch(/^\d+-\d+$/);
  });
});

describe('getNextAvailableVlanId', () => {
  it.each([
    { allocatedIds: [1, 2, 100], expected: 3 },
    { allocatedIds: [1, 2, 3, 4, 1100], expected: 5 },
    { allocatedIds: [], expected: 1 },
  ])(
    'should return $expected from possible VLAN ID values when $allocatedIds are allocated ',
    ({ allocatedIds, expected }) => {
      expect(getNextAvailableVlanId(allocatedIds)).toBe(expected);
    },
  );
});

describe('getLocalZoneRegions', () => {
  it('should return local zone regions', () => {
    const regions = [
      { name: 'region1', type: 'localzone' },
      { name: 'region2', type: 'region' },
      { name: 'region3', type: 'localzone' },
    ] as TRegion[];
    const result = getLocalZoneRegions(regions);

    expect(result).toEqual([
      { name: 'region1', type: 'localzone' },
      { name: 'region3', type: 'localzone' },
    ]);
  });

  it('should return empty array if no local zone regions', () => {
    const regions = [
      { name: 'region1', type: 'region' },
      { name: 'region2', type: 'region' },
    ] as TRegion[];
    const result = getLocalZoneRegions(regions);
    expect(result).toEqual([]);
  });
});

describe('groupPrivateNetworkByVlanId', () => {
  it('should return empty array when networks have not vlanId', () => {
    const networks = [
      {
        id: 'net1',
        name: 'net1',
        region: 'region1',
        vlanId: null,
        visibility: NetworkVisibility.Private,
      },
      {
        id: 'net2',
        name: 'net2',
        region: 'region2',
        vlanId: null,
        visibility: NetworkVisibility.Private,
      },
    ];

    const result = groupedPrivateNetworkByVlanId(networks);

    expect(result).toEqual([]);
  });

  it('should grouped by vlanId', () => {
    const networks = [
      {
        id: 'net1',
        name: 'net1',
        region: 'region1',
        vlanId: 34,
        visibility: NetworkVisibility.Private,
      },
      {
        id: 'net2',
        name: 'net2',
        region: 'region2',
        vlanId: 34,
        visibility: NetworkVisibility.Private,
      },
      {
        id: 'net3',
        name: 'net3',
        region: 'region3',
        vlanId: 1,
        visibility: NetworkVisibility.Private,
      },
      {
        id: 'net4',
        name: 'net4',
        region: 'region4',
        vlanId: null,
        visibility: NetworkVisibility.Private,
      },
      {
        id: 'net5',
        name: 'net5',
        region: 'region5',
        vlanId: 34,
        visibility: NetworkVisibility.Private,
      },
      {
        id: 'net6',
        name: 'net6',
        region: 'region6',
        vlanId: 34,
        visibility: NetworkVisibility.Private,
      },
    ];

    const result = groupedPrivateNetworkByVlanId(networks);

    expect(result).toEqual([
      {
        vlanId: 1,
        name: 'net3',
        regions: ['region3'],
        search: '1 net3 region3',
      },
      {
        vlanId: 34,
        name: 'net1',
        regions: ['region1', 'region2', 'region5', 'region6'],
        search: '34 net1 region1 region2 region5 region6',
      },
    ]);
  });
});

describe('paginateResults', () => {
  it('should return paginated results', () => {
    const items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const pagination = { pageIndex: 1, pageSize: 3 };
    const result = paginateResults(items, pagination);
    expect(result).toEqual({
      rows: [4, 5, 6],
      pageCount: 4,
      totalRows: 10,
    });
  });

  it('should return empty rows if no items', () => {
    const items = [];
    const pagination = { pageIndex: 1, pageSize: 3 };
    const result = paginateResults(items, pagination);
    expect(result).toEqual({
      rows: [],
      pageCount: 0,
      totalRows: 0,
    });
  });
});
