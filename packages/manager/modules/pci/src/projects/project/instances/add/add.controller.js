import find from 'lodash/find';
import filter from 'lodash/filter';
import get from 'lodash/get';
import includes from 'lodash/includes';
import isEmpty from 'lodash/isEmpty';
import map from 'lodash/map';
import has from 'lodash/has';
import some from 'lodash/some';
import sortBy from 'lodash/sortBy';

import Quota from '../../../../components/project/instance/quota/quota.class';
import { PATTERN } from '../../../../components/project/instance/name/constants';
import Instance from '../../../../components/project/instance/instance.class';
import { getAutoGeneratedName } from '../../../../components/auto-generate-name/auto-generate-name';
import {
  DEFAULT_CIDR,
  DEFAULT_VLAN_ID,
  LOCAL_ZONE_REGION,
  ONE_AZ_REGION,
  PCI_FEATURES,
  PLAN_ORDER,
  THREE_AZ_REGION,
  VLAN_ID,
} from '../../project.constants';

import {
  AVAILABLE_SUBNET,
  BANDWIDTH_OUT,
  FILTER_PRIVATE_NETWORK_BAREMETAL,
  FLOATING_IP_AVAILABILITY_INFO_LINK,
  INSTANCE_MODES_ENUM,
  INSTANCE_READ_MORE_GUIDE,
  LOCAL_PRIVATE_NETWORK_MODE,
  PRIVATE_NETWORK_MODE,
  PUBLIC_NETWORK_MODE,
  URL_MODEL,
  WINDOWS_PRIVATE_MODE_LICENSE_GUIDE,
} from './add.constants';

import {
  INSTANCE_PRICING_LINKS,
  INSTANCE_RESILIENCE_3AZ,
} from '../instances.constants';
import { useURLModel } from '../../project.utils';

export default class PciInstancesAddController {
  /* @ngInject */
  constructor(
    $q,
    $translate,
    coreConfig,
    $timeout,
    CucCloudMessage,
    cucUcentsToCurrencyFilter,
    PciProjectsProjectInstanceService,
    PciPublicGatewaysService,
    PciProjectAdditionalIpService,
    PciProjectDeploymentMode,
    atInternet,
    PciProject,
    OvhApiCloudProjectRegion,
    HOURS_PER_MONTH,
    $scope,
  ) {
    this.$q = $q;
    this.$translate = $translate;
    this.$timeout = $timeout;
    this.coreConfig = coreConfig;
    this.user = coreConfig.getUser();
    this.CucCloudMessage = CucCloudMessage;
    this.cucUcentsToCurrencyFilter = cucUcentsToCurrencyFilter;
    this.PciProjectsProjectInstanceService = PciProjectsProjectInstanceService;
    this.PciPublicGatewaysService = PciPublicGatewaysService;
    this.PciProjectDeploymentMode = PciProjectDeploymentMode;
    this.atInternet = atInternet;
    this.availableSubnet = AVAILABLE_SUBNET;
    this.instanceReadMoreUrl =
      INSTANCE_READ_MORE_GUIDE.ALL_GUIDE[this.user.ovhSubsidiary] ||
      INSTANCE_READ_MORE_GUIDE.ALL_GUIDE.DEFAULT;
    this.windowsPrivateModeLicenseGuideUrl =
      WINDOWS_PRIVATE_MODE_LICENSE_GUIDE[this.user.ovhSubsidiary] ||
      WINDOWS_PRIVATE_MODE_LICENSE_GUIDE.DEFAULT;
    this.instanceModeEnum = INSTANCE_MODES_ENUM;
    this.currency = coreConfig.getUser().currency.symbol;
    this.PciProjectAdditionalIpService = PciProjectAdditionalIpService;
    this.FLOATING_IP_AVAILABILITY_INFO_LINK = FLOATING_IP_AVAILABILITY_INFO_LINK;
    this.LOCAL_ZONE_REGION = LOCAL_ZONE_REGION;
    this.THREE_AZ_REGION = THREE_AZ_REGION;
    this.HOURS_PER_MONTH = HOURS_PER_MONTH;
    this.ONE_AZ_REGION = ONE_AZ_REGION;
    this.PciProject = PciProject;
    this.instancePricesLink =
      INSTANCE_PRICING_LINKS[this.user.ovhSubsidiary] ||
      INSTANCE_PRICING_LINKS.DEFAULT;
    this.OvhApiCloudProjectRegion = OvhApiCloudProjectRegion;

    this.resilience3azLink =
      INSTANCE_RESILIENCE_3AZ[this.user.ovhSubsidiary] ||
      INSTANCE_RESILIENCE_3AZ.DEFAULT;

    $scope.$watch(
      () => this.model.number,
      (newNumber, oldNumber) => {
        if (
          typeof newNumber === 'number' &&
          typeof oldNumber === 'number' &&
          newNumber !== oldNumber
        ) {
          this.trackAddInstance([
            'quantity_more',
            'add_instance',
            'configure_instance',
            newNumber > oldNumber ? 'more' : 'less',
          ]);
        }
      },
    );

    $scope.$watch(
      () => this.currentStep,
      (currentStep) => {
        if (currentStep >= 4) {
          this.instanceNumberValidated = true;
        }
        if (currentStep >= 5) {
          this.networkValidated = true;
        }
      },
    );

    $scope.$watch(
      () => this.model.flavorGroup,
      () => {
        if (this.model.flavorGroup) {
          this.deploymentModesPrices = PciProjectDeploymentMode.getFlavorGroupPricesPerDeploymentMode(
            this.model.flavorGroup,
          );
        }
      },
    );

    this.floatingIpPriceFormatter = new Intl.NumberFormat(
      this.user.language.replace('_', '-'),
      {
        style: 'currency',
        currency: this.user.currency.code,
        maximumFractionDigits: 5,
      },
    );
  }

  $onInit() {
    const {
      model: { selectedCategory },
    } = useURLModel(URL_MODEL);

    this.instance = new Instance({
      monthlyBilling: false,
    });

    this.isLoading = false;
    this.defaultInstanceName = '';

    this.showUserData = false;
    this.showNonAvailableRegions = false;

    this.quota = null;
    this.flavor = null;

    this.loadMessages();

    this.globalRegionsUrl = this.PciProject.getDocumentUrl('GLOBAL_REGIONS');
    this.localZoneUrl = this.PciProject.getDocumentUrl('LOCAL_ZONE');
    this.zone3azUrl = this.PciProject.getDocumentUrl('REGIONS_3AZ');

    this.selectedDeploymentMode = null;
    this.model = {
      flavorGroup: null,
      image: null,
      isImageCompatible: false,
      number: 1,
      location: null,
      datacenter: null,
      sshKey: null,
      isInstanceFlex: false,
      threeAzRegion: { auto: true, zone: '' },
    };
    this.osTypes = [];
    this.selectedCategory = selectedCategory;

    this.instanceNamePattern = PATTERN;

    this.defaultPrivateNetwork = this.getDefaultSelectValue(
      'pci_projects_project_instances_add_privateNetwork_none',
    );
    this.selectedPrivateNetwork = this.defaultPrivateNetwork;
    this.availablePrivateNetworks = [this.defaultPrivateNetwork];
    this.automatedBackup = {
      selected: false,
      schedule: null,
      price: null,
    };

    this.availableLocalPrivateNetworks = [this.defaultPrivateNetwork];
    this.modes = this.instanceModeEnum.map(({ mode }) => {
      return {
        name: mode,
        label: this.$translate.instant(
          `pci_projects_project_instances_add_privateNetwork_${mode}`,
        ),
        description1: this.$translate.instant(
          `pci_projects_project_instances_add_privateNetwork_${mode}_description1`,
        ),
        description2: this.$translate.instant(
          `pci_projects_project_instances_add_privateNetwork_${mode}_description2`,
        ),
      };
    });

    this.selectedFloatingIP = null;
    this.messageContainers = ['region', 'network', 'instance'];
    this.messages = {};
    this.loadMessages();
    [this.selectedMode] = this.modes;
    this.showAddPrivateNetworkModalForm = false;
    this.isAttachFloatingIP = false;
    this.isAttachPublicNetwork = false;
    this.isCreateFloatingIPClicked = false;
    this.subnetGateways = [];
    this.isCustomNetwork = false;
    this.isGatewayLoading = false;
    this.isLoadBillingStep = false;
    this.floatingIps = null;
    this.addons = [];

    this.defaultFloatingIp = this.getProductCatalog;
    this.isIpLoading = false;
    this.isAddingRegionError = false;

    this.configuration = {
      region: null,
      createGateway: false,
      vlanId: DEFAULT_VLAN_ID,
      cidr: DEFAULT_CIDR,
      dhcp: true,
      enableGatewayIp: true,
    };

    this.isAddingPrivateNetwork = false;
    this.isAddingPrivateNetworkError = false;

    this.regionsTypesAvailability = {};
    this.fetchRegionsTypesAvailability();

    this.availableRegions = {};
    this.unavailableRegions = {};
    this.showNonAvailableRegions = {};
    this.fetchInstancesAvailability();
  }

  get areLocalZonesFree() {
    return this.pciFeatures.isFeatureAvailable(
      PCI_FEATURES.BANNERS.FREE_LOCAL_ZONES_BANNER,
    );
  }

  get isLocalZoneSelected() {
    return this.model.datacenter?.type === 'localzone';
  }

  get isSavingsPlanAvailable() {
    return this.pciFeatures.isFeatureAvailable(
      PCI_FEATURES.PRODUCTS.SAVINGS_PLAN,
    );
  }

  onDeploymentModeChange(deploymentMode) {
    this.selectedDeploymentMode = deploymentMode;
    this.getFilteredRegions();
    this.trackAddInstance([
      'tile',
      'add_instance',
      'select_location_mode',
      deploymentMode.name,
    ]);
  }

  updateLocation(location, datacenters) {
    this.model.location = location;
    this.model.threeAzRegion = { auto: true, zone: '' };
    this.selectedMode = this.isLocalZone() ? this.modes[2] : this.modes[0];
    this.trackAddInstance(
      [
        'tile',
        'add_instance',
        'select_localisation',
        datacenters[0]?.name?.toLowerCase(),
      ].filter(Boolean),
    );
    return null;
  }

  on3AzRegionChange(auto) {
    if (auto) {
      this.model.threeAzRegion.zone = '';
    }
    this.trackAddInstance([
      'box',
      'add_instance',
      'select_location',
      `3AZ-${auto ? 'automated' : 'manually'}`,
    ]);
  }

  on3AZZoneChange(zone) {
    this.trackAddInstance([
      'box',
      'add_instance',
      'select_location',
      zone,
      '3AZ-manually-selected',
    ]);
  }

  onContinentChange(_, datacentersMap) {
    if (this.currentStep !== 1) {
      return;
    }
    const continentCodes = Object.values(datacentersMap)
      .flatMap((datacenters) =>
        datacenters.map(({ continentCode }) => continentCode.toLowerCase()),
      )
      .filter((item, index, list) => list.indexOf(item) === index);
    if (!continentCodes.length) {
      return;
    }
    this.trackAddInstance([
      'tab',
      'add_instance',
      'select_localisation',
      continentCodes.length > 1 ? 'all' : continentCodes[0],
    ]);
  }

  getSmallestGatewayInfo() {
    this.PciPublicGatewaysService.getGetwayAvalability(
      this.projectId,
      this.user.ovhSubsidiary,
      this.model.datacenter.name,
      'gateway',
    ).then((plans) => {
      // Find the smallest available plan based on predefined order
      const smallestAvailablePlan = PLAN_ORDER.map((planCode) =>
        plans.find(({ code }) => code.includes(planCode)),
      ).find((plan) => plan); // Get the first defined plan

      this.PciPublicGatewaysService.getSmallestGatewayInfo(
        this.user.ovhSubsidiary,
      ).then((data) => {
        const smallestGateway = data.find(
          (addon) => addon.planCode === smallestAvailablePlan.code,
        );

        const pricePerHour =
          smallestGateway.pricings.find((pricing) =>
            pricing.description.includes('hour'),
          )?.price || 0;

        this.defaultGateway = {
          size: smallestGateway.product.split('-').pop(), // Get the last segment of the product name
          pricePerHour,
        };
        this.isLoadBillingStep = false;
      });
    });
  }

  getDefaultSelectValue(transKey) {
    return {
      id: '',
      name: this.$translate.instant(transKey),
    };
  }

  fetchRegionsTypesAvailability() {
    this.PciProjectsProjectInstanceService.getRegionsTypesAvailability(
      this.projectId,
    ).then((regionsTypesAvailability) => {
      this.regionsTypesAvailability = regionsTypesAvailability;
    });
  }

  fetchInstancesAvailability() {
    this.isInstancesAvailabilityFetching = true;
    return this.PciProjectsProjectInstanceService.getProductAvailability(
      this.projectId,
      this.coreConfig.getUser().ovhSubsidiary,
      'instance',
    ).then((productCapabilities) => {
      this.instancesProductCapabilities = productCapabilities;
      this.isInstancesAvailabilityFetching = false;
    });
  }

  getFilteredRegions() {
    const availableRegions = {};
    const unavailableRegions = {};

    const planCode = `${this.model.flavorGroup.name}.consumption`;

    // New plancodes has been introduced for localzones which will have region names after plan codes names like ***.consumption.EU-WEST-LZ-BRU-A
    // So we need to consider all the plancodes which starts with "**flavorName**.consumption"
    const productCapability = this.instancesProductCapabilities.plans?.filter(
      (plan) => plan.code?.startsWith(planCode),
    );

    // After fetching all the productCapabilities we need to combine all the regions of possible plans
    // of "b38.consumption" "b38.consumption.EU-WEST-LZ-BRU-A" "b38.consumption.EU-SOUTH-LZ-MAD-A" into regionsAllowed
    const productRegionsAllowed = productCapability?.flatMap(
      ({ regions }) => regions,
    );

    Object.entries(this.regions).forEach(([continent, locationsMap]) => {
      // Create datacenters continent groups
      availableRegions[continent] = {};
      unavailableRegions[continent] = {};
      Object.entries(locationsMap).forEach(([location, datacenters]) => {
        if (
          !this.selectedDeploymentMode ||
          datacenters[0]?.type === this.selectedDeploymentMode.name
        ) {
          // Create datacenters location sub groups
          availableRegions[continent][location] = [];
          unavailableRegions[continent][location] = [];
          // Fill datacenters groups: a datacenter is considered available if
          // it is in a region where we have the capability to add an instance
          // and the selected flavor is available for the datacenter region
          datacenters.forEach((datacenter) => {
            // If productAvailibility of the Product is not enabled it means Product is not activated in that region
            // in this case Enabled = false and we need to skip checking available regions from flavorGroup
            const isDatacenterAvailable = !!productRegionsAllowed.find(
              (productRegion) =>
                productRegion.name === datacenter.name &&
                (this.model.flavorGroup.availableRegions.includes(
                  productRegion.name,
                ) ||
                  !productRegion.enabled),
            );

            if (isDatacenterAvailable) {
              availableRegions[continent][location].push(datacenter);
            } else {
              unavailableRegions[continent][location].push(datacenter);
            }
          });
        }
      });

      this.showNonAvailableRegions[continent] = !this.constructor.hasRegions(
        availableRegions[continent],
      );
    });

    this.availableRegions = availableRegions;
    this.unavailableRegions = unavailableRegions;
  }

  static hasRegions(locations) {
    return some(locations, (datacenters) => datacenters.length);
  }

  loadMessages() {
    this.messageHandlers = this.messageContainers?.reduce(
      (handlers, containerName) => ({
        ...handlers,
        [containerName]: this.CucCloudMessage.subscribe(
          `pci.projects.project.instances.add-${containerName}`,
          {
            onMessage: () => this.refreshMessages(),
          },
        ),
      }),
      {},
    );
  }

  refreshMessages() {
    this.messages = this.messageContainers?.reduce(
      (messages, containerName) => ({
        ...messages,
        [containerName]: this.messageHandlers[containerName].getMessages(),
      }),
      {},
    );
  }

  onFlavorFocus() {
    if (this.model.flavorGroup) {
      this.trackAddInstance([
        'link',
        'add_instance',
        `edit_step_flavor_${this.model.flavorGroup.name}`,
      ]);
    }
    this.displaySelectedFlavor = false;
  }

  onFlavorChange() {
    this.displaySelectedFlavor = true;
    this.getFilteredRegions();

    this.trackAddInstance([
      'button',
      'add_instance',
      'select_flavor',
      `add_${this.model.flavorGroup.name}`,
    ]);
  }

  displayFlavorSelectionHeader() {
    if (this.currentStep > 0) {
      // if the flavor doesn't have a monthly plan
      if (!this.model.flavorGroup?.prices?.monthly) {
        return this.$translate.instant(
          'pci_projects_project_instances_add_flavor_selected_title_without_price',
          {
            model: this.model?.flavorGroup?.name.toUpperCase(),
          },
        );
      }

      // if the flavor does have a monthly plan
      return this.$translate.instant(
        'pci_projects_project_instances_add_flavor_selected_title',
        {
          model: this.model?.flavorGroup?.name.toUpperCase(),
          price: this.model?.flavorGroup?.prices?.monthly?.text,
        },
      );
    }
    // current step is the flavor selection step
    return this.$translate.instant(
      'pci_projects_project_instances_add_flavor_title',
    );
  }

  IsSavingsPlanBannerDisplayed() {
    return this.hasSavingsPlan;
  }

  IsComingSoonPricingBannerDisplayed() {
    return !this.model.flavorGroup?.prices?.monthly;
  }

  onFlavorCategorySelect(flavor, category) {
    this.selectedCategory = category;
    this.trackAddInstance(
      ['tile', 'add_instance', 'select_flavor', flavor?.name].filter(Boolean),
    );
    if (flavor.legacy) {
      this.CucCloudMessage.warning(
        this.$translate.instant(
          'pci_projects_project_instances_add_flavor_selected_legacy',
        ),
        'pci.projects.project.instances.add-instance',
      );
    } else {
      this.messages = [];
    }
  }

  onFlavorCategoryChange(category) {
    if (this.currentStep === 0 && category) {
      this.trackAddInstance(['tab', 'add_instance', 'select_flavor', category]);
    }
  }

  onRegionFocus() {
    if (this.instance?.region) {
      this.trackAddInstance([
        'link',
        'add_instance',
        `edit_step_localisation_${this.instance.region.toLowerCase()}`,
      ]);
    }
    this.displaySelectedRegion = false;
    if (this.instance.availabilityZone) {
      delete this.instance.availabilityZone;
    }
    this.model.datacenter = null;
    this.selectedDeploymentMode = null;
    this.getFilteredRegions();

    this.$timeout(() => {
      const regionStepper = document.getElementById('instances_add_region');
      if (regionStepper) {
        regionStepper.scrollIntoView();
      }
    }, 0);
  }

  addRegions() {
    return this.OvhApiCloudProjectRegion.v6()
      .addRegion(
        { serviceName: this.projectId },
        { region: this.model.datacenter.name },
      )
      .$promise.then(() => {
        return this.$q.all([
          this.OvhApiCloudProjectRegion.AvailableRegions()
            .v6()
            .resetQueryCache(),
          this.PciProjectsProjectInstanceService.getSnapshotAvailability(
            this.projectId,
            this.catalogEndpoint,
          ).then((snapshotAvailability) => {
            this.snapshotAvailability[this.model.datacenter.name] =
              snapshotAvailability[this.model.datacenter.name];
          }),
        ]);
      })
      .then(() => {
        this.CucCloudMessage.success(
          this.$translate.instant(
            'pci_projects_project_regions_add_region_success',
            {
              code: this.model.datacenter.name,
            },
          ),
          'pci.projects.project.instances.add-region',
        );
        this.isLoading = false;
        this.isAddingRegionError = false;
      })
      .catch((error) => {
        this.CucCloudMessage.error(
          this.$translate.instant(
            'pci_projects_project_regions_add_region_error',
            {
              message: get(error, 'data.message'),
            },
          ),
          'pci.projects.project.instances.add-region',
        );
        this.isLoading = false;
        this.isAddingRegionError = true;
      });
  }

  onRegionChange() {
    if (!this.model.datacenter || this.isAddingNewRegion) {
      return null;
    }

    this.getFilteredRegions();

    if (
      !this.isAddingNewRegion &&
      this.model.datacenter &&
      !this.isRegionAvailable(this.model.datacenter)
    ) {
      this.trackAddInstance([
        'button',
        'add_instance',
        'select_localisation',
        `activate_add_${this.model.datacenter.name.toLowerCase()}`,
      ]);
      this.isLoading = true;
      this.isAddingNewRegion = true;
      return this.addRegions().then(() => {
        return this.PciProjectsProjectInstanceService.getProjectQuota(
          this.projectId,
          this.model.datacenter.name,
        ).then((data) => {
          this.model.datacenter.quota = data;
          this.model.datacenter.available = true;

          this.displaySelectedRegion = true;
          this.instance.region = this.model.datacenter.name;
          // Retrieve list of os types availables for the selected regio

          this.isAddingNewRegion = false;
          this.reloadFlavorList = true;
          this.isLoading = false;
        });
      });
    }

    this.displaySelectedRegion = true;
    this.instance.region = this.model.datacenter.name;
    // Retrieve list of os types availables for the selected region
    this.osTypes = this.model.flavorGroup.getOsTypesByRegion(
      this.model.datacenter.name,
    );
    this.availablePrivateNetworks = [
      this.defaultPrivateNetwork,
      ...sortBy(
        map(
          filter(this.privateNetworks, (network) =>
            find(network.regions, {
              region: this.instance.region,
              status: 'ACTIVE',
            }) &&
            // For metal instances we only have vlan 0 available
            this.model.flavorGroup.type === FILTER_PRIVATE_NETWORK_BAREMETAL
              ? network.vlanId === 0
              : network.vlanId !== null,
          ),
          (privateNetwork) => {
            return {
              ...privateNetwork,
              name: `${privateNetwork.vlanId.toString().padStart(4, '0')} - ${
                privateNetwork.name
              }`,
            };
          },
        ),
        ['name'],
      ),
    ];

    if (!includes(this.availablePrivateNetworks, this.selectedPrivateNetwork)) {
      this.selectedPrivateNetwork = this.defaultPrivateNetwork;
    }
    this.getPrivateNetworkSubnet();
    if (this.isLocalZone()) {
      this.PciProjectsProjectInstanceService.getLocalPrivateNetworks(
        this.projectId,
        this.model.datacenter.name,
      )
        .then((network) => {
          this.availableLocalPrivateNetworks = network;
          this.getLocalPrivateNetworkSubnet();
        })
        .catch((error) =>
          this.CucCloudMessage.error(
            get(error, 'data.message'),
            'pci.projects.project.instances.add-region',
          ),
        );
    }

    this.trackAddInstance([
      'button',
      'add_instance',
      'select_localisation',
      `add_${this.instance.region.toLowerCase()}}`.concat(
        this.is3AZRegion()
          ? `-${this.model.threeAzRegion.auto ? 'automated' : 'manually'}`
          : '',
      ),
    ]);

    this.model.image = null;
    return null;
  }

  getPrivateNetworkSubnet() {
    return this.$q
      .all(
        this.availablePrivateNetworks.map((privateNetwork) => {
          if (privateNetwork.id) {
            return this.PciProjectsProjectInstanceService.getSubnets(
              this.projectId,
              privateNetwork.id,
            ).then((data) => {
              return {
                ...privateNetwork,
                subnet: data.filter(
                  (subnet) => subnet.ipPools[0].region === this.instance.region,
                ),
              };
            });
          }
          return privateNetwork;
        }),
      )
      .then((data) => {
        this.availablePrivateNetworks = [
          this.defaultPrivateNetwork,
          ...data.filter(({ subnet }) => subnet?.length > 0),
        ];
        return this.availablePrivateNetworks;
      });
  }

  onImageFocus() {
    this.displaySelectedImage = false;
    if (this.model.image?.nameGeneric) {
      this.trackAddInstance([
        'link',
        'add_instance',
        `edit_step_image_${this.model.image.nameGeneric}`,
      ]);
    }
  }

  onImageChange() {
    this.displaySelectedImage = true;

    if (this.model.image.isBackup()) {
      this.instance.imageId = this.model.image.id;
      this.instance.imageRegionName = this.model.image.region;
    } else {
      this.instance.imageId = this.model.image.getIdByRegion(
        this.instance.region,
      );
      this.instance.imageRegionName = this.instance.region;
    }

    this.onFlexChange(false);

    if (!this.isLinuxImageType()) {
      this.model.sshKey = null;
      this.instance.sshKey = null;
    } else {
      this.instance.sshKey = this.model.sshKey;
    }

    this.trackAddInstance([
      'button',
      'add_instance',
      'select_image',
      `add_${this.model.image.nameGeneric}`,
    ]);
  }

  isLinuxImageType() {
    return this.model.image?.type?.includes('linux');
  }

  isWindowsImageType() {
    return this.model.image?.type?.includes('windows');
  }

  showImageNavigation() {
    return (
      this.model.image &&
      this.model.isImageCompatible &&
      (!this.isLinuxImageType() || this.model.sshKey)
    );
  }

  onInstanceFocus() {
    if (this.instanceNumberValidated) {
      this.trackAddInstance([
        'link',
        'add_instance',
        'edit_step_configure_instance',
      ]);
    }
    if (this.isLocalZone() && !this.selectedPrivateNetwork.id) {
      // Display default selection for local private mode
      this.selectedPrivateNetwork = {
        id: '',
        name: this.$translate.instant(
          'pci_projects_project_instances_add_localPrivateNetwork_placeholder',
        ),
      };
    }
    if (!isEmpty(this.model.datacenter)) {
      this.quota = new Quota(this.model.datacenter.quota.instance);
      this.generateInstanceName();
      if (
        this.PciProjectsProjectInstanceService.automatedBackupIsAvailable(
          this.flavor.type,
        )
      ) {
        if (
          !this.snapshotAvailability[this.instance.region] ||
          !this.snapshotAvailability[this.instance.region].plans.length ||
          !this.snapshotAvailability[this.instance.region].workflow
        ) {
          this.automatedBackup.selected = false;
          this.automatedBackup.schedule = null;
          this.automatedBackup.price = null;
        } else {
          const plan = this.snapshotAvailability[this.instance.region].plans[0];
          this.automatedBackup.price = this.formatBackupMonthlyPrice(
            plan.price,
          );
        }

        return this.automatedBackup.price;
      }
    }
    return this.$q.when();
  }

  formatBackupMonthlyPrice(price) {
    const { value, currencyCode } = price;

    const formatter = new Intl.NumberFormat(
      this.coreConfig.getUserLocale().replace('_', '-'),
      {
        style: 'currency',
        currency: currencyCode,
        maximumFractionDigits: 3,
      },
    );

    return `~${formatter.format(value * this.HOURS_PER_MONTH)}`;
  }

  getLocalPrivateNetworkSubnet() {
    return this.$q
      .all(
        this.availableLocalPrivateNetworks.map((privateNetwork) => {
          if (privateNetwork.id) {
            return this.PciProjectsProjectInstanceService.getLocalPrivateNetworkSubnets(
              this.projectId,
              this.model.datacenter.name,
              privateNetwork.id,
            ).then((data) => {
              return {
                ...privateNetwork,
                subnet: [
                  {
                    ...data,
                    ipPools: data?.allocationPools,
                  },
                ],
              };
            });
          }
          return privateNetwork;
        }),
      )
      .then((data) => {
        this.availableLocalPrivateNetworks = [
          this.defaultPrivateNetwork,
          ...data.filter(({ subnet }) => subnet?.length > 0),
        ];
      });
  }

  generateInstanceName() {
    if (
      !has(this.instance, 'name') ||
      get(this.instance, 'name') === this.defaultInstanceName
    ) {
      this.defaultInstanceName = `${this.flavor.name}-${this.instance.region}`.toLowerCase();
      this.instance.name = this.defaultInstanceName;
    }
  }

  onFlexChange(isFlex) {
    this.flavor = this.model.flavorGroup.getFlavorByOsType(
      this.model.image.type,
      isFlex,
    );

    this.instance.flavorId = this.model.flavorGroup.getFlavorId(
      this.model.image.type,
      this.instance.region,
      isFlex,
    );
    this.generateInstanceName();

    this.model.flavorGroup.prices = this.model.flavorGroup.getPriceBasedOnFlavorId(
      this.instance.flavorId,
    );

    // Legacy code : FlavorGroup prices seems to contains the valid price based on 3AZ, 1AZ or LocalZone
    // In a recent PR we use flavor instead of flavorGroup to display Windows Gen 3 Licence but it's introduce a regression on LocalZone Price (https://github.com/ovh/manager/pull/16314/files#r2073015373)
    // Patch the issue by setting the valid flavorGroup Prices to the current flavor
    this.flavor.prices = { ...this.model.flavorGroup.prices };

    this.flavorGroup = { ...this.model.flavorGroup };
  }

  isRegionAvailable(datacenter) {
    return (
      datacenter?.isAvailable() &&
      datacenter?.hasEnoughQuotaForFlavors(this.model.flavorGroup)
    );
  }

  isRegionActive(datacenter) {
    return this.availableRegions.includes(datacenter.name);
  }

  createQuota() {
    if (!isEmpty(this.model.datacenter)) {
      this.quota = new Quota(this.model.datacenter.quota.instance);
    }
  }

  getUnavailabilityReason(datacenter) {
    if (!datacenter.isAvailable()) {
      return 'INACTIVE';
    }

    if (has(datacenter, 'quota.instance')) {
      if (!datacenter.checkInstancesNumber()) {
        return 'INSTANCE';
      }

      if (!datacenter.checkRamQuota(this.model.flavorGroup)) {
        return 'RAM';
      }

      if (!datacenter.checkCoresQuota(this.model.flavorGroup)) {
        return 'VCPUS';
      }
    }

    return 'UNKWOWN';
  }

  onCancel() {
    this.trackAddInstance(['add', 'create-private-network', 'cancel']);
    this.showAddPrivateNetworkModalForm = false;
  }

  trackAction(type) {
    const mode = this.instance.monthlyBilling ? 'monthly' : 'hourly';
    if (type === 'create') {
      this.trackAddInstance([
        'button',
        'add_instance',
        'add_billing',
        `add_${mode}`,
      ]);
    }
    this.trackAddInstance([
      'button',
      'add_instance',
      ...(type === 'create' ? ['confirm'] : [type]),
      [
        ...(type === 'create' ? ['instances', 'created'] : []),
        mode,
        this.instance.region
          .toLowerCase()
          .concat(
            this.is3AZRegion()
              ? `-${this.model.threeAzRegion.auto ? 'automated' : 'manually'}`
              : '',
          ),
        this.model.flavorGroup.name,
        this.selectedMode.name.replace('_mode', ''),
        this.model.image.nameGeneric,
      ].join('_'),
    ]);
  }

  onInstanceSubmit() {
    this.isLocalPrivateModeLocalZone = false;
    this.isCreatingNewPrivateNetwork = null;
    this.isAttachFloatingIP = false;
    this.trackAddInstance([
      'button',
      'add_instance',
      'configure_instance',
      `add_${this.model.number}`,
    ]);
  }

  onModeFocus() {
    this.displaySelectedMode = false;
    this.isFloatingIpAvailable = false;
    if (this.isLocalZone()) {
      this.privateNetworkName = null;
      this.selectedPrivateNetwork = this.defaultPrivateNetwork;
      this.isAddingPrivateNetworkError = false;
      this.regenerateNetworkAddress(DEFAULT_VLAN_ID);
      this.loadNetworkDetails();
    }
    this.PciProjectAdditionalIpService.getRegions(
      this.projectId,
      this.user.ovhSubsidiary,
      null,
      'floatingip',
    ).then((regions) => {
      this.isFloatingIpAvailable = regions.some(
        ({ name }) => name === this.model.datacenter.name,
      );
      if (!this.isFloatingIpAvailable) {
        this.isAttachFloatingIP = false;
      }
    });
    if (this.networkValidated) {
      this.trackAddInstance([
        'link',
        'add_instance',
        `edit_step_configure_network_${this.selectedMode.name.replace(
          '_mode',
          '',
        )}`,
      ]);
    }
  }

  loadNetworkDetails() {
    return this.PciProjectsProjectInstanceService.getPrivateNetworksByRegion(
      this.projectId,
      this.customerRegions,
    ).then((networks) => {
      this.networks = networks;
      this.configureVlanId = !this.isVlanAvailable(DEFAULT_VLAN_ID);
      this.mandatoryVlanId = this.configureVlanId;

      if (this.configureVlanId) {
        const nextVlanId = this.getNextAvailableVlanId();
        this.VLAN_ID = {
          MIN: VLAN_ID.MIN,
          MAX: VLAN_ID.MAX,
          NEXT_AVAILABLE: nextVlanId,
        };
        this.configuration.vlanId = this.VLAN_ID.NEXT_AVAILABLE;

        this.regenerateNetworkAddress(this.configuration.vlanId);
      }
    });
  }

  getNextAvailableVlanId() {
    const network = this.networks.find(
      ({ vlanId }) =>
        vlanId !== DEFAULT_VLAN_ID &&
        !this.networks.some(({ vlanId: nextId }) => nextId === vlanId + 1),
    );
    return network ? network.vlanId + 1 : DEFAULT_VLAN_ID;
  }

  isVlanAvailable(checkVlanId) {
    return this.networks?.every(({ vlanId }) => vlanId !== checkVlanId);
  }

  onModeChange() {
    this.displaySelectedMode = true;
  }

  onAttachIPChange(value) {
    if (value) {
      if (!this.floatingIps) {
        this.getFloatingIps();
      }
      if (this.isCreateFloatingIPClicked) {
        this.isCreateFloatingIPClicked = false;
      }
      this.trackAddInstance(['add', 'enable-attach-floating-ip']);
    } else {
      this.trackAddInstance(['add', 'disable-attach-floating-ip']);
    }
    return this.floatingIps;
  }

  onSelectedModeChange(mode) {
    this.selectedMode = mode;
    this.selectedPrivateNetwork = {
      id: '',
      name: this.$translate.instant(
        'pci_projects_project_instances_add_privateNetwork_none',
      ),
    };
    if (this.subnetGateways) {
      this.subnetGateways = [];
    }
    if (this.isPrivateMode()) {
      this.isCreateFloatingIPClicked = false;
      this.isAttachFloatingIP = false;
      this.selectedPrivateNetwork = {
        id: '',
        name: this.$translate.instant(
          'pci_projects_project_instances_add_privateNetwork_placeholder',
        ),
      };
    }
    if (this.isLocalPrivateMode()) {
      this.isAttachPublicNetwork = false;
      this.selectedPrivateNetwork = {
        id: '',
        name: this.$translate.instant(
          'pci_projects_project_instances_add_localPrivateNetwork_placeholder',
        ),
      };
    }
    this.trackAddInstance([
      'tile',
      'add_instance',
      'configure_network',
      mode.name.replace('_mode', ''),
    ]);
  }

  isPrivateMode() {
    return this.selectedMode.name === PRIVATE_NETWORK_MODE;
  }

  isPublicMode() {
    return this.selectedMode.name === PUBLIC_NETWORK_MODE;
  }

  isLocalPrivateMode() {
    return this.selectedMode.name === LOCAL_PRIVATE_NETWORK_MODE;
  }

  isLocalZone() {
    return this.model?.datacenter?.type === this.LOCAL_ZONE_REGION;
  }

  is3AZRegion() {
    return this.model?.datacenter?.type === this.THREE_AZ_REGION;
  }

  onFloatingIpChange(value) {
    if (value !== null && !value?.id) {
      this.isCreateFloatingIPClicked = true;
      this.getFloatingIpPrice();
      this.trackAddInstance(['add', 'create-floating-ip']);
    } else {
      this.selectedFloatingIP = value;
      this.isCreateFloatingIPClicked = false;
    }
  }

  onPrivateNetworkChange(modelValue) {
    if (
      modelValue &&
      modelValue.subnet &&
      this.selectedMode.name !== PRIVATE_NETWORK_MODE &&
      !this.isLocalZone()
    ) {
      this.getSubnetGateways(modelValue.subnet[0].id)
        .then((data) => {
          this.subnetGateways = data;
        })
        .catch(() => {
          this.subnetGateways = [];
        });
    }
    this.subnetGateways = [];
  }

  getFloatingIps() {
    this.isIpLoading = true;
    return this.PciProjectsProjectInstanceService.getFloatingIps(
      this.projectId,
      this.model.datacenter.name,
    )
      .then((data) => {
        this.floatingIps = data;
        this.floatingIps.push({
          id: '',
          isCustom: true,
          ip: this.$translate.instant(
            'pci_projects_project_instances_add_create_floating_ip_action',
          ),
        });
      })
      .catch((err) => {
        this.handleError(err);
      })
      .finally(() => {
        this.isIpLoading = false;
      });
  }

  getSubnetGateways(id) {
    this.isGatewayLoading = true;
    return this.PciProjectsProjectInstanceService.getSubnetGateways(
      this.projectId,
      this.model.datacenter.name,
      id,
    )
      .then((data) => data)
      .finally(() => {
        this.isGatewayLoading = false;
      });
  }

  onModeSubmit() {
    if (this.isLocalPrivateModeLocalZone && this.privateNetworkName) {
      this.onCreatePrivateNetworkClick();
    }

    this.trackAddInstance([
      'button',
      'add_instance',
      'configure_network',
      [
        this.selectedPrivateNetwork?.id ? 'associate' : 'add',
        this.selectedMode.name.replace('_mode', ''),
      ].join('_'),
    ]);

    this.addons = [];
    if (
      this.isPrivateMode() &&
      this.isAttachFloatingIP &&
      this.selectedPrivateNetwork
    ) {
      this.isLoadBillingStep = true;

      if (this.selectedPrivateNetwork.subnet?.[0]) {
        return this.getSubnetGateways(this.selectedPrivateNetwork.subnet[0].id)
          .then((data) => {
            this.subnetGateways = data;

            // TODO rework the pricing details (total, floatingIp and gateway)
            // this.addPricing();
            if (
              this.subnetGateways.length > 0 &&
              this.selectedPrivateNetwork.subnet[0]?.gatewayIp === null
            ) {
              this.enableDhcp();
            }
            this.isGatewayLoading = false;
          })
          .catch((err) => {
            this.handleError(err);
          })
          .finally(() => {
            this.isLoadBillingStep = false;
          });
      }
    }
    return null;
  }

  getFloatingIpPrice() {
    this.PciProjectsProjectInstanceService.getProductAvailability(
      this.projectId,
      this.coreConfig.getUser().ovhSubsidiary,
      'floatingip',
    ).then((productCapabilities) => {
      const hourCapabilities = productCapabilities.plans.filter((plan) =>
        plan.code.includes('hour'),
      );

      const flattenCode = hourCapabilities.flatMap((plan) =>
        plan.regions.map((region) => ({
          code: plan.code,
          region: region.name,
        })),
      );

      const activeCode =
        flattenCode.find(
          (code) => code.region === this.model.datacenter?.name,
        ) || flattenCode?.[0];

      const catalogPrice = this.catalog.addons.find(
        (addon) => addon.planCode === activeCode?.code,
      );

      this.floatingIpPrice = this.getFormatedHourlyPrice(
        catalogPrice?.pricings?.[0].price || 0,
      );
      return this.floatingIpPrice;
    });
  }

  showNetworkNavigation() {
    if (this.isPrivateMode()) {
      return (
        this.selectedPrivateNetwork.id !== '' &&
        (!this.isAttachFloatingIP || this.selectedFloatingIP)
      );
    }

    if (this.isLocalPrivateMode()) {
      return (
        this.selectedPrivateNetwork.id !== '' ||
        (this.isAttachPublicNetwork && !this.isLocalPrivateModeLocalZone) ||
        (this.isLocalPrivateModeLocalZone && this.privateNetworkName)
      );
    }

    if (
      this.isLocalZone() &&
      !(this.isPrivateMode() || this.isLocalPrivateMode())
    ) {
      return false;
    }

    return (
      !this.isGatewayLoading &&
      this.subnetGateways &&
      this.subnetGateways.length === 0
    );
  }

  addPricing() {
    if (
      this.isAttachFloatingIP &&
      this.subnetGateways.length === 0 &&
      this.selectedFloatingIP.id
    ) {
      this.addons = [...this.addons, { gateway: this.defaultGateway }];
    }
    if (
      this.isAttachFloatingIP &&
      this.subnetGateways.length === 0 &&
      !this.selectedFloatingIP.id
    ) {
      this.addons = [
        ...this.addons,
        { gateway: this.defaultGateway },
        { floatingIp: this.getProductCatalog },
      ];
    } else if (
      this.isAttachFloatingIP &&
      !this.selectedFloatingIP.id &&
      this.subnetGateways.length > 0
    ) {
      this.addons = [...this.addons, { floatingIp: this.defaultFloatingIp }];
    }
  }

  enableDhcp() {
    this.dhcpModel = {
      dhcp: true,
      noGateway: false,
      start: this.selectedPrivateNetwork.subnet[0].ipPools[0].start,
      end: this.selectedPrivateNetwork.subnet[0].ipPools[0].end,
      network: this.selectedPrivateNetwork.subnet[0].ipPools[0].network,
      region: this.selectedPrivateNetwork.subnet[0].ipPools[0].region,
    };
    return this.PciProjectsProjectInstanceService.enableDhcp(
      this.projectId,
      this.selectedPrivateNetwork.id,
      this.dhcpModel,
    )
      .then((data) => data)
      .catch((err) => {
        this.isLoading = false;
        return this.handleError(err);
      });
  }

  getSavingsPlanPrice() {
    return this.PciProjectsProjectInstanceService.getCommercialCatalog({
      productCode: this.model.flavorGroup.name,
      nature: 'BILLING_PLAN',
      ovhSubsidiary: this.coreConfig.getUser().ovhSubsidiary,
    })
      .then((savingsPlan) => {
        this.hasSavingsPlan = !this.isLocalZone() && savingsPlan.length > 0;
      })
      .catch(() => {
        this.hasSavingsPlan = false;
      });
  }

  onBillingFocus() {
    this.isLoadBillingStep = true;

    this.$q
      .all([
        this.getUAppUrl(
          'public-cloud',
          `#/pci/projects/${this.projectId}/savings-plan`,
        ).then((url) => {
          this.savingsPlanUrl = url;

          if (
            (this.subnetGateways.length === 0 ||
              this.subnetGateways.length > 1) &&
            this.isAttachFloatingIP &&
            !this.isAddingPrivateNetwork &&
            !this.isAddingPrivateNetworkError
          ) {
            this.isLoadBillingStep = true;
            this.getSmallestGatewayInfo();
          }
        }),
        this.isSavingsPlanAvailable && this.getSavingsPlanPrice(),
      ])
      .finally(() => {
        this.isLoadBillingStep = false;
      });
  }

  onCreateFormStepperSubmit() {
    return this.create();
  }

  create() {
    this.isLoading = true;
    this.trackAction('create');

    if (!this.isLinuxImageType()) {
      this.instance.userData = null;
    }

    if (
      this.PciProjectsProjectInstanceService.automatedBackupIsAvailable(
        this.flavor.type,
      ) &&
      this.automatedBackup.selected
    ) {
      const { schedule } = this.automatedBackup;
      this.instance.autobackup = {
        cron: `${schedule.cronPattern.minutes} ${schedule.cronPattern.hour} ${schedule.cronPattern.dom} ${schedule.cronPattern.month} ${schedule.cronPattern.dow}`,
        rotation: schedule.rotation,
      };
    }

    if (this.is3AZRegion() && this.model.threeAzRegion.zone) {
      this.instance.availabilityZone = this.model.threeAzRegion.zone;
    }

    const network = {
      private:
        this.isPrivateMode() ||
        (this.isLocalPrivateMode() && this.isLocalPrivateModeLocalZone) ||
        (this.isPublicMode() && this.selectedPrivateNetwork)
          ? {
              floatingIp:
                !this.isPublicMode() && this.selectedFloatingIP?.id
                  ? {
                      id: this.selectedFloatingIP.id,
                    }
                  : null,
              floatingIpCreate:
                !this.isPublicMode() &&
                !!this.selectedFloatingIP &&
                !this.selectedFloatingIP.id
                  ? {
                      description: '',
                    }
                  : null,
              gatewayCreate:
                !this.isPublicMode() &&
                this.subnetGateways?.length === 0 &&
                this.isAttachFloatingIP
                  ? {
                      model: this.defaultGateway.size,
                      name: getAutoGeneratedName(
                        `gateway-${this.model.datacenter.name.toLowerCase()}`,
                      ),
                    }
                  : null,
              gateway:
                !this.isPublicMode() &&
                this.subnetGateways?.length === 1 &&
                this.isAttachFloatingIP
                  ? {
                      id: this.subnetGateways[0]?.id,
                    }
                  : null,
              ip: null,

              network: {
                id:
                  this.selectedPrivateNetwork?.regions?.find(
                    (r) => r.region === this.instance.region,
                  )?.openstackId || this.selectedPrivateNetwork.id,
                subnetId: this.selectedPrivateNetwork.subnet?.[0]?.id,
              },
            }
          : null,
      public: this.isPublicMode() || this.isAttachPublicNetwork,
    };

    return this.PciProjectsProjectInstanceService.save(
      this.projectId,
      this.instance.region,
      { ...this.instance, network },
      this.model.number,
    )
      .then(() => {
        let messageType = null;
        if (
          this.model.image.isBackup() &&
          !this.model.image.isAvailableInRegion(this.instance.region)
        ) {
          messageType = 'distant_backup';
        } else if (this.isPrivateMode()) {
          messageType = 'private_network';
        }

        return this.goBack(
          this.$translate.instant(
            `pci_projects_project_instances_add_success_message${
              messageType ? `_${messageType}` : ''
            }`,
          ),
          'success',
        );
      })
      .catch((error) => {
        this.createInstanceError(error);
      })
      .finally(() => {
        this.isLoading = false;
      });
  }

  createInstanceError(error) {
    let message;
    if (this.model.number === 1) {
      message = this.$translate.instant(
        'pci_projects_project_instances_add_error_save',
        {
          instance: this.instance.name,
          message: get(error, 'data.message', null),
        },
      );
    } else {
      message = this.$translate.instant(
        'pci_projects_project_instances_add_error_multiple_save',
        {
          message: get(error, 'data.message', null),
        },
      );
    }

    this.CucCloudMessage.error(
      message,
      'pci.projects.project.instances.add-instance',
    );
    this.$timeout(() => {
      document
        .getElementById('create-instance-error-container')
        .scrollIntoView(true);
    });
  }

  handleError(err) {
    this.CucCloudMessage.error(
      this.$translate.instant(
        'pci_projects_project_instances_add_common_error',
        { message: get(err, 'data.message', '') },
      ),
      'pci.projects.project.instances.add-instance',
    );
  }

  cancel() {
    this.trackAction('cancel');
    return this.goBack();
  }

  getBandwidthExtraCost(region) {
    return this.cucUcentsToCurrencyFilter(
      get(this.prices, `${BANDWIDTH_OUT}.${region.name}`).price,
    );
  }

  displayNetwork(mode, type) {
    if (type === this.LOCAL_ZONE_REGION) return mode !== 'public_mode';
    if (type !== this.LOCAL_ZONE_REGION) return mode !== 'local_private_mode';
    return true;
  }

  onFlavorListLoadEnd() {
    if (this.reloadFlavorList && this.currentStep === 2) {
      this.reloadFlavorList = false;
      if (!this.isAddingRegionError) {
        this.onRegionChange();
      }
    }
  }

  isRegionValid() {
    return (
      this.model.datacenter &&
      !this.isDiscoveryProject &&
      (this.isRegionAvailable(this.model.datacenter) ||
        (!this.model.datacenter.isAvailable() &&
          !this.model.datacenter.hasEnoughQuotaForFlavors(
            this.model.flavorGroup,
          )))
    );
  }

  regenerateNetworkAddress(vlanId) {
    this.configuration.address = this.PciProjectsProjectInstanceService.constructor.generateNetworkAddress(
      vlanId,
    );
  }

  createPrivateNetwork() {
    const subnet = {
      cidr: `${this.configuration.address}/${this.configuration.cidr}`,
      ipVersion: 4,
      enableDhcp: this.configuration.dhcp,
      enableGatewayIp: this.configuration.enableGatewayIp,
    };
    return this.PciProjectsProjectInstanceService.createPrivateNetwork(
      this.projectId,
      this.instance.region,
      this.privateNetworkName,
      subnet,
    );
  }

  onCreatePrivateNetworkClick() {
    this.isAddingPrivateNetwork = true;

    return this.createPrivateNetwork()
      .then((networkId) => {
        return this.PciProjectsProjectInstanceService.getLocalPrivateNetworks(
          this.projectId,
          this.model.datacenter.name,
        ).then((networks) => {
          this.availableLocalPrivateNetworks = networks;
          this.selectedPrivateNetwork = networks.find(
            (n) => n.id === networkId,
          );
          this.isCreatingNewPrivateNetwork = false;
          return this.getLocalPrivateNetworkSubnet()
            .then(() => {
              this.CucCloudMessage.success(
                this.$translate.instant(
                  'pci_projects_project_instances_network_private_create_success',
                  {
                    code: this.model.datacenter.name,
                  },
                ),
                'pci.projects.project.instances.add-network',
              );
              this.isAddingPrivateNetwork = false;
              this.isAddingPrivateNetworkError = false;
              this.selectedPrivateNetwork = this.availableLocalPrivateNetworks.find(
                (n) => n.id === networkId,
              );
            })
            .catch((error) => {
              this.CucCloudMessage.error(
                get(error, 'data.message'),
                'pci.projects.project.instances.add-network',
              );
            });
        });
      })
      .catch((error) => {
        this.CucCloudMessage.error(
          this.$translate.instant(
            'pci_projects_project_instances_network_private_create_error',
            { message: get(error, 'data.message') },
          ),
          'pci.projects.project.instances.add-network',
        );

        this.isAddingPrivateNetwork = false;
        this.isAddingPrivateNetworkError = true;
      })
      .finally(() => {
        this.isAddingPrivateNetwork = false;
      });
  }

  handleisCreatingNewPrivateNetworkChange(modelValue) {
    if (this.isCreatingNewPrivateNetwork === false) {
      this.privateNetworkName = null;
    }
    this.selectedPrivateNetwork = this.defaultPrivateNetwork;
    this.trackAddInstance([
      'box',
      'add_instance',
      modelValue
        ? 'create_local_private_network'
        : 'associate_existing_private_network',
    ]);
  }

  onShowNonAvailableRegionsChange(modelValue) {
    if (modelValue) {
      this.trackAddInstance([
        'box',
        'add_instance',
        'show_unvailable_localisations',
      ]);
    }
  }

  changeFlavor() {
    this.trackAddInstance(['link', 'add_instance', 'change_flavor']);
    this.currentStep = 0;
  }

  changeRegion() {
    this.trackAddInstance([
      'link',
      'add_instance',
      'configure_network',
      'change_localisation',
    ]);
    this.currentStep = 1;
  }

  onImageSelected(image) {
    this.trackAddInstance([
      'tile',
      'add_instance',
      'select_image',
      image.nameGeneric,
    ]);
  }

  onImageTabChange(tab) {
    if (this.currentStep === 2) {
      this.trackAddInstance(['tab', 'add_instance', 'select_image', tab]);
    }
  }

  onEnableDhcpChange(modelValue) {
    this.trackAddInstance([
      'box',
      'add_instance',
      `${modelValue ? '' : 'de'}activate_dhcp_private_network`,
    ]);
  }

  onBillingChange(billing) {
    this.trackAddInstance([
      'tile',
      'add_instance',
      'select_billing',
      billing ? 'monthly' : 'hourly',
    ]);
  }

  onAttachPublicNetworkChange(modelValue) {
    this.trackAddInstance([
      'box',
      'add_instance',
      'configure_network',
      `${modelValue ? '' : 'de'}activate_public_network`,
    ]);
  }

  onIsLocalPrivateModeLocalZoneChange(modelValue) {
    this.trackAddInstance([
      'box',
      'add_instance',
      'configure_network',
      `${modelValue ? '' : 'de'}activate_private_network_compatible_lz`,
    ]);
  }

  shouldShowWindowsGen3Data(images) {
    const windowsFlavor = this.model.flavorGroup.getFlavorByOsType('windows');
    return (
      !!windowsFlavor &&
      this.PciProjectsProjectInstanceService.getLicensePrice(
        this.catalog,
        windowsFlavor,
        images?.[0] || this.model.image,
      ) !== null
    );
  }

  getFormattedLicensePrice(price) {
    return this.PciProjectsProjectInstanceService.formatLicensePrice(
      price * this.model.number,
    );
  }

  getLicensePriceText(distribution, images) {
    const flavor = this.model.flavorGroup.getFlavorByOsType(images[0]?.type);

    if (!flavor) return '';

    const licensePrice = this.PciProjectsProjectInstanceService.getLicensePrice(
      this.catalog,
      flavor,
      images?.[0],
    );

    if (!licensePrice) return '';

    const price = this.getFormattedLicensePrice(licensePrice);
    const unit = this.$translate.instant(
      'pci_projects_project_instances_add_windows_gen3_license_unit_w_core',
    );

    return `+ ${price} ${unit}`;
  }

  get shouldShow3AZRegionData() {
    return this.regionsTypesAvailability[THREE_AZ_REGION] && this.is3AZRegion();
  }

  onAutomatedBackupChange(modelValue) {
    if (!modelValue) {
      this.automatedBackup.schedule = null;
    }
  }

  getFormatedHourlyPrice(price) {
    return this.floatingIpPriceFormatter.format(price / 100000000);
  }
}
