/**
 * Generated by orval v7.3.0 🍺
 * Do not edit manually.
 * OVHcloud API specification
 * Specification for OVHcloud API
 * OpenAPI spec version: 1.0
 */
export type PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody = {
  /** Farm Id you want to attach to that vrack network */
  farmId: number[];
};

export type PostIpLoadbalancingServiceNameVrackNetworkBody = {
  /** Human readable name for your vrack network */
  displayName?: string;
  /** Farm Id you want to attach to that vrack network */
  farmId?: number[];
  /** An IP block used as a pool of IPs by this Load Balancer to connect to the servers in this private network. The block must be in the private network and reserved for the Load Balancer */
  natIp: IpBlockOVH;
  /** IP Block of the private network in the vRack */
  subnet: IpBlockOVH;
  /** VLAN of the private network in the vRack. 0 if the private network is not in a VLAN */
  vlan?: number;
};

export type GetIpLoadbalancingServiceNameVrackNetworkParams = {
/**
 * Filter the value of subnet property (=)
 */
subnet?: IpBlockOVH;
/**
 * Filter the value of vlan property (=)
 */
vlan?: number;
};

export type PostIpLoadbalancingServiceNameUdpFrontendBody = {
  /** Only attach frontend on these ip. No restriction if null */
  dedicatedIpfo?: IpBlockOVH[];
  /** Default UDP Farm of your frontend */
  defaultFarmId?: number;
  /** Disable your frontend. Default: 'false' */
  disabled?: boolean;
  /** Human readable name for your frontend, this field is for you */
  displayName?: string;
  /** Port(s) attached to your frontend. Supports single port (numerical value), range (2 dash-delimited increasing ports) and comma-separated list of 'single port' and/or 'range'. Each port must be in the [1;49151] range. */
  port: string;
  /** Zone of your frontend. Use "all" for all owned zone. */
  zone: string;
};

export type GetIpLoadbalancingServiceNameUdpFrontendParams = {
/**
 * Filter the value of defaultFarmId property (=)
 */
defaultFarmId?: number;
/**
 * Filter the value of port property (like)
 */
port?: string;
/**
 * Filter the value of zone property (=)
 */
zone?: string;
};

export type PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody = {
  /** Address of your server */
  address: Ipv4OVH;
  /** Human readable name for your server, this field is for you */
  displayName?: string;
  /** Port attached to your server ([1..49151]). Inherited from farm if null */
  port?: number;
  /** Enable or disable your server */
  status: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
};

export type GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams = {
/**
 * Filter the value of address property (=)
 */
address?: Ipv4OVH;
/**
 * Filter the value of status property (=)
 */
status?: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
};

export type PostIpLoadbalancingServiceNameUdpFarmBody = {
  /** Human readable name for your backend, this field is for you */
  displayName?: string;
  /** Port attached to your farm ([1..49151]). Inherited from frontend if null */
  port: number;
  /** Internal Load Balancer identifier of the vRack private network to attach to your farm, mandatory when your Load Balancer is attached to a vRack */
  vrackNetworkId?: number;
  /** Zone of your farm */
  zone: string;
};

export type GetIpLoadbalancingServiceNameUdpFarmParams = {
/**
 * Filter the value of vrackNetworkId property (=)
 */
vrackNetworkId?: number;
/**
 * Filter the value of zone property (=)
 */
zone?: string;
};

export type PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody = {
  /** Human readable name for your rule */
  displayName?: string;
  /** Name of the field to match like "protocol" or "host". See "/ipLoadbalancing/{serviceName}/availableRouteRules" for a list of available rules */
  field: string;
  /** Matching operator. Not all operators are available for all fields. See "/ipLoadbalancing/{serviceName}/availableRouteRules" */
  match: IpLoadbalancingRouteRuleMatchesEnumOVH;
  /** Invert the matching operator effect */
  negate?: boolean;
  /** Value to match against this match. Interpretation if this field depends on the match and field */
  pattern?: string;
  /** Name of sub-field, if applicable. This may be a Cookie or Header name for instance */
  subField?: string;
};

export type PostIpLoadbalancingServiceNameTcpRouteBody = {
  /** Action triggered when all rules match */
  action: IpLoadbalancingRouteTcpActionOVH;
  /** Human readable name for your route, this field is for you */
  displayName?: string;
  /** Route traffic for this frontend */
  frontendId?: number;
  /** Route priority ([0..255]). 0 if null. Highest priority routes are evaluated last. Only the first matching route will trigger an action */
  weight?: number;
};

export type GetIpLoadbalancingServiceNameTcpRouteParams = {
/**
 * Filter the value of frontendId property (=)
 */
frontendId?: number;
};

export type PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody = {
  /** Address of the frontend in the vrack. Null to disable */
  dedicatedIpfo?: IpBlockOVH[];
  /** Internal Load Balancer identifier of the vRack private network to attach to your frontend. Null to disable */
  vrackNetworkId?: number;
  /** Virtual Router Identifier. 1-255 */
  vrackVrouterId?: number;
};

export type PostIpLoadbalancingServiceNameTcpFrontendBody = {
  /** Restrict IP Load Balancing access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time */
  allowedSource?: IpBlockOVH[];
  /** Only attach frontend on these ip. No restriction if null */
  dedicatedIpfo?: IpBlockOVH[];
  /** Default TCP Farm of your frontend */
  defaultFarmId?: number;
  /** Default ssl served to your customer */
  defaultSslId?: number;
  /** Deny IP Load Balancing access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time */
  deniedSource?: IpBlockOVH[];
  /** Disable your frontend. Default: 'false' */
  disabled?: boolean;
  /** Human readable name for your frontend, this field is for you */
  displayName?: string;
  /** Port(s) attached to your frontend. Supports single port (numerical value), range (2 dash-delimited increasing ports) and comma-separated list of 'single port' and/or 'range'. Each port must be in the [1;49151] range. */
  port: string;
  /** SSL deciphering. Default: 'false' */
  ssl?: boolean;
  /** Zone of your frontend. Use "all" for all owned zone. */
  zone: string;
};

export type GetIpLoadbalancingServiceNameTcpFrontendParams = {
/**
 * Filter the value of defaultFarmId property (=)
 */
defaultFarmId?: number;
/**
 * Filter the value of defaultSslId property (=)
 */
defaultSslId?: number;
/**
 * Filter the value of port property (like)
 */
port?: string;
/**
 * Filter the value of zone property (=)
 */
zone?: string;
};

export type PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody = {
  address: IpOVH;
  slotId: number;
};

export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams = {
/**
 * Filter the value of slotId property (=)
 */
slotId?: number;
};

export type PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody = {
  /** Address of your server */
  address: Ipv4OVH;
  /** Set server as backup. Default: 'false' */
  backup?: boolean;
  /** Certificate chain. Allow server certificate verification (Avoid man-in-the-middle attacks) */
  chain?: string;
  /** Human readable name for your server, this field is for you */
  displayName?: string;
  /** Enable action when backend marked down. (No action if null) */
  onMarkedDown?: IpLoadbalancingOnMarkedDownEnumOVH;
  /** Port attached to your server ([1..49151]). Inherited from farm if null */
  port?: number;
  /** Enable/disable probe. Default: 'false' */
  probe?: boolean;
  /** Disabled if null. Send PROXY protocol header. Requires a compatible server. */
  proxyProtocolVersion?: IpLoadbalancingProxyProtocolVersionEnumOVH;
  /** SSL ciphering. Probes will also be sent ciphered. Default: 'false' */
  ssl?: boolean;
  /** Enable or disable your server */
  status: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
  /** Set weight on that server [1..256]. 0 if not used in load balancing. 1 if left null. Servers with higher weight get more requests. */
  weight?: number;
};

export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams = {
/**
 * Filter the value of address property (=)
 */
address?: Ipv4OVH;
/**
 * Filter the value of status property (=)
 */
status?: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
};

export type PostIpLoadbalancingServiceNameTcpFarmBody = {
  /** Load balancing algorithm. 'roundrobin' if null */
  balance?: IpLoadbalancingBalanceTCPEnumOVH;
  /** Human readable name for your backend, this field is for you */
  displayName?: string;
  /** Port attached to your farm ([1..49151]). Inherited from frontend if null */
  port?: number;
  /** Probe used to determine if a backend is alive and can handle requests */
  probe?: IpLoadbalancingBackendProbeOVH;
  /** Stickiness type. No stickiness if null */
  stickiness?: IpLoadbalancingStickinessTCPEnumOVH;
  /** Internal Load Balancer identifier of the vRack private network to attach to your farm, mandatory when your Load Balancer is attached to a vRack */
  vrackNetworkId?: number;
  /** Zone of your farm */
  zone: string;
};

export type GetIpLoadbalancingServiceNameTcpFarmParams = {
/**
 * Filter the value of vrackNetworkId property (=)
 */
vrackNetworkId?: number;
/**
 * Filter the value of zone property (=)
 */
zone?: string;
};

export type GetIpLoadbalancingServiceNameTaskParams = {
/**
 * Filter the value of action property (=)
 */
action?: IpLoadbalancingTaskActionEnumOVH;
/**
 * Filter the value of creationDate property (>=)
 */
'creationDate.from'?: string;
/**
 * Filter the value of creationDate property (<=)
 */
'creationDate.to'?: string;
/**
 * Filter the value of doneDate property (>=)
 */
'doneDate.from'?: string;
/**
 * Filter the value of doneDate property (<=)
 */
'doneDate.to'?: string;
/**
 * Filter the value of status property (=)
 */
status?: IpLoadbalancingTaskStatusEnumOVH;
};

export type PostIpLoadbalancingServiceNameSslBody = {
  /** Certificate */
  certificate: string;
  /** Certificate chain */
  chain?: string;
  /** Human readable name for your ssl certificate, this field is for you */
  displayName?: string;
  /** Certificate key */
  key: string;
};

export type GetIpLoadbalancingServiceNameSslParams = {
/**
 * Filter the value of expireDate property (<)
 */
expireDate?: string;
/**
 * Filter the value of fingerprint property (like)
 */
fingerprint?: string;
/**
 * Filter the value of serial property (like)
 */
serial?: string;
/**
 * Filter the value of type property (=)
 */
type?: IpLoadbalancingSslTypeEnumOVH;
};

export type PostIpLoadbalancingServiceNameRefreshBody = {
  /** The zone(s) of your iplb */
  zone?: string;
};

export type GetIpLoadbalancingServiceNameQuotaHistoryParams = {
/**
 * Filter the value of historizedDate property (>=)
 */
'historizedDate.from'?: string;
/**
 * Filter the value of historizedDate property (<=)
 */
'historizedDate.to'?: string;
/**
 * Filter the value of zone property (=)
 */
zone?: string;
};

export type PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody = {
  /** Human readable name for your rule */
  displayName?: string;
  /** Name of the field to match like "protocol" or "host". See "/ipLoadbalancing/{serviceName}/availableRouteRules" for a list of available rules */
  field: string;
  /** Matching operator. Not all operators are available for all fields. See "/ipLoadbalancing/{serviceName}/availableRouteRules" */
  match: IpLoadbalancingRouteRuleMatchesEnumOVH;
  /** Invert the matching operator effect */
  negate?: boolean;
  /** Value to match against this match. Interpretation if this field depends on the match and field */
  pattern?: string;
  /** Name of sub-field, if applicable. This may be a Cookie or Header name for instance */
  subField?: string;
};

export type PostIpLoadbalancingServiceNameHttpRouteBody = {
  /** Action triggered when all rules match */
  action: IpLoadbalancingRouteHttpActionOVH;
  /** Human readable name for your route, this field is for you */
  displayName?: string;
  /** Route traffic for this frontend */
  frontendId?: number;
  /** Route priority ([0..255]). 0 if null. Highest priority routes are evaluated last. Only the first matching route will trigger an action */
  weight?: number;
};

export type GetIpLoadbalancingServiceNameHttpRouteParams = {
/**
 * Filter the value of frontendId property (=)
 */
frontendId?: number;
};

export type PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody = {
  /** Address of the frontend in the vrack. Null to disable */
  dedicatedIpfo?: IpBlockOVH[];
  /** Internal Load Balancer identifier of the vRack private network to attach to your frontend. Null to disable */
  vrackNetworkId?: number;
  /** Virtual Router Identifier. 1-255 */
  vrackVrouterId?: number;
};

export type PostIpLoadbalancingServiceNameHttpFrontendBody = {
  /** Restrict IP Load Balancing access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time */
  allowedSource?: IpBlockOVH[];
  /** Only attach frontend on these ip. No restriction if null */
  dedicatedIpfo?: IpBlockOVH[];
  /** Default HTTP Farm of your frontend */
  defaultFarmId?: number;
  /** Default ssl served to your customer */
  defaultSslId?: number;
  /** Deny IP Load Balancing access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time */
  deniedSource?: IpBlockOVH[];
  /** Disable your frontend. Default: 'false' */
  disabled?: boolean;
  /** Human readable name for your frontend, this field is for you */
  displayName?: string;
  /** HTTP Strict Transport Security. Default: 'false' */
  hsts?: boolean;
  /** Add header to your frontend. Useful variables admitted : %ci <=> client_ip, %cp <=> client_port */
  httpHeader?: string[];
  /** Port(s) attached to your frontend. Supports single port (numerical value), range (2 dash-delimited increasing ports) and comma-separated list of 'single port' and/or 'range'. Each port must be in the [1;49151] range. */
  port: string;
  /** HTTP redirection (Ex : http://www.ovh.com) */
  redirectLocation?: string;
  /** SSL deciphering. Default: 'false' */
  ssl?: boolean;
  /** Zone of your frontend. Use "all" for all owned zone. */
  zone: string;
};

export type GetIpLoadbalancingServiceNameHttpFrontendParams = {
/**
 * Filter the value of defaultFarmId property (=)
 */
defaultFarmId?: number;
/**
 * Filter the value of defaultSslId property (=)
 */
defaultSslId?: number;
/**
 * Filter the value of port property (like)
 */
port?: string;
/**
 * Filter the value of zone property (=)
 */
zone?: string;
};

export type PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody = {
  address: IpOVH;
  slotId: number;
};

export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams = {
/**
 * Filter the value of slotId property (=)
 */
slotId?: number;
};

export type PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody = {
  /** Address of your server */
  address: Ipv4OVH;
  /** Set server as backup. Default: 'false' */
  backup?: boolean;
  /** Certificate chain. Allow server certificate verification (Avoid man-in-the-middle attacks) */
  chain?: string;
  /** Set the cookie value used when 'cookie' stickiness is set in the farm. Auto generate the cookie if none provided and required. */
  cookie?: string;
  /** Human readable name for your server, this field is for you */
  displayName?: string;
  /** Enable action when backend marked down. (No action if null) */
  onMarkedDown?: IpLoadbalancingOnMarkedDownEnumOVH;
  /** Port attached to your server ([1..49151]). Inherited from farm if null */
  port?: number;
  /** Enable/disable probe. Default: 'false' */
  probe?: boolean;
  /** Disabled if null. Send PROXY protocol header. Requires a compatible server. */
  proxyProtocolVersion?: IpLoadbalancingProxyProtocolVersionEnumOVH;
  /** SSL ciphering. Probes will also be sent ciphered. Default: 'false' */
  ssl?: boolean;
  /** Enable or disable your server */
  status: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
  /** Set weight on that server [1..256]. 0 if not used in load balancing. 1 if left null. Servers with higher weight get more requests. */
  weight?: number;
};

export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams = {
/**
 * Filter the value of address property (=)
 */
address?: Ipv4OVH;
/**
 * Filter the value of cookie property (like)
 */
cookie?: string;
/**
 * Filter the value of status property (=)
 */
status?: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
};

export type PostIpLoadbalancingServiceNameHttpFarmBody = {
  /** Load balancing algorithm. 'roundrobin' if null */
  balance?: IpLoadbalancingBalanceHTTPEnumOVH;
  /** Human readable name for your backend, this field is for you */
  displayName?: string;
  /** Port attached to your farm ([1..49151]). Inherited from frontend if null */
  port?: number;
  /** Probe used to determine if a backend is alive and can handle requests */
  probe?: IpLoadbalancingBackendProbeOVH;
  /** Stickiness type. No stickiness if null */
  stickiness?: IpLoadbalancingStickinessHTTPEnumOVH;
  /** Internal Load Balancer identifier of the vRack private network to attach to your farm, mandatory when your Load Balancer is attached to a vRack */
  vrackNetworkId?: number;
  /** Zone of your farm */
  zone: string;
};

export type GetIpLoadbalancingServiceNameHttpFarmParams = {
/**
 * Filter the value of vrackNetworkId property (=)
 */
vrackNetworkId?: number;
/**
 * Filter the value of zone property (=)
 */
zone?: string;
};

export type PostIpLoadbalancingServiceNameFreeCertificateBody = {
  /** The FQDN for which you want a free certificate. A DCV (Domain Control Validation) http request will be made to http://your_domain.abc, make sure this domain exists and resolves to your iplb ip before ordering */
  fqdn: string[];
};

export type GetIpLoadbalancingServiceNameDefinedFarmsParams = {
/**
 * The vrack network id you want to filter on
 */
vrackNetworkId?: number;
};

export type PostIpLoadbalancingServiceNameChangeContactBody = {
  /** The contact to set as admin contact */
  contactAdmin?: string;
  /** The contact to set as billing contact */
  contactBilling?: string;
  /** The contact to set as tech contact */
  contactTech?: string;
};

export type GetIpLoadbalancingParams = {
/**
 * Filter resources on IAM tags
 */
iamTags?: {[key: string]: IamResourceTagFilterOVH[]};
};

/**
 * Time (e.g., 15:04:05)
 */
export type TimeOVH = string;

/**
 * Way of handling the renew
 * @nullable
 */
export type ServicesServiceOVHRenew = ServiceRenewTypeOVH | null;

/**
 * All reasons you can provide for a service termination
 */
export type ServiceTerminationReasonEnumOVH = typeof ServiceTerminationReasonEnumOVH[keyof typeof ServiceTerminationReasonEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ServiceTerminationReasonEnumOVH = {
  FEATURES_DONT_SUIT_ME: 'FEATURES_DONT_SUIT_ME',
  LACK_OF_PERFORMANCES: 'LACK_OF_PERFORMANCES',
  MIGRATED_TO_ANOTHER_OVH_PRODUCT: 'MIGRATED_TO_ANOTHER_OVH_PRODUCT',
  MIGRATED_TO_COMPETITOR: 'MIGRATED_TO_COMPETITOR',
  NOT_ENOUGH_RECOGNITION: 'NOT_ENOUGH_RECOGNITION',
  NOT_NEEDED_ANYMORE: 'NOT_NEEDED_ANYMORE',
  NOT_RELIABLE: 'NOT_RELIABLE',
  NO_ANSWER: 'NO_ANSWER',
  OTHER: 'OTHER',
  PRODUCT_DIMENSION_DONT_SUIT_ME: 'PRODUCT_DIMENSION_DONT_SUIT_ME',
  PRODUCT_TOOLS_DONT_SUIT_ME: 'PRODUCT_TOOLS_DONT_SUIT_ME',
  TOO_EXPENSIVE: 'TOO_EXPENSIVE',
  TOO_HARD_TO_USE: 'TOO_HARD_TO_USE',
  UNSATIFIED_BY_CUSTOMER_SUPPORT: 'UNSATIFIED_BY_CUSTOMER_SUPPORT',
} as const;

/**
 * All future uses you can provide for a service termination
 */
export type ServiceTerminationFutureUseEnumOVH = typeof ServiceTerminationFutureUseEnumOVH[keyof typeof ServiceTerminationFutureUseEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ServiceTerminationFutureUseEnumOVH = {
  NOT_REPLACING_SERVICE: 'NOT_REPLACING_SERVICE',
  OTHER: 'OTHER',
  SUBSCRIBE_AN_OTHER_SERVICE: 'SUBSCRIBE_AN_OTHER_SERVICE',
  SUBSCRIBE_OTHER_KIND_OF_SERVICE_WITH_COMPETITOR: 'SUBSCRIBE_OTHER_KIND_OF_SERVICE_WITH_COMPETITOR',
  SUBSCRIBE_SIMILAR_SERVICE_WITH_COMPETITOR: 'SUBSCRIBE_SIMILAR_SERVICE_WITH_COMPETITOR',
} as const;

export type PostIpLoadbalancingServiceNameConfirmTerminationBody = {
  /** Commentary about your termination request */
  commentary?: string;
  /** What next after your termination request */
  futureUse?: ServiceTerminationFutureUseEnumOVH;
  /** Reason of your termination request */
  reason?: ServiceTerminationReasonEnumOVH;
  /** The termination token sent by email to the admin contact */
  token: string;
};

export type ServiceStateEnumOVH = typeof ServiceStateEnumOVH[keyof typeof ServiceStateEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ServiceStateEnumOVH = {
  autorenewInProgress: 'autorenewInProgress',
  expired: 'expired',
  inCreation: 'inCreation',
  ok: 'ok',
  pendingDebt: 'pendingDebt',
  unPaid: 'unPaid',
} as const;

/**
 * Detailed renewal type of a service
 */
export type ServiceRenewalTypeEnumOVH = typeof ServiceRenewalTypeEnumOVH[keyof typeof ServiceRenewalTypeEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ServiceRenewalTypeEnumOVH = {
  automaticForcedProduct: 'automaticForcedProduct',
  automaticV2012: 'automaticV2012',
  automaticV2014: 'automaticV2014',
  automaticV2016: 'automaticV2016',
  automaticV2024: 'automaticV2024',
  manual: 'manual',
  oneShot: 'oneShot',
  option: 'option',
} as const;

/**
 * Details about a Service
 */
export interface ServicesServiceOVH {
  /** Indicates that the service can be set up to be deleted at expiration */
  readonly canDeleteAtExpiration?: boolean;
  readonly contactAdmin?: string;
  readonly contactBilling?: string;
  readonly contactTech?: string;
  readonly creation?: string;
  readonly domain?: string;
  /** @nullable */
  readonly engagedUpTo?: string | null;
  readonly expiration?: string;
  /**
   * All the possible renew period of your service in month
   * @nullable
   */
  readonly possibleRenewPeriod?: readonly number[] | null;
  /**
   * Way of handling the renew
   * @nullable
   */
  renew?: ServicesServiceOVHRenew;
  readonly renewalType?: ServiceRenewalTypeEnumOVH;
  readonly serviceId?: number;
  readonly status?: ServiceStateEnumOVH;
}

/**
 * Map a possible renew for a specific service
 */
export interface ServiceRenewTypeOVH {
  /** The service is automatically renewed */
  automatic?: boolean;
  /** The service will be deleted at expiration */
  deleteAtExpiration?: boolean;
  /** The service forced to be renewed */
  forced?: boolean;
  /**
   * The service needs to be manually renewed and paid
   * @nullable
   */
  manualPayment?: boolean | null;
  /**
   * period of renew in month
   * @nullable
   */
  period?: number | null;
}

/**
 * Phone number
 */
export type PhoneNumberOVH = string;

/**
 * MAC address (e.g., 2001:4860:4860::8844)
 */
export type MacAddressOVH = string;

/**
 * IPv6 CIDR notation (e.g., 2001:41d0::/128)
 */
export type Ipv6BlockOVH = string;

/**
 * IPv6 address (e.g., 2001:41d0:1:1994::1)
 */
export type Ipv6OVH = string;

/**
 * IPv4 CIDR notation (e.g., 192.0.2.0/24)
 */
export type Ipv4BlockOVH = string;

/**
 * IPv4 address (e.g., 192.0.2.0)
 */
export type Ipv4OVH = string;

/**
 * Possible values for a Load Balancer status
 */
export type IpLoadbalancingStatusEnumOVH = typeof IpLoadbalancingStatusEnumOVH[keyof typeof IpLoadbalancingStatusEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingStatusEnumOVH = {
  error: 'error',
  ok: 'ok',
  unknown: 'unknown',
  warn: 'warn',
} as const;

/**
 * The status of a Load Balancer service
 */
export interface IpLoadbalancingStatusServiceOVH {
  /** The status of your Load Balancer billing domain */
  status?: IpLoadbalancingStatusEnumOVH;
}

/**
 * The statuses of a Load Balancer component
 */
export interface IpLoadbalancingStatusComponentStatusOVH {
  /** The number of component with status error */
  error?: number;
  /** The number of component with status ok */
  ok?: number;
  /** The number of component with status unknown */
  unknown?: number;
  /** The number of component with status warn */
  warn?: number;
}

/**
 * The global status of a Load Balancer component
 */
export interface IpLoadbalancingStatusComponentOVH {
  /** The global status of your Load Balancer component */
  status?: IpLoadbalancingStatusComponentStatusOVH;
  /** The Load Balancer total component count */
  total?: number;
}

/**
 * Frontend UDP
 */
export interface IpLoadbalancingFrontendUdpFrontendUdpOVH {
  /**
   * Only attach frontend on these ip. No restriction if null
   * @nullable
   */
  dedicatedIpfo?: IpBlockOVH[] | null;
  /**
   * Default UDP Farm of your frontend
   * @nullable
   */
  defaultFarmId?: number | null;
  /** Disable frontend. Default: 'false' */
  disabled?: boolean;
  /**
   * Human readable name for your frontend, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /** Id of your frontend */
  readonly frontendId?: number;
  /** Listening port(s) on the server */
  port?: string;
  /** Zone of you frontend */
  zone?: string;
}

/**
 * Frontend TCP
 */
export interface IpLoadbalancingFrontendTcpFrontendTcpOVH {
  /**
   * Restrict IP Load Balancing access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time
   * @nullable
   */
  allowedSource?: IpBlockOVH[] | null;
  /**
   * Only attach frontend on these ip. No restriction if null
   * @nullable
   */
  dedicatedIpfo?: IpBlockOVH[] | null;
  /**
   * Default TCP Farm of your frontend
   * @nullable
   */
  defaultFarmId?: number | null;
  /**
   * Default ssl served to your customer
   * @nullable
   */
  defaultSslId?: number | null;
  /**
   * Deny IP Load Balancing access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time
   * @nullable
   */
  deniedSource?: IpBlockOVH[] | null;
  /** Disable frontend. Default: 'false' */
  disabled?: boolean;
  /**
   * Human readable name for your frontend, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /** Id of your frontend */
  readonly frontendId?: number;
  /** Listening port(s) on the server */
  port?: string;
  /** SSL deciphering. Default: 'false' */
  ssl?: boolean;
  /**
   * Internal Load Balancer identifier of the vRack private network attached to your frontend.
   * @nullable
   */
  readonly vrackNetworkId?: number | null;
  /**
   * Virtual Router Identifier. 1-255
   * @nullable
   */
  readonly vrackVrouterId?: number | null;
  /** Zone of you frontend */
  zone?: string;
}

/**
 * Frontend HTTP
 */
export interface IpLoadbalancingFrontendHttpFrontendHttpOVH {
  /**
   * Restrict IP Load Balancing access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time
   * @nullable
   */
  allowedSource?: IpBlockOVH[] | null;
  /**
   * Only attach frontend on these ip. No restriction if null
   * @nullable
   */
  dedicatedIpfo?: IpBlockOVH[] | null;
  /**
   * Default HTTP Farm of your frontend
   * @nullable
   */
  defaultFarmId?: number | null;
  /**
   * Default ssl served to your customer
   * @nullable
   */
  defaultSslId?: number | null;
  /**
   * Deny IP Load Balancing access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time
   * @nullable
   */
  deniedSource?: IpBlockOVH[] | null;
  /** Disable frontend. Default: 'false' */
  disabled?: boolean;
  /**
   * Human readable name for your frontend, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /** Id of your frontend */
  readonly frontendId?: number;
  /** HTTP Strict Transport Security. Default: 'false' */
  hsts?: boolean;
  /**
   * Add header to your frontend. Useful variables admitted : %ci <=> client_ip, %cp <=> client_port
   * @nullable
   */
  httpHeader?: string[] | null;
  /** Listening port(s) on the server */
  port?: string;
  /**
   * HTTP redirection (Ex : http://www.ovh.com)
   * @nullable
   */
  redirectLocation?: string | null;
  /** SSL deciphering. Default: 'false' */
  ssl?: boolean;
  /**
   * Internal Load Balancer identifier of the vRack private network attached to your frontend.
   * @nullable
   */
  readonly vrackNetworkId?: number | null;
  /**
   * Virtual Router Identifier. 1-255
   * @nullable
   */
  readonly vrackVrouterId?: number | null;
  /** Zone of you frontend */
  zone?: string;
}

/**
 * UDP Farm's Server
 */
export interface IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH {
  /** Address of your server */
  readonly address?: Ipv4OVH;
  /** farm id */
  readonly backendId?: number;
  /**
   * Human readable name for your server, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /**
   * Port attached to your server. Inherited from farm if null
   * @nullable
   */
  port?: number | null;
  /** Id of your server */
  readonly serverId?: number;
  /** Status attached to your server */
  status?: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
}

/**
 * UDP Farm
 */
export interface IpLoadbalancingBackendUdpBackendUdpOVH {
  /**
   * Human readable name for your backend, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /** Id of your farm */
  readonly farmId?: number;
  /** Port attached to your farm. Inherited from frontend if null */
  port?: number;
  /**
   * Internal Load Balancer identifier of the vRack private network attached to your farm, mandatory when your Load Balancer is attached to a vRack
   * @nullable
   */
  vrackNetworkId?: number | null;
  /** Zone of you farm */
  readonly zone?: string;
}

/**
 * Disabled if null. Send PROXY protocol header. Requires a compatible server.
 * @nullable
 */
export type IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVHProxyProtocolVersion = IpLoadbalancingProxyProtocolVersionEnumOVH | null;

/**
 * Set action when backend marked down. (No action if null)
 * @nullable
 */
export type IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVHOnMarkedDown = IpLoadbalancingOnMarkedDownEnumOVH | null;

/**
 * TCP Farm's Server
 */
export interface IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH {
  /** Address of your server */
  readonly address?: Ipv4OVH;
  /** Farm id */
  readonly backendId?: number;
  /** Backup state. Default: 'false' */
  backup?: boolean;
  /**
   * Certificate chain. Allow server certificate verification (Avoid man-in-the-middle attacks)
   * @nullable
   */
  chain?: string | null;
  /**
   * Human readable name for your server, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /**
   * Set action when backend marked down. (No action if null)
   * @nullable
   */
  onMarkedDown?: IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVHOnMarkedDown;
  /**
   * Port attached to your server. Inherited from farm if null
   * @nullable
   */
  port?: number | null;
  /** Probe state. Default: 'false' */
  probe?: boolean;
  /**
   * Disabled if null. Send PROXY protocol header. Requires a compatible server.
   * @nullable
   */
  proxyProtocolVersion?: IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVHProxyProtocolVersion;
  /** Id of your server */
  readonly serverId?: number;
  /** Server state */
  readonly serverState?: readonly IpLoadbalancingServerStateOVH[];
  /** SSL ciphering. Probes will also be sent ciphered */
  ssl?: boolean;
  /** Status attached to your server */
  status?: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
  /**
   * Weight value. Defaults to 1. 0 if not used in load balancing. Servers with higher weight get more requests.
   * @nullable
   */
  weight?: number | null;
}

/**
 * Stickiness type. No stickiness if null
 * @nullable
 */
export type IpLoadbalancingBackendTcpBackendTcpOVHStickiness = IpLoadbalancingStickinessTCPEnumOVH | null;

/**
 * Probe used to determine if a backend is alive and can handle requests. Defaults to tcp on the same port as the farm
 * @nullable
 */
export type IpLoadbalancingBackendTcpBackendTcpOVHProbe = IpLoadbalancingBackendProbeOVH | null;

/**
 * Load balancing algorithm. 'roundrobin' if null
 * @nullable
 */
export type IpLoadbalancingBackendTcpBackendTcpOVHBalance = IpLoadbalancingBalanceTCPEnumOVH | null;

/**
 * TCP Farm
 */
export interface IpLoadbalancingBackendTcpBackendTcpOVH {
  /**
   * Load balancing algorithm. 'roundrobin' if null
   * @nullable
   */
  balance?: IpLoadbalancingBackendTcpBackendTcpOVHBalance;
  /**
   * Human readable name for your backend, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /** Id of your farm */
  readonly farmId?: number;
  /**
   * Port attached to your farm. Inherited from frontend if null
   * @nullable
   */
  port?: number | null;
  /**
   * Probe used to determine if a backend is alive and can handle requests. Defaults to tcp on the same port as the farm
   * @nullable
   */
  probe?: IpLoadbalancingBackendTcpBackendTcpOVHProbe;
  /**
   * Stickiness type. No stickiness if null
   * @nullable
   */
  stickiness?: IpLoadbalancingBackendTcpBackendTcpOVHStickiness;
  /**
   * Internal Load Balancer identifier of the vRack private network attached to your farm, mandatory when your Load Balancer is attached to a vRack
   * @nullable
   */
  vrackNetworkId?: number | null;
  /** Zone of you farm */
  readonly zone?: string;
}

/**
 * Disabled if null. Send PROXY protocol header. Requires a compatible server.
 * @nullable
 */
export type IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVHProxyProtocolVersion = IpLoadbalancingProxyProtocolVersionEnumOVH | null;

/**
 * Set action when backend marked down. (No action if null)
 * @nullable
 */
export type IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVHOnMarkedDown = IpLoadbalancingOnMarkedDownEnumOVH | null;

/**
 * Stickiness type. No stickiness if null
 * @nullable
 */
export type IpLoadbalancingBackendHttpBackendHttpOVHStickiness = IpLoadbalancingStickinessHTTPEnumOVH | null;

/**
 * Probe used to determine if a backend is alive and can handle requests. Defaults to tcp on the same port as the farm
 * @nullable
 */
export type IpLoadbalancingBackendHttpBackendHttpOVHProbe = IpLoadbalancingBackendProbeOVH | null;

/**
 * Load balancing algorithm. 'roundrobin' if null
 * @nullable
 */
export type IpLoadbalancingBackendHttpBackendHttpOVHBalance = IpLoadbalancingBalanceHTTPEnumOVH | null;

/**
 * HTTP Farm
 */
export interface IpLoadbalancingBackendHttpBackendHttpOVH {
  /**
   * Load balancing algorithm. 'roundrobin' if null
   * @nullable
   */
  balance?: IpLoadbalancingBackendHttpBackendHttpOVHBalance;
  /**
   * Human readable name for your backend, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /** Id of your farm */
  readonly farmId?: number;
  /**
   * Port attached to your farm. Inherited from frontend if null
   * @nullable
   */
  port?: number | null;
  /**
   * Probe used to determine if a backend is alive and can handle requests. Defaults to tcp on the same port as the farm
   * @nullable
   */
  probe?: IpLoadbalancingBackendHttpBackendHttpOVHProbe;
  /**
   * Stickiness type. No stickiness if null
   * @nullable
   */
  stickiness?: IpLoadbalancingBackendHttpBackendHttpOVHStickiness;
  /**
   * Internal Load Balancer identifier of the vRack private network attached to your farm, mandatory when your Load Balancer is attached to a vRack
   * @nullable
   */
  vrackNetworkId?: number | null;
  /** Zone of you farm */
  readonly zone?: string;
}

/**
 * IP Load Balancing Zone
 */
export interface IpLoadbalancingZoneZoneOVH {
  /** Name of your zone */
  readonly name?: string;
  /** State of your zone */
  readonly state?: string;
}

/**
 * Server's vrack transparent ip
 */
export interface IpLoadbalancingVrackTransparentIpVrackTransparentIpOVH {
  readonly address?: IpOVH;
  readonly farmId?: number;
  readonly id?: number;
  readonly serverId?: number;
  readonly slotId?: number;
}

/**
 * Aims to help you configure needed transparent interfaces
 */
export interface IpLoadbalancingVrackTransparentGatewaysOVH {
  /** address */
  address?: IpOVH;
  /** gateway */
  gateway?: IpOVH;
  /** vlan */
  vlan?: number;
}

/**
 * Possible values for load balancing vRack state
 */
export type IpLoadbalancingVrackStateEnumOVH = typeof IpLoadbalancingVrackStateEnumOVH[keyof typeof IpLoadbalancingVrackStateEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingVrackStateEnumOVH = {
  activating: 'activating',
  active: 'active',
  deactivating: 'deactivating',
  inactive: 'inactive',
} as const;

/**
 * Rules to create a new description of a private network in the vRack
 */
export interface IpLoadbalancingVrackNetworkCreationRulesOVH {
  /** Minimum number of IPs needed to forward requests to your servers using NAT in your private network behind the current Load Balancer. Ip Block given on Load Balancer vRack network must contain at least this number of IP. */
  minNatIps?: number;
  /** Number of remaining private network descriptions available for creation for this Load Balancer */
  remainingNetworks?: number;
  /** Name of the vRack on which the current Load Balancer is attached to, as it is named on vRack product */
  vrackName?: string;
}

/**
 * Represents a private network in the vRack
 */
export interface IpLoadbalancingVrackNetworkVrackNetworkOVH {
  /**
   * Human readable name for your vrack network
   * @nullable
   */
  displayName?: string | null;
  /** Farm Id your vrack network is attached to and their type */
  readonly farmId?: readonly IpLoadbalancingDefinedFarmOVH[];
  /** An IP block used as a pool of IPs by this Load Balancer to connect to the servers in this private network. The block must be in the private network and reserved for the Load Balancer */
  natIp?: IpBlockOVH;
  /** IP block of the private network in the vRack */
  readonly subnet?: IpBlockOVH;
  /** VLAN of the private network in the vRack. 0 if the private network is not in a VLAN */
  vlan?: number;
  /** Internal Load Balancer identifier of the vRack private network description */
  readonly vrackNetworkId?: number;
}

/**
 * Information about vRack for your Load Balancer
 */
export interface IpLoadbalancingVrackInformationOVH {
  /** State of the vRack link to your Load Balancer */
  state?: IpLoadbalancingVrackStateEnumOVH;
  /** Ongoing task related to vRack installation or uninstallation on your Load Balancer */
  task?: number[];
  /**
   * Name of the vRack on which the current Load Balancer is attached to, as it is named on vRack product
   * @nullable
   */
  vrackName?: string | null;
}

/**
 * Possible task status
 */
export type IpLoadbalancingTaskStatusEnumOVH = typeof IpLoadbalancingTaskStatusEnumOVH[keyof typeof IpLoadbalancingTaskStatusEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingTaskStatusEnumOVH = {
  blocked: 'blocked',
  cancelled: 'cancelled',
  doing: 'doing',
  done: 'done',
  error: 'error',
  todo: 'todo',
} as const;

/**
 * Possible task action
 */
export type IpLoadbalancingTaskActionEnumOVH = typeof IpLoadbalancingTaskActionEnumOVH[keyof typeof IpLoadbalancingTaskActionEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingTaskActionEnumOVH = {
  deleteIplb: 'deleteIplb',
  deployIplb: 'deployIplb',
  install: 'install',
  installIplb: 'installIplb',
  installZone: 'installZone',
  orderFreeCertificate: 'orderFreeCertificate',
  orderPaidCertificate: 'orderPaidCertificate',
  orderSsl: 'orderSsl',
  refreshIplb: 'refreshIplb',
  releaseIplb: 'releaseIplb',
  releaseIplbZone: 'releaseIplbZone',
  reopenIplb: 'reopenIplb',
  suspendIplb: 'suspendIplb',
  suspendZone: 'suspendZone',
  switchToIplbNextGenerationApi: 'switchToIplbNextGenerationApi',
  vrackAttach: 'vrackAttach',
  vrackDetach: 'vrackDetach',
} as const;

/**
 * IP Load Balancing Operations
 */
export interface IpLoadbalancingTaskTaskOVH {
  /** Operation type */
  readonly action?: IpLoadbalancingTaskActionEnumOVH;
  /** Creation date of your operation */
  readonly creationDate?: string;
  /**
   * Done date of your operation
   * @nullable
   */
  readonly doneDate?: string | null;
  /** Id of the operation */
  readonly id?: number;
  /** Operation progress percentage */
  readonly progress?: number;
  /** Current status of your operation */
  readonly status?: IpLoadbalancingTaskStatusEnumOVH;
  /** Zone of your Load Balancer which are updated by current Task */
  readonly zones?: readonly string[];
}

/**
 * Possible values for TCP backend stickiness
 */
export type IpLoadbalancingStickinessTCPEnumOVH = typeof IpLoadbalancingStickinessTCPEnumOVH[keyof typeof IpLoadbalancingStickinessTCPEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingStickinessTCPEnumOVH = {
  sourceIp: 'sourceIp',
} as const;

/**
 * Possible values for HTTP backend stickiness
 */
export type IpLoadbalancingStickinessHTTPEnumOVH = typeof IpLoadbalancingStickinessHTTPEnumOVH[keyof typeof IpLoadbalancingStickinessHTTPEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingStickinessHTTPEnumOVH = {
  cookie: 'cookie',
  sourceIp: 'sourceIp',
} as const;

/**
 * The global status of a Load Balancer
 */
export interface IpLoadbalancingStatusOVH {
  /** The Load Balancer farms status informations */
  farms?: IpLoadbalancingStatusComponentOVH;
  /** The Load Balancer frontends status informations */
  frontends?: IpLoadbalancingStatusComponentOVH;
  /** The Load Balancer servers status informations */
  servers?: IpLoadbalancingStatusComponentOVH;
  /** The Load Balancer service status informations */
  service?: IpLoadbalancingStatusServiceOVH;
}

/**
 * Possible values for ssl type
 */
export type IpLoadbalancingSslTypeEnumOVH = typeof IpLoadbalancingSslTypeEnumOVH[keyof typeof IpLoadbalancingSslTypeEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingSslTypeEnumOVH = {
  built: 'built',
  built_not_routed: 'built_not_routed',
  custom: 'custom',
} as const;

/**
 * Possible values for ssl ciphers
 */
export type IpLoadbalancingSslConfigurationEnumOVH = typeof IpLoadbalancingSslConfigurationEnumOVH[keyof typeof IpLoadbalancingSslConfigurationEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingSslConfigurationEnumOVH = {
  intermediate: 'intermediate',
  modern: 'modern',
} as const;

/**
 * Type of your SSL certificate.
'built' for SSL certificates managed by the IP Load Balancing. 'custom' for user manager certificates.
 * @nullable
 */
export type IpLoadbalancingSslSslOVHType = IpLoadbalancingSslTypeEnumOVH | null;

/**
 * Ssl
 */
export interface IpLoadbalancingSslSslOVH {
  /**
   * Human readable name for your ssl certificate, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /** Expire date of your SSL certificate */
  readonly expireDate?: string;
  /** Fingerprint of your SSL certificate */
  readonly fingerprint?: string;
  /** Id of your SSL certificate */
  readonly id?: number;
  /** Subject Alternative Name of your SSL certificate */
  readonly san?: readonly string[];
  /** Serial of your SSL certificate (Deprecated, use fingerprint instead !) */
  readonly serial?: string;
  /** Subject of your SSL certificate */
  readonly subject?: string;
  /**
   * Type of your SSL certificate.
'built' for SSL certificates managed by the IP Load Balancing. 'custom' for user manager certificates.
   * @nullable
   */
  readonly type?: IpLoadbalancingSslSslOVHType;
}

/**
 * Available servers states
 */
export interface IpLoadbalancingServerStateOVH {
  /**
   * Layer5-7 code, if available
   * @nullable
   */
  checkCode?: string | null;
  /**
   * Status of last health check
   * @nullable
   */
  checkStatus?: string | null;
  /**
   * Time of last health check
   * @nullable
   */
  checkTime?: string | null;
  /** Id of your instance */
  instanceId?: number;
  /**
   * Last health check contents or textual error
   * @nullable
   */
  lastCheckContent?: string | null;
  /**
   * Status
   * @nullable
   */
  status?: string | null;
}

/**
 * Action triggered when all rules from route match
 */
export interface IpLoadbalancingRouteTcpActionOVH {
  /**
   * Farm ID for "farm" action type, empty for others
   * @nullable
   */
  target?: string | null;
  /** Action to trigger if all the rules of this route matches */
  type?: string;
}

/**
 * Route configuration status
 */
export type IpLoadbalancingRouteStatusEnumOVH = typeof IpLoadbalancingRouteStatusEnumOVH[keyof typeof IpLoadbalancingRouteStatusEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingRouteStatusEnumOVH = {
  creating: 'creating',
  deleting: 'deleting',
  internal: 'internal',
  ok: 'ok',
  updating: 'updating',
} as const;

/**
 * List of possible route rule matches
 */
export type IpLoadbalancingRouteRuleMatchesEnumOVH = typeof IpLoadbalancingRouteRuleMatchesEnumOVH[keyof typeof IpLoadbalancingRouteRuleMatchesEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingRouteRuleMatchesEnumOVH = {
  contains: 'contains',
  endswith: 'endswith',
  exists: 'exists',
  in: 'in',
  internal: 'internal',
  is: 'is',
  matches: 'matches',
  startswith: 'startswith',
} as const;

/**
 * Rule of a route
 */
export interface IpLoadbalancingRouteRuleRouteRuleOVH {
  /**
   * Human readable name for your rule
   * @nullable
   */
  displayName?: string | null;
  /** Name of the field to match like "protocol" or "host". See "/ipLoadbalancing/{serviceName}/availableRouteRules" for a list of available rules */
  field?: string;
  /** Matching operator. Not all operators are available for all fields. See "/ipLoadbalancing/{serviceName}/availableRouteRules" */
  match?: IpLoadbalancingRouteRuleMatchesEnumOVH;
  /** Invert the matching operator effect */
  negate?: boolean;
  /**
   * Value to match against this match. Interpretation if this field depends on the match and field
   * @nullable
   */
  pattern?: string | null;
  /** Id of your rule */
  readonly ruleId?: number;
  /**
   * Name of sub-field, if applicable. This may be a Cookie or Header name for instance
   * @nullable
   */
  subField?: string | null;
}

/**
 * Match rule to combine to build routes
 */
export interface IpLoadbalancingRouteRuleOVH {
  /** Name of the field to match like "protocol" or "host". See "/ipLoadbalancing/{serviceName}/route/availableRules" for a list of available rules */
  field?: string;
  /** Matching operator. Not all operators are available for all fields. See "/availableRules" */
  match?: IpLoadbalancingRouteRuleMatchesEnumOVH;
  /** Invert the matching operator effect */
  negate?: boolean;
  /**
   * Value to match against this match. Interpretation if this field depends on the match and field
   * @nullable
   */
  pattern?: string | null;
  /** Id of your rule */
  ruleId?: number;
  /**
   * Name of sub-field, if applicable. This may be a Cookie or Header name for instance
   * @nullable
   */
  subField?: string | null;
}

/**
 * TCP Route
 */
export interface IpLoadbalancingRouteTcpRouteTcpOVH {
  /** Action triggered when all rules match */
  action?: IpLoadbalancingRouteTcpActionOVH;
  /**
   * Human readable name for your route, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /**
   * Route traffic for this frontend
   * @nullable
   */
  frontendId?: number | null;
  /** Id of your route */
  readonly routeId?: number;
  /** List of rules to match to trigger action */
  readonly rules?: readonly IpLoadbalancingRouteRuleOVH[];
  /** Route status. Routes in "ok" state are ready to operate */
  readonly status?: IpLoadbalancingRouteStatusEnumOVH;
  /** Route priority ([0..255]). 0 if null. Highest priority routes are evaluated last. Only the first matching route will trigger an action */
  weight?: number;
}

/**
 * Action triggered when all rules from route match
 */
export interface IpLoadbalancingRouteHttpActionOVH {
  /**
   * HTTP status code for "redirect" and "reject" actions
   * @nullable
   */
  status?: number | null;
  /**
   * Farm ID for "farm" action type or URL template for "redirect" action. You may use ${uri}, ${protocol}, ${host}, ${port} and ${path} variables in redirect target
   * @nullable
   */
  target?: string | null;
  /** Action to trigger if all the rules of this route matches */
  type?: string;
}

/**
 * HTTP Route
 */
export interface IpLoadbalancingRouteHttpRouteHttpOVH {
  /** Action triggered when all rules match */
  action?: IpLoadbalancingRouteHttpActionOVH;
  /**
   * Human readable name for your route, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /**
   * Route traffic for this frontend
   * @nullable
   */
  frontendId?: number | null;
  /** Id of your route */
  readonly routeId?: number;
  /** List of rules to match to trigger action */
  readonly rules?: readonly IpLoadbalancingRouteRuleOVH[];
  /** Route status. Routes in "ok" state are ready to operate */
  readonly status?: IpLoadbalancingRouteStatusEnumOVH;
  /** Route priority ([0..255]). 0 if null. Highest priority routes are evaluated last. Only the first matching route will trigger an action */
  weight?: number;
}

/**
 * Match rule to combine to build routes
 */
export interface IpLoadbalancingRouteAvailableRuleOVH {
  /**
   * If pattern is "enum", list of available options
   * @nullable
   */
  enum?: string[] | null;
  /** If true, this rule needs a subfield. Typically a cookie or header name */
  hasSubField?: boolean;
  /** List of match operators compatible with this rule */
  matches?: string[];
  /** Rule name */
  name?: string;
  /** Expected type for the pattern. Like "enum", "backend", "cidr", ... */
  pattern?: string;
  /** Protocol supported by this action */
  type?: string;
}

/**
 * Available route actions options
 */
export interface IpLoadbalancingRouteAvailableActionOVH {
  /**
   * Type of the destination for this action
   * @nullable
   */
  destination?: string | null;
  /** Action name */
  name?: string;
  /**
   * List of available HTTP status code if applicable
   * @nullable
   */
  status?: number[] | null;
  /** Protocol supported by this action */
  type?: string;
}

/**
 * QuotaHistory
 */
export interface IpLoadbalancingQuotaHistoryQuotaHistoryOVH {
  /** Historized date for this quota entry */
  readonly historizedDate?: string;
  /** Id of your quota */
  readonly id?: number;
  /** The last time your quota was updated from your Load Balancer instance */
  readonly lastUpdateDate?: string;
  /** The last time your quota was resetted (billed) */
  readonly resetDate?: string;
  /** Total used quota value in bytes */
  readonly total?: number;
  /** Zone of your quota */
  readonly zone?: string;
}

/**
 * Quota informations for current billing period for this zone
 */
export interface IpLoadbalancingQuotaQuotaOVH {
  /**
   * Quota alert value in bytes. When reached, we will send you an alert. Default : included quota with your offer
   * @nullable
   */
  alert?: number | null;
  /**
   * Included quota value with your offer, in bytes
   * @nullable
   */
  readonly included?: number | null;
  /**
   * The last time your quota was updated from your Load Balancer instance
   * @nullable
   */
  readonly lastUpdateDate?: string | null;
  /**
   * The last time your quota was resetted (billed)
   * @nullable
   */
  readonly resetDate?: string | null;
  /**
   * Total used quota value in bytes
   * @nullable
   */
  readonly total?: number | null;
  /** Zone of your quota */
  readonly zone?: string;
}

/**
 * Possible values for proxy type
 */
export type IpLoadbalancingProxyTypeEnumOVH = typeof IpLoadbalancingProxyTypeEnumOVH[keyof typeof IpLoadbalancingProxyTypeEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingProxyTypeEnumOVH = {
  http: 'http',
  tcp: 'tcp',
} as const;

/**
 * Possible values for proxy type
 */
export type IpLoadbalancingProxyProtocolVersionEnumOVH = typeof IpLoadbalancingProxyProtocolVersionEnumOVH[keyof typeof IpLoadbalancingProxyProtocolVersionEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingProxyProtocolVersionEnumOVH = {
  v1: 'v1',
  v2: 'v2',
  'v2-ssl': 'v2-ssl',
  'v2-ssl-cn': 'v2-ssl-cn',
} as const;

/**
 * Possible values for farm probe
 */
export type IpLoadbalancingProbeTypeEnumOVH = typeof IpLoadbalancingProbeTypeEnumOVH[keyof typeof IpLoadbalancingProbeTypeEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingProbeTypeEnumOVH = {
  http: 'http',
  internal: 'internal',
  mysql: 'mysql',
  oco: 'oco',
  pgsql: 'pgsql',
  smtp: 'smtp',
  tcp: 'tcp',
} as const;

/**
 * List of possible method for HTTP probes. Consider using HEAD to save bandwidth when possible.
 */
export type IpLoadbalancingProbeMethodEnumOVH = typeof IpLoadbalancingProbeMethodEnumOVH[keyof typeof IpLoadbalancingProbeMethodEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingProbeMethodEnumOVH = {
  GET: 'GET',
  HEAD: 'HEAD',
  OPTIONS: 'OPTIONS',
  internal: 'internal',
} as const;

/**
 * List of possible probe result matches. "status" is only supported for HTTP probes
 */
export type IpLoadbalancingProbeExpectMatchEnumOVH = typeof IpLoadbalancingProbeExpectMatchEnumOVH[keyof typeof IpLoadbalancingProbeExpectMatchEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingProbeExpectMatchEnumOVH = {
  contains: 'contains',
  default: 'default',
  internal: 'internal',
  matches: 'matches',
  status: 'status',
} as const;

/**
 * The pending changes for a Load Balancer zone
 */
export interface IpLoadbalancingPendingChangesOVH {
  /** The number of changes waiting to be applied */
  number?: number;
  /** The Load Balancer zone with pending changes */
  zone?: string;
}

/**
 * Available additional zone to order for a Load Balancer
 */
export interface IpLoadbalancingOrderableZoneOVH {
  /** The zone three letter code */
  name?: string;
  /** The billing planCode for this zone */
  planCode?: string;
}

/**
 * Possible values for OnMarkedDown type
 */
export type IpLoadbalancingOnMarkedDownEnumOVH = typeof IpLoadbalancingOnMarkedDownEnumOVH[keyof typeof IpLoadbalancingOnMarkedDownEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingOnMarkedDownEnumOVH = {
  'shutdown-sessions': 'shutdown-sessions',
} as const;

/**
 * a list of {zone, nat Ip}
 */
export interface IpLoadbalancingNatIpsOVH {
  ip?: IpBlockOVH[];
  zone?: string;
}

/**
 * The metrics token of a Load Balancer
 */
export interface IpLoadbalancingMetricsTokenOVH {
  /** The metrics endpoint */
  endpoint?: string;
  /** The metrics token */
  token?: string;
}

/**
 * Modern oldest compatible clients : Firefox 27, Chrome 30, IE 11 on Windows 7, Edge, Opera 17, Safari 9, Android 5.0, and Java 8. Intermediate oldest compatible clients : Firefox 1, Chrome 1, IE 7, Opera 5, Safari 1, Windows XP IE8, Android 2.3, Java 7. Intermediate if null.
 * @nullable
 */
export type IpLoadbalancingIpWithIAMOVHSslConfiguration = IpLoadbalancingSslConfigurationEnumOVH | null;

/**
 * The IPV6 associated to your IP load balancing
 * @nullable
 */
export type IpLoadbalancingIpWithIAMOVHIpv6 = Ipv6OVH | null;

/**
 * The IPV4 associated to your IP load balancing
 * @nullable
 */
export type IpLoadbalancingIpWithIAMOVHIpv4 = Ipv4OVH | null;

/**
 * IAM resource metadata
 * @nullable
 */
export type IpLoadbalancingIpWithIAMOVHIam = IamResourceMetadataOVH | null;

/**
 * Possible values for load balancing IP state
 */
export type IpLoadbalancingIpStateEnumOVH = typeof IpLoadbalancingIpStateEnumOVH[keyof typeof IpLoadbalancingIpStateEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingIpStateEnumOVH = {
  blacklisted: 'blacklisted',
  deleted: 'deleted',
  free: 'free',
  ok: 'ok',
  quarantined: 'quarantined',
  suspended: 'suspended',
} as const;

/**
 * Your IP load balancing
 */
export interface IpLoadbalancingIpWithIAMOVH {
  /**
   * Set the name displayed in ManagerV6 for your iplb (max 50 chars)
   * @nullable
   */
  displayName?: string | null;
  /**
   * IAM resource metadata
   * @nullable
   */
  readonly iam?: IpLoadbalancingIpWithIAMOVHIam;
  /** Your IP load balancing */
  readonly ipLoadbalancing?: IpOVH;
  /**
   * The IPV4 associated to your IP load balancing
   * @nullable
   */
  readonly ipv4?: IpLoadbalancingIpWithIAMOVHIpv4;
  /**
   * The IPV6 associated to your IP load balancing
   * @nullable
   */
  readonly ipv6?: IpLoadbalancingIpWithIAMOVHIpv6;
  /**
   * The metrics token associated with your IP load balancing
   * @nullable
   */
  readonly metricsToken?: string | null;
  /** The offer of your IP load balancing */
  readonly offer?: string;
  /** Available additional zone for your Load Balancer */
  readonly orderableZone?: readonly IpLoadbalancingOrderableZoneOVH[];
  /** The internal name of your IP load balancing */
  readonly serviceName?: string;
  /**
   * Modern oldest compatible clients : Firefox 27, Chrome 30, IE 11 on Windows 7, Edge, Opera 17, Safari 9, Android 5.0, and Java 8. Intermediate oldest compatible clients : Firefox 1, Chrome 1, IE 7, Opera 5, Safari 1, Windows XP IE8, Android 2.3, Java 7. Intermediate if null.
   * @nullable
   */
  sslConfiguration?: IpLoadbalancingIpWithIAMOVHSslConfiguration;
  /** Current state of your IP */
  readonly state?: IpLoadbalancingIpStateEnumOVH;
  /** Vrack eligibility */
  readonly vrackEligibility?: boolean;
  /**
   * Name of the vRack on which the current Load Balancer is attached to, as it is named on vRack product
   * @nullable
   */
  readonly vrackName?: string | null;
  /** Location where your service is */
  readonly zone?: readonly string[];
}

/**
 * Modern oldest compatible clients : Firefox 27, Chrome 30, IE 11 on Windows 7, Edge, Opera 17, Safari 9, Android 5.0, and Java 8. Intermediate oldest compatible clients : Firefox 1, Chrome 1, IE 7, Opera 5, Safari 1, Windows XP IE8, Android 2.3, Java 7. Intermediate if null.
 * @nullable
 */
export type IpLoadbalancingIpOVHSslConfiguration = IpLoadbalancingSslConfigurationEnumOVH | null;

/**
 * The IPV6 associated to your IP load balancing
 * @nullable
 */
export type IpLoadbalancingIpOVHIpv6 = Ipv6OVH | null;

/**
 * The IPV4 associated to your IP load balancing
 * @nullable
 */
export type IpLoadbalancingIpOVHIpv4 = Ipv4OVH | null;

/**
 * Your IP load balancing
 */
export interface IpLoadbalancingIpOVH {
  /**
   * Set the name displayed in ManagerV6 for your iplb (max 50 chars)
   * @nullable
   */
  displayName?: string | null;
  /** Your IP load balancing */
  readonly ipLoadbalancing?: IpOVH;
  /**
   * The IPV4 associated to your IP load balancing
   * @nullable
   */
  readonly ipv4?: IpLoadbalancingIpOVHIpv4;
  /**
   * The IPV6 associated to your IP load balancing
   * @nullable
   */
  readonly ipv6?: IpLoadbalancingIpOVHIpv6;
  /**
   * The metrics token associated with your IP load balancing
   * @nullable
   */
  readonly metricsToken?: string | null;
  /** The offer of your IP load balancing */
  readonly offer?: string;
  /** Available additional zone for your Load Balancer */
  readonly orderableZone?: readonly IpLoadbalancingOrderableZoneOVH[];
  /** The internal name of your IP load balancing */
  readonly serviceName?: string;
  /**
   * Modern oldest compatible clients : Firefox 27, Chrome 30, IE 11 on Windows 7, Edge, Opera 17, Safari 9, Android 5.0, and Java 8. Intermediate oldest compatible clients : Firefox 1, Chrome 1, IE 7, Opera 5, Safari 1, Windows XP IE8, Android 2.3, Java 7. Intermediate if null.
   * @nullable
   */
  sslConfiguration?: IpLoadbalancingIpOVHSslConfiguration;
  /** Current state of your IP */
  readonly state?: IpLoadbalancingIpStateEnumOVH;
  /** Vrack eligibility */
  readonly vrackEligibility?: boolean;
  /**
   * Name of the vRack on which the current Load Balancer is attached to, as it is named on vRack product
   * @nullable
   */
  readonly vrackName?: string | null;
  /** Location where your service is */
  readonly zone?: readonly string[];
}

/**
 * A structure describing the current state of an IPLB instances
 */
export interface IpLoadbalancingInstancesStateOVH {
  /** Internal ID of this IPLB instance */
  internalId?: number;
  /** Last update date */
  lastUpdateDate?: string;
  /** Current state of this IPLB instance */
  state?: string;
  /** zone of this IPLB instance */
  zone?: string;
}

/**
 * Frontend
 */
export interface IpLoadbalancingFrontendFrontendOVH {
  /**
   * Restrict iplb access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time
   * @nullable
   */
  allowedSource?: IpBlockOVH[] | null;
  /**
   * Only attach frontend on these ip. No restriction if null
   * @nullable
   */
  dedicatedIpfo?: IpBlockOVH[] | null;
  /**
   * Default Backend of your frontend
   * @nullable
   */
  readonly defaultBackendId?: number | null;
  /**
   * Default ssl served to your customer
   * @nullable
   */
  defaultSslId?: number | null;
  /**
   * Deny iplb access to these ip block. No restriction if null. You cannot specify allowedSource and deniedSource both at the same time
   * @nullable
   */
  deniedSource?: IpBlockOVH[] | null;
  /** Disable frontend. Default: 'false' */
  disabled?: boolean;
  /** HTTP Strict Transport Security. Default: 'false' */
  hsts?: boolean;
  /**
   * Add header to your frontend. Useful variables admitted : %ci <=> client_ip, %cp <=> client_port
   * @nullable
   */
  httpHeader?: string[] | null;
  /** Id of your frontend */
  readonly id?: number;
  /** Port(s) attached to your frontend */
  readonly port?: string;
  /**
   * HTTP redirection (Ex : http://www.ovh.com)
   * @nullable
   */
  readonly redirectLocation?: string | null;
  /** SSL deciphering. Default: 'false' */
  ssl?: boolean;
  /** Type of your frontend */
  readonly type?: IpLoadbalancingProxyTypeEnumOVH;
  /** Zone of you frontend */
  readonly zone?: string;
}

/**
 * Available farm probes options
 */
export interface IpLoadbalancingFarmAvailableProbeOVH {
  /** List of possible probe result checkers for this type of probe */
  matches?: string[];
  /**
   * List of available HTTP method, if available
   * @nullable
   */
  method?: string[] | null;
  /** List of matches operators that accept the negate option for this type of probe */
  negatableMatches?: string[];
  /** True is this probe type supports a custom port */
  port?: boolean;
  /** Probe protocol name. See probe "type" field in the farm probe */
  type?: string;
  /** True is this probe type supports a URL */
  url?: boolean;
}

/**
 * Defined routes name, type and id. Typically used to generate autocomplete lists.
 */
export interface IpLoadbalancingDefinedRouteOVH {
  /**
   * Human readable name for your route
   * @nullable
   */
  displayName?: string | null;
  /** Id of your route */
  routeId?: number;
  /** Protocol supported by this route */
  type?: string;
}

/**
 * a list of {type=>[Frontend ids]}
 */
export interface IpLoadbalancingDefinedFrontendOVH {
  id?: number;
  type?: string;
}

/**
 * a list of { type => [ Farm ids ] }
 */
export interface IpLoadbalancingDefinedFarmOVH {
  id?: number;
  type?: string;
}

/**
 * Possible values for load balancing balance algorithm
 */
export type IpLoadbalancingBalanceTCPEnumOVH = typeof IpLoadbalancingBalanceTCPEnumOVH[keyof typeof IpLoadbalancingBalanceTCPEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingBalanceTCPEnumOVH = {
  first: 'first',
  leastconn: 'leastconn',
  roundrobin: 'roundrobin',
  source: 'source',
} as const;

/**
 * Possible values for load balancing balance algorithm
 */
export type IpLoadbalancingBalanceHTTPEnumOVH = typeof IpLoadbalancingBalanceHTTPEnumOVH[keyof typeof IpLoadbalancingBalanceHTTPEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingBalanceHTTPEnumOVH = {
  first: 'first',
  leastconn: 'leastconn',
  roundrobin: 'roundrobin',
  source: 'source',
  uri: 'uri',
} as const;

/**
 * Probe type. "tcp" if null
 * @nullable
 */
export type IpLoadbalancingBackendProbeOVHType = IpLoadbalancingProbeTypeEnumOVH | null;

/**
 * HTTP method to use with "http" probe. Consider using HEAD to save bandwidth when possible. Defaults to "GET"
 * @nullable
 */
export type IpLoadbalancingBackendProbeOVHMethod = IpLoadbalancingProbeMethodEnumOVH | null;

/**
 * Matcher to use to valide "expect". "default" uses HAProxy's default behavior for this type of check. "status" is only supported for HTTP probes
 * @nullable
 */
export type IpLoadbalancingBackendProbeOVHMatch = IpLoadbalancingProbeExpectMatchEnumOVH | null;

/**
 * Probe used to determine if a backend is alive and can handle requests
 */
export interface IpLoadbalancingBackendProbeOVH {
  /**
   * Force probe to run over a SSL layer. Defaults to false
   * @nullable
   */
  forceSsl?: boolean | null;
  /**
   * Seconds between each probe check. Must be > 30sec. Defaults to 30
   * @nullable
   */
  interval?: number | null;
  /**
   * Matcher to use to valide "expect". "default" uses HAProxy's default behavior for this type of check. "status" is only supported for HTTP probes
   * @nullable
   */
  match?: IpLoadbalancingBackendProbeOVHMatch;
  /**
   * HTTP method to use with "http" probe. Consider using HEAD to save bandwidth when possible. Defaults to "GET"
   * @nullable
   */
  method?: IpLoadbalancingBackendProbeOVHMethod;
  /**
   * Invert the matching operator effect
   * @nullable
   */
  negate?: boolean | null;
  /**
   * Server response expected when UP. Empty for "default", comma delimited list of statuses for "status", string for "contains", regex for "matches"
   * @nullable
   */
  pattern?: string | null;
  /**
   * Port used to probe your backend. Equal to farm port if null. Ignored for oco probe type
   * @nullable
   */
  port?: number | null;
  /**
   * Probe type. "tcp" if null
   * @nullable
   */
  type?: IpLoadbalancingBackendProbeOVHType;
  /**
   * URL to use for HTTP probes of the form [www.example.com]/path/to/check. Protocol will be ignored. Defaults to "/"
   * @nullable
   */
  url?: string | null;
}

/**
 * Possible values for server status
 */
export type IpLoadbalancingBackendCustomerServerStatusEnumOVH = typeof IpLoadbalancingBackendCustomerServerStatusEnumOVH[keyof typeof IpLoadbalancingBackendCustomerServerStatusEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IpLoadbalancingBackendCustomerServerStatusEnumOVH = {
  active: 'active',
  inactive: 'inactive',
} as const;

/**
 * HTTP Farm's Server
 */
export interface IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH {
  /** Address of your server */
  readonly address?: Ipv4OVH;
  /** farm id */
  readonly backendId?: number;
  /** Backup state. Default: 'false' */
  backup?: boolean;
  /**
   * Certificate chain. Allow server certificate verification (Avoid man-in-the-middle attacks)
   * @nullable
   */
  chain?: string | null;
  /**
   * Server cookie value configured for cookie stickiness
   * @nullable
   */
  cookie?: string | null;
  /**
   * Human readable name for your server, this field is for you
   * @nullable
   */
  displayName?: string | null;
  /**
   * Set action when backend marked down. (No action if null)
   * @nullable
   */
  onMarkedDown?: IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVHOnMarkedDown;
  /**
   * Port attached to your server. Inherited from farm if null
   * @nullable
   */
  port?: number | null;
  /** Probe state. Default: 'false' */
  probe?: boolean;
  /**
   * Disabled if null. Send PROXY protocol header. Requires a compatible server.
   * @nullable
   */
  proxyProtocolVersion?: IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVHProxyProtocolVersion;
  /** Id of your server */
  readonly serverId?: number;
  /** Server state */
  readonly serverState?: readonly IpLoadbalancingServerStateOVH[];
  /** SSL ciphering. Probes will also be sent ciphered. Default: 'false' */
  ssl?: boolean;
  /** Status attached to your server */
  status?: IpLoadbalancingBackendCustomerServerStatusEnumOVH;
  /**
   * Weight value. Defaults to 1. 0 if not used in load balancing. Servers with higher weight get more requests.
   * @nullable
   */
  weight?: number | null;
}

/**
 * IP address (e.g., 192.0.2.0)
 */
export type IpInterfaceOVH = string;

/**
 * IP (v4 or v6) CIDR notation (e.g., 192.0.2.0/24)
 */
export type IpBlockOVH = string;

/**
 * IP address (e.g., 192.0.2.0)
 */
export type IpOVH = string;

/**
 * International phone number
 */
export type InternationalPhoneNumberOVH = string;

/**
 * Operator that can be used in order to filter resources tags
 */
export type IamResourceTagFilterOperatorEnumOVH = typeof IamResourceTagFilterOperatorEnumOVH[keyof typeof IamResourceTagFilterOperatorEnumOVH];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IamResourceTagFilterOperatorEnumOVH = {
  EQ: 'EQ',
  EXISTS: 'EXISTS',
  ILIKE: 'ILIKE',
  LIKE: 'LIKE',
  NEQ: 'NEQ',
  NEXISTS: 'NEXISTS',
} as const;

/**
 * Operator to use in order to filter on the value (defaults to 'EQ')
 * @nullable
 */
export type IamResourceTagFilterOVHOperator = IamResourceTagFilterOperatorEnumOVH | null;

/**
 * Resource tag filter
 */
export interface IamResourceTagFilterOVH {
  /**
   * Operator to use in order to filter on the value (defaults to 'EQ')
   * @nullable
   */
  readonly operator?: IamResourceTagFilterOVHOperator;
  /** Value to use in order to filter tags */
  readonly value?: string;
}

/**
 * Resource tags. Tags that were internally computed are prefixed with ovh:
 * @nullable
 */
export type IamResourceMetadataOVHTags = {[key: string]: string} | null;

/**
 * IAM resource metadata embedded in services models
 */
export interface IamResourceMetadataOVH {
  /**
   * Resource display name
   * @nullable
   */
  readonly displayName?: string | null;
  /** Unique identifier of the resource */
  readonly id?: string;
  /**
   * Resource tags. Tags that were internally computed are prefixed with ovh:
   * @nullable
   */
  readonly tags?: IamResourceMetadataOVHTags;
  /** Unique resource name used in policies */
  readonly urn?: string;
}

/**
 * Email address (e.g., api@ml.ovh.net)
 */
export type EmailOVH = string;

/**
 * Duration (e.g., P1Y2M3DT4H6M9S)
 */
export type DurationOVH = string;

