/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * OVHcloud API specification
 * Specification for OVHcloud API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  GetIpLoadbalancingParams,
  GetIpLoadbalancingServiceNameDefinedFarmsParams,
  GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams,
  GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams,
  GetIpLoadbalancingServiceNameHttpFarmParams,
  GetIpLoadbalancingServiceNameHttpFrontendParams,
  GetIpLoadbalancingServiceNameHttpRouteParams,
  GetIpLoadbalancingServiceNameQuotaHistoryParams,
  GetIpLoadbalancingServiceNameSslParams,
  GetIpLoadbalancingServiceNameTaskParams,
  GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams,
  GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams,
  GetIpLoadbalancingServiceNameTcpFarmParams,
  GetIpLoadbalancingServiceNameTcpFrontendParams,
  GetIpLoadbalancingServiceNameTcpRouteParams,
  GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams,
  GetIpLoadbalancingServiceNameUdpFarmParams,
  GetIpLoadbalancingServiceNameUdpFrontendParams,
  GetIpLoadbalancingServiceNameVrackNetworkParams,
  IpBlockOVH,
  IpLoadbalancingBackendHttpBackendHttpOVH,
  IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH,
  IpLoadbalancingBackendTcpBackendTcpOVH,
  IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH,
  IpLoadbalancingBackendUdpBackendUdpOVH,
  IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH,
  IpLoadbalancingDefinedFarmOVH,
  IpLoadbalancingDefinedFrontendOVH,
  IpLoadbalancingDefinedRouteOVH,
  IpLoadbalancingFarmAvailableProbeOVH,
  IpLoadbalancingFrontendFrontendOVH,
  IpLoadbalancingFrontendHttpFrontendHttpOVH,
  IpLoadbalancingFrontendTcpFrontendTcpOVH,
  IpLoadbalancingFrontendUdpFrontendUdpOVH,
  IpLoadbalancingIpOVH,
  IpLoadbalancingIpWithIAMOVH,
  IpLoadbalancingMetricsTokenOVH,
  IpLoadbalancingNatIpsOVH,
  IpLoadbalancingPendingChangesOVH,
  IpLoadbalancingQuotaHistoryQuotaHistoryOVH,
  IpLoadbalancingQuotaQuotaOVH,
  IpLoadbalancingRouteAvailableActionOVH,
  IpLoadbalancingRouteAvailableRuleOVH,
  IpLoadbalancingRouteHttpRouteHttpOVH,
  IpLoadbalancingRouteRuleRouteRuleOVH,
  IpLoadbalancingRouteTcpRouteTcpOVH,
  IpLoadbalancingSslSslOVH,
  IpLoadbalancingStatusOVH,
  IpLoadbalancingTaskTaskOVH,
  IpLoadbalancingVrackInformationOVH,
  IpLoadbalancingVrackNetworkCreationRulesOVH,
  IpLoadbalancingVrackNetworkVrackNetworkOVH,
  IpLoadbalancingVrackTransparentGatewaysOVH,
  IpLoadbalancingVrackTransparentIpVrackTransparentIpOVH,
  IpLoadbalancingZoneZoneOVH,
  PostIpLoadbalancingServiceNameChangeContactBody,
  PostIpLoadbalancingServiceNameConfirmTerminationBody,
  PostIpLoadbalancingServiceNameFreeCertificateBody,
  PostIpLoadbalancingServiceNameHttpFarmBody,
  PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody,
  PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody,
  PostIpLoadbalancingServiceNameHttpFrontendBody,
  PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody,
  PostIpLoadbalancingServiceNameHttpRouteBody,
  PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody,
  PostIpLoadbalancingServiceNameRefreshBody,
  PostIpLoadbalancingServiceNameSslBody,
  PostIpLoadbalancingServiceNameTcpFarmBody,
  PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody,
  PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody,
  PostIpLoadbalancingServiceNameTcpFrontendBody,
  PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody,
  PostIpLoadbalancingServiceNameTcpRouteBody,
  PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody,
  PostIpLoadbalancingServiceNameUdpFarmBody,
  PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody,
  PostIpLoadbalancingServiceNameUdpFrontendBody,
  PostIpLoadbalancingServiceNameVrackNetworkBody,
  PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody,
  ServicesServiceOVH
} from './oVHcloudAPISpecification.schemas'
import { customInstanceV6 } from '../../../custom-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;


type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * @summary List of your load balancing IP
 */
export const getIpLoadbalancing = (
    params?: GetIpLoadbalancingParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<string[]>(
      {url: `/ipLoadbalancing`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingQueryKey = (params?: GetIpLoadbalancingParams,) => {
    return [`/ipLoadbalancing`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancing>>, TError = unknown>(params?: GetIpLoadbalancingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancing>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancing>>> = ({ signal }) => getIpLoadbalancing(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancing>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancing>>>
export type GetIpLoadbalancingQueryError = unknown


export function useGetIpLoadbalancing<TData = Awaited<ReturnType<typeof getIpLoadbalancing>>, TError = unknown>(
 params: undefined |  GetIpLoadbalancingParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancing>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancing>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancing<TData = Awaited<ReturnType<typeof getIpLoadbalancing>>, TError = unknown>(
 params?: GetIpLoadbalancingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancing>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancing>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancing<TData = Awaited<ReturnType<typeof getIpLoadbalancing>>, TError = unknown>(
 params?: GetIpLoadbalancingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancing>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List of your load balancing IP
 */

export function useGetIpLoadbalancing<TData = Awaited<ReturnType<typeof getIpLoadbalancing>>, TError = unknown>(
 params?: GetIpLoadbalancingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancing>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceName = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingIpWithIAMOVH>(
      {url: `/ipLoadbalancing/${serviceName}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>> = ({ signal }) => getIpLoadbalancingServiceName(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>>
export type GetIpLoadbalancingServiceNameQueryError = unknown


export function useGetIpLoadbalancingServiceName<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceName<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceName<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceName<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceName>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceName = (
    serviceName: string,
    ipLoadbalancingIpOVH: NonReadonly<IpLoadbalancingIpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingIpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceName>>, TError,{serviceName: string;data: NonReadonly<IpLoadbalancingIpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceName>>, TError,{serviceName: string;data: NonReadonly<IpLoadbalancingIpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceName>>, {serviceName: string;data: NonReadonly<IpLoadbalancingIpOVH>}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  putIpLoadbalancingServiceName(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceName>>>
    export type PutIpLoadbalancingServiceNameMutationBody = NonReadonly<IpLoadbalancingIpOVH>
    export type PutIpLoadbalancingServiceNameMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceName = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceName>>, TError,{serviceName: string;data: NonReadonly<IpLoadbalancingIpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceName>>,
        TError,
        {serviceName: string;data: NonReadonly<IpLoadbalancingIpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Available farm probes for health checks
 */
export const getIpLoadbalancingServiceNameAvailableFarmProbes = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFarmAvailableProbeOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/availableFarmProbes`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameAvailableFarmProbesQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/availableFarmProbes`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameAvailableFarmProbesQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameAvailableFarmProbesQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>> = ({ signal }) => getIpLoadbalancingServiceNameAvailableFarmProbes(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameAvailableFarmProbesQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>>
export type GetIpLoadbalancingServiceNameAvailableFarmProbesQueryError = unknown


export function useGetIpLoadbalancingServiceNameAvailableFarmProbes<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableFarmProbes<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableFarmProbes<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Available farm probes for health checks
 */

export function useGetIpLoadbalancingServiceNameAvailableFarmProbes<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmProbes>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameAvailableFarmProbesQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Available farm types
 */
export const getIpLoadbalancingServiceNameAvailableFarmType = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<string[]>(
      {url: `/ipLoadbalancing/${serviceName}/availableFarmType`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameAvailableFarmTypeQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/availableFarmType`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameAvailableFarmTypeQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameAvailableFarmTypeQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>> = ({ signal }) => getIpLoadbalancingServiceNameAvailableFarmType(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameAvailableFarmTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>>
export type GetIpLoadbalancingServiceNameAvailableFarmTypeQueryError = unknown


export function useGetIpLoadbalancingServiceNameAvailableFarmType<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableFarmType<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableFarmType<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Available farm types
 */

export function useGetIpLoadbalancingServiceNameAvailableFarmType<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFarmType>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameAvailableFarmTypeQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Available frontend type
 */
export const getIpLoadbalancingServiceNameAvailableFrontendType = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<string[]>(
      {url: `/ipLoadbalancing/${serviceName}/availableFrontendType`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameAvailableFrontendTypeQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/availableFrontendType`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameAvailableFrontendTypeQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameAvailableFrontendTypeQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>> = ({ signal }) => getIpLoadbalancingServiceNameAvailableFrontendType(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameAvailableFrontendTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>>
export type GetIpLoadbalancingServiceNameAvailableFrontendTypeQueryError = unknown


export function useGetIpLoadbalancingServiceNameAvailableFrontendType<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableFrontendType<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableFrontendType<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Available frontend type
 */

export function useGetIpLoadbalancingServiceNameAvailableFrontendType<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableFrontendType>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameAvailableFrontendTypeQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Available route actions
 */
export const getIpLoadbalancingServiceNameAvailableRouteActions = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteAvailableActionOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/availableRouteActions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameAvailableRouteActionsQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/availableRouteActions`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameAvailableRouteActionsQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameAvailableRouteActionsQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>> = ({ signal }) => getIpLoadbalancingServiceNameAvailableRouteActions(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameAvailableRouteActionsQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>>
export type GetIpLoadbalancingServiceNameAvailableRouteActionsQueryError = unknown


export function useGetIpLoadbalancingServiceNameAvailableRouteActions<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableRouteActions<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableRouteActions<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Available route actions
 */

export function useGetIpLoadbalancingServiceNameAvailableRouteActions<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteActions>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameAvailableRouteActionsQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Available route match rules
 */
export const getIpLoadbalancingServiceNameAvailableRouteRules = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteAvailableRuleOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/availableRouteRules`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameAvailableRouteRulesQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/availableRouteRules`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameAvailableRouteRulesQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameAvailableRouteRulesQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>> = ({ signal }) => getIpLoadbalancingServiceNameAvailableRouteRules(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameAvailableRouteRulesQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>>
export type GetIpLoadbalancingServiceNameAvailableRouteRulesQueryError = unknown


export function useGetIpLoadbalancingServiceNameAvailableRouteRules<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableRouteRules<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameAvailableRouteRules<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Available route match rules
 */

export function useGetIpLoadbalancingServiceNameAvailableRouteRules<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameAvailableRouteRules>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameAvailableRouteRulesQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Launch a contact change procedure
 */
export const postIpLoadbalancingServiceNameChangeContact = (
    serviceName: string,
    postIpLoadbalancingServiceNameChangeContactBody: PostIpLoadbalancingServiceNameChangeContactBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/changeContact`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameChangeContactBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameChangeContactMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameChangeContact>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameChangeContactBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameChangeContact>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameChangeContactBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameChangeContact>>, {serviceName: string;data: PostIpLoadbalancingServiceNameChangeContactBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameChangeContact(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameChangeContactMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameChangeContact>>>
    export type PostIpLoadbalancingServiceNameChangeContactMutationBody = PostIpLoadbalancingServiceNameChangeContactBody
    export type PostIpLoadbalancingServiceNameChangeContactMutationError = unknown

    /**
 * @summary Launch a contact change procedure
 */
export const usePostIpLoadbalancingServiceNameChangeContact = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameChangeContact>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameChangeContactBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameChangeContact>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameChangeContactBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameChangeContactMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Confirm service termination
 */
export const postIpLoadbalancingServiceNameConfirmTermination = (
    serviceName: string,
    postIpLoadbalancingServiceNameConfirmTerminationBody: PostIpLoadbalancingServiceNameConfirmTerminationBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<string>(
      {url: `/ipLoadbalancing/${serviceName}/confirmTermination`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameConfirmTerminationBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameConfirmTerminationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameConfirmTermination>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameConfirmTerminationBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameConfirmTermination>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameConfirmTerminationBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameConfirmTermination>>, {serviceName: string;data: PostIpLoadbalancingServiceNameConfirmTerminationBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameConfirmTermination(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameConfirmTerminationMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameConfirmTermination>>>
    export type PostIpLoadbalancingServiceNameConfirmTerminationMutationBody = PostIpLoadbalancingServiceNameConfirmTerminationBody
    export type PostIpLoadbalancingServiceNameConfirmTerminationMutationError = unknown

    /**
 * @summary Confirm service termination
 */
export const usePostIpLoadbalancingServiceNameConfirmTermination = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameConfirmTermination>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameConfirmTerminationBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameConfirmTermination>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameConfirmTerminationBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameConfirmTerminationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List of defined farms, and whether they are HTTP, TCP or UDP
 */
export const getIpLoadbalancingServiceNameDefinedFarms = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameDefinedFarmsParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingDefinedFarmOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/definedFarms`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameDefinedFarmsQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameDefinedFarmsParams,) => {
    return [`/ipLoadbalancing/${serviceName}/definedFarms`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameDefinedFarmsQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameDefinedFarmsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameDefinedFarmsQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>> = ({ signal }) => getIpLoadbalancingServiceNameDefinedFarms(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameDefinedFarmsQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>>
export type GetIpLoadbalancingServiceNameDefinedFarmsQueryError = unknown


export function useGetIpLoadbalancingServiceNameDefinedFarms<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameDefinedFarmsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameDefinedFarms<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameDefinedFarmsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameDefinedFarms<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameDefinedFarmsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List of defined farms, and whether they are HTTP, TCP or UDP
 */

export function useGetIpLoadbalancingServiceNameDefinedFarms<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameDefinedFarmsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFarms>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameDefinedFarmsQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List of defined frontends, and whether they are HTTP, TCP or UDP
 */
export const getIpLoadbalancingServiceNameDefinedFrontends = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingDefinedFrontendOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/definedFrontends`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameDefinedFrontendsQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/definedFrontends`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameDefinedFrontendsQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameDefinedFrontendsQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>> = ({ signal }) => getIpLoadbalancingServiceNameDefinedFrontends(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameDefinedFrontendsQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>>
export type GetIpLoadbalancingServiceNameDefinedFrontendsQueryError = unknown


export function useGetIpLoadbalancingServiceNameDefinedFrontends<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameDefinedFrontends<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameDefinedFrontends<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List of defined frontends, and whether they are HTTP, TCP or UDP
 */

export function useGetIpLoadbalancingServiceNameDefinedFrontends<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedFrontends>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameDefinedFrontendsQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List of defined routes, and whether they are HTTP or TCP
 */
export const getIpLoadbalancingServiceNameDefinedRoutes = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingDefinedRouteOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/definedRoutes`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameDefinedRoutesQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/definedRoutes`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameDefinedRoutesQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameDefinedRoutesQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>> = ({ signal }) => getIpLoadbalancingServiceNameDefinedRoutes(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameDefinedRoutesQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>>
export type GetIpLoadbalancingServiceNameDefinedRoutesQueryError = unknown


export function useGetIpLoadbalancingServiceNameDefinedRoutes<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameDefinedRoutes<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameDefinedRoutes<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List of defined routes, and whether they are HTTP or TCP
 */

export function useGetIpLoadbalancingServiceNameDefinedRoutes<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameDefinedRoutes>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameDefinedRoutesQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List all failover ip routed to this IPLB
 */
export const getIpLoadbalancingServiceNameFailover = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpBlockOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/failover`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameFailoverQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/failover`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameFailoverQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameFailoverQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>> = ({ signal }) => getIpLoadbalancingServiceNameFailover(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameFailoverQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>>
export type GetIpLoadbalancingServiceNameFailoverQueryError = unknown


export function useGetIpLoadbalancingServiceNameFailover<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameFailover<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameFailover<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List all failover ip routed to this IPLB
 */

export function useGetIpLoadbalancingServiceNameFailover<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameFailover>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameFailoverQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Order a free certificate. We order and deliver it for you
 */
export const postIpLoadbalancingServiceNameFreeCertificate = (
    serviceName: string,
    postIpLoadbalancingServiceNameFreeCertificateBody: PostIpLoadbalancingServiceNameFreeCertificateBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingTaskTaskOVH>(
      {url: `/ipLoadbalancing/${serviceName}/freeCertificate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameFreeCertificateBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameFreeCertificateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameFreeCertificate>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameFreeCertificateBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameFreeCertificate>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameFreeCertificateBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameFreeCertificate>>, {serviceName: string;data: PostIpLoadbalancingServiceNameFreeCertificateBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameFreeCertificate(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameFreeCertificateMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameFreeCertificate>>>
    export type PostIpLoadbalancingServiceNameFreeCertificateMutationBody = PostIpLoadbalancingServiceNameFreeCertificateBody
    export type PostIpLoadbalancingServiceNameFreeCertificateMutationError = unknown

    /**
 * @summary Order a free certificate. We order and deliver it for you
 */
export const usePostIpLoadbalancingServiceNameFreeCertificate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameFreeCertificate>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameFreeCertificateBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameFreeCertificate>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameFreeCertificateBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameFreeCertificateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary HTTP Farm for this iplb
 */
export const getIpLoadbalancingServiceNameHttpFarm = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFarmParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpFarmQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFarmParams,) => {
    return [`/ipLoadbalancing/${serviceName}/http/farm`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpFarmQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpFarmQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpFarm(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpFarmQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>>
export type GetIpLoadbalancingServiceNameHttpFarmQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameHttpFarmParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary HTTP Farm for this iplb
 */

export function useGetIpLoadbalancingServiceNameHttpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpFarmQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new HTTP Farm on your IP Load Balancing
 */
export const postIpLoadbalancingServiceNameHttpFarm = (
    serviceName: string,
    postIpLoadbalancingServiceNameHttpFarmBody: PostIpLoadbalancingServiceNameHttpFarmBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendHttpBackendHttpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameHttpFarmBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameHttpFarmMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpFarmBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpFarmBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarm>>, {serviceName: string;data: PostIpLoadbalancingServiceNameHttpFarmBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameHttpFarm(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameHttpFarmMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarm>>>
    export type PostIpLoadbalancingServiceNameHttpFarmMutationBody = PostIpLoadbalancingServiceNameHttpFarmBody
    export type PostIpLoadbalancingServiceNameHttpFarmMutationError = unknown

    /**
 * @summary Add a new HTTP Farm on your IP Load Balancing
 */
export const usePostIpLoadbalancingServiceNameHttpFarm = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpFarmBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarm>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameHttpFarmBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameHttpFarmMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete an HTTP Farm
 */
export const deleteIpLoadbalancingServiceNameHttpFarmFarmId = (
    serviceName: string,
    farmId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameHttpFarmFarmIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmId>>, {serviceName: string;farmId: number}> = (props) => {
          const {serviceName,farmId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameHttpFarmFarmId(serviceName,farmId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameHttpFarmFarmIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmId>>>
    
    export type DeleteIpLoadbalancingServiceNameHttpFarmFarmIdMutationError = unknown

    /**
 * @summary Delete an HTTP Farm
 */
export const useDeleteIpLoadbalancingServiceNameHttpFarmFarmId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmId>>,
        TError,
        {serviceName: string;farmId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameHttpFarmFarmIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameHttpFarmFarmId = (
    serviceName: string,
    farmId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendHttpBackendHttpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdQueryKey = (serviceName: string,
    farmId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/http/farm/${farmId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError = unknown>(serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpFarmFarmIdQueryKey(serviceName,farmId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpFarmFarmId(serviceName,farmId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpFarmFarmIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>>
export type GetIpLoadbalancingServiceNameHttpFarmFarmIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameHttpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpFarmFarmIdQueryOptions(serviceName,farmId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameHttpFarmFarmId = (
    serviceName: string,
    farmId: number,
    ipLoadbalancingBackendHttpBackendHttpOVH: NonReadonly<IpLoadbalancingBackendHttpBackendHttpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingBackendHttpBackendHttpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameHttpFarmFarmIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendHttpBackendHttpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendHttpBackendHttpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmId>>, {serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendHttpBackendHttpOVH>}> = (props) => {
          const {serviceName,farmId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameHttpFarmFarmId(serviceName,farmId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameHttpFarmFarmIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmId>>>
    export type PutIpLoadbalancingServiceNameHttpFarmFarmIdMutationBody = NonReadonly<IpLoadbalancingBackendHttpBackendHttpOVH>
    export type PutIpLoadbalancingServiceNameHttpFarmFarmIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameHttpFarmFarmId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendHttpBackendHttpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmId>>,
        TError,
        {serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendHttpBackendHttpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameHttpFarmFarmIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary HTTP Farm's Servers
 */
export const getIpLoadbalancingServiceNameHttpFarmFarmIdServer = (
    serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerQueryKey = (serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams,) => {
    return [`/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError = unknown>(serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerQueryKey(serviceName,farmId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpFarmFarmIdServer(serviceName,farmId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>>
export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params: undefined |  GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary HTTP Farm's Servers
 */

export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerQueryOptions(serviceName,farmId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a server to an HTTP Farm
 */
export const postIpLoadbalancingServiceNameHttpFarmFarmIdServer = (
    serviceName: string,
    farmId: number,
    postIpLoadbalancingServiceNameHttpFarmFarmIdServerBody: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameHttpFarmFarmIdServerBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameHttpFarmFarmIdServerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, {serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody}> = (props) => {
          const {serviceName,farmId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameHttpFarmFarmIdServer(serviceName,farmId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameHttpFarmFarmIdServerMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServer>>>
    export type PostIpLoadbalancingServiceNameHttpFarmFarmIdServerMutationBody = PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody
    export type PostIpLoadbalancingServiceNameHttpFarmFarmIdServerMutationError = unknown

    /**
 * @summary Add a server to an HTTP Farm
 */
export const usePostIpLoadbalancingServiceNameHttpFarmFarmIdServer = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServer>>,
        TError,
        {serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameHttpFarmFarmIdServerMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a server from an HTTP Farm
 */
export const deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, {serviceName: string;farmId: number;serverId: number}> = (props) => {
          const {serviceName,farmId,serverId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId(serviceName,farmId,serverId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>>
    
    export type DeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationError = unknown

    /**
 * @summary Delete a server from an HTTP Farm
 */
export const useDeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>,
        TError,
        {serviceName: string;farmId: number;serverId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdQueryKey = (serviceName: string,
    farmId: number,
    serverId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError = unknown>(serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdQueryKey(serviceName,farmId,serverId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId(serviceName,farmId,serverId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId && serverId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>>
export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdQueryOptions(serviceName,farmId,serverId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
    ipLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH: NonReadonly<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, {serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>}> = (props) => {
          const {serviceName,farmId,serverId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId(serviceName,farmId,serverId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>>
    export type PutIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationBody = NonReadonly<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>
    export type PutIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFarmFarmIdServerServerId>>,
        TError,
        {serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendHttpCustomerServerBackendHTTPServerOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary HTTP Farm's Servers transparent configuration
 */
export const getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent = (
    serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}/transparent`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentQueryKey = (serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams,) => {
    return [`/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}/transparent`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentQueryKey(serviceName,farmId,serverId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent(serviceName,farmId,serverId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId && serverId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>>
export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    params: undefined |  GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary HTTP Farm's Servers transparent configuration
 */

export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentQueryOptions(serviceName,farmId,serverId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new vrack transparent ip
 */
export const postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent = (
    serviceName: string,
    farmId: number,
    serverId: number,
    postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackTransparentIpVrackTransparentIpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}/transparent`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError,{serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError,{serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, {serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody}> = (props) => {
          const {serviceName,farmId,serverId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent(serviceName,farmId,serverId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>>
    export type PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentMutationBody = PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody
    export type PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentMutationError = unknown

    /**
 * @summary Add a new vrack transparent ip
 */
export const usePostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>, TError,{serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparent>>,
        TError,
        {serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a vrack transparent ip
 */
export const deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId = (
    serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}/transparent/${transparentId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError,{serviceName: string;farmId: number;serverId: number;transparentId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError,{serviceName: string;farmId: number;serverId: number;transparentId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, {serviceName: string;farmId: number;serverId: number;transparentId: number}> = (props) => {
          const {serviceName,farmId,serverId,transparentId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId(serviceName,farmId,serverId,transparentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>>
    
    export type DeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdMutationError = unknown

    /**
 * @summary Delete a vrack transparent ip
 */
export const useDeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError,{serviceName: string;farmId: number;serverId: number;transparentId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>,
        TError,
        {serviceName: string;farmId: number;serverId: number;transparentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId = (
    serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackTransparentIpVrackTransparentIpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}/transparent/${transparentId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdQueryKey = (serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/http/farm/${farmId}/server/${serverId}/transparent/${transparentId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdQueryKey(serviceName,farmId,serverId,transparentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId(serviceName,farmId,serverId,transparentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId && serverId && transparentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>>
export type GetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpFarmFarmIdServerServerIdTransparentTransparentIdQueryOptions(serviceName,farmId,serverId,transparentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary HTTP frontends for this iplb
 */
export const getIpLoadbalancingServiceNameHttpFrontend = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFrontendParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/http/frontend`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpFrontendQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFrontendParams,) => {
    return [`/ipLoadbalancing/${serviceName}/http/frontend`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpFrontendQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpFrontendQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpFrontend(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpFrontendQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>>
export type GetIpLoadbalancingServiceNameHttpFrontendQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameHttpFrontendParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary HTTP frontends for this iplb
 */

export function useGetIpLoadbalancingServiceNameHttpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpFrontendQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new http frontend on your IP Load Balancing
 */
export const postIpLoadbalancingServiceNameHttpFrontend = (
    serviceName: string,
    postIpLoadbalancingServiceNameHttpFrontendBody: PostIpLoadbalancingServiceNameHttpFrontendBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFrontendHttpFrontendHttpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/frontend`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameHttpFrontendBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameHttpFrontendMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpFrontendBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpFrontendBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontend>>, {serviceName: string;data: PostIpLoadbalancingServiceNameHttpFrontendBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameHttpFrontend(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameHttpFrontendMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontend>>>
    export type PostIpLoadbalancingServiceNameHttpFrontendMutationBody = PostIpLoadbalancingServiceNameHttpFrontendBody
    export type PostIpLoadbalancingServiceNameHttpFrontendMutationError = unknown

    /**
 * @summary Add a new http frontend on your IP Load Balancing
 */
export const usePostIpLoadbalancingServiceNameHttpFrontend = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpFrontendBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontend>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameHttpFrontendBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameHttpFrontendMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete an HTTP frontend
 */
export const deleteIpLoadbalancingServiceNameHttpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/frontend/${frontendId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFrontendFrontendId>>, {serviceName: string;frontendId: number}> = (props) => {
          const {serviceName,frontendId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameHttpFrontendFrontendId(serviceName,frontendId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFrontendFrontendId>>>
    
    export type DeleteIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationError = unknown

    /**
 * @summary Delete an HTTP frontend
 */
export const useDeleteIpLoadbalancingServiceNameHttpFrontendFrontendId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpFrontendFrontendId>>,
        TError,
        {serviceName: string;frontendId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameHttpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFrontendHttpFrontendHttpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/frontend/${frontendId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpFrontendFrontendIdQueryKey = (serviceName: string,
    frontendId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/http/frontend/${frontendId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpFrontendFrontendIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError = unknown>(serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpFrontendFrontendIdQueryKey(serviceName,frontendId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpFrontendFrontendId(serviceName,frontendId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && frontendId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpFrontendFrontendIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>>
export type GetIpLoadbalancingServiceNameHttpFrontendFrontendIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameHttpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpFrontendFrontendIdQueryOptions(serviceName,frontendId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameHttpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
    ipLoadbalancingFrontendHttpFrontendHttpOVH: NonReadonly<IpLoadbalancingFrontendHttpFrontendHttpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/frontend/${frontendId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingFrontendHttpFrontendHttpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendHttpFrontendHttpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendHttpFrontendHttpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFrontendFrontendId>>, {serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendHttpFrontendHttpOVH>}> = (props) => {
          const {serviceName,frontendId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameHttpFrontendFrontendId(serviceName,frontendId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFrontendFrontendId>>>
    export type PutIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationBody = NonReadonly<IpLoadbalancingFrontendHttpFrontendHttpOVH>
    export type PutIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameHttpFrontendFrontendId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendHttpFrontendHttpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpFrontendFrontendId>>,
        TError,
        {serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendHttpFrontendHttpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameHttpFrontendFrontendIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Move the frontend in or out vrack
 */
export const postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate = (
    serviceName: string,
    frontendId: number,
    postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody: PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFrontendFrontendOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/frontend/${frontendId}/private`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate>>, TError,{serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate>>, TError,{serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate>>, {serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody}> = (props) => {
          const {serviceName,frontendId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate(serviceName,frontendId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate>>>
    export type PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateMutationBody = PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody
    export type PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateMutationError = unknown

    /**
 * @summary Move the frontend in or out vrack
 */
export const usePostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate>>, TError,{serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivate>>,
        TError,
        {serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameHttpFrontendFrontendIdPrivateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary HTTP routes for this iplb
 */
export const getIpLoadbalancingServiceNameHttpRoute = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpRouteParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/http/route`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpRouteQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpRouteParams,) => {
    return [`/ipLoadbalancing/${serviceName}/http/route`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpRouteQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpRouteParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpRouteQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpRoute(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpRouteQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>>
export type GetIpLoadbalancingServiceNameHttpRouteQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpRoute<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameHttpRouteParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpRoute<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpRouteParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpRoute<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpRouteParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary HTTP routes for this iplb
 */

export function useGetIpLoadbalancingServiceNameHttpRoute<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameHttpRouteParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpRouteQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new HTTP route to your frontend
 */
export const postIpLoadbalancingServiceNameHttpRoute = (
    serviceName: string,
    postIpLoadbalancingServiceNameHttpRouteBody: PostIpLoadbalancingServiceNameHttpRouteBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteHttpRouteHttpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/route`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameHttpRouteBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameHttpRouteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRoute>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpRouteBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRoute>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpRouteBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRoute>>, {serviceName: string;data: PostIpLoadbalancingServiceNameHttpRouteBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameHttpRoute(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameHttpRouteMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRoute>>>
    export type PostIpLoadbalancingServiceNameHttpRouteMutationBody = PostIpLoadbalancingServiceNameHttpRouteBody
    export type PostIpLoadbalancingServiceNameHttpRouteMutationError = unknown

    /**
 * @summary Add a new HTTP route to your frontend
 */
export const usePostIpLoadbalancingServiceNameHttpRoute = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRoute>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameHttpRouteBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRoute>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameHttpRouteBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameHttpRouteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete this HTTP route
 */
export const deleteIpLoadbalancingServiceNameHttpRouteRouteId = (
    serviceName: string,
    routeId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/route/${routeId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameHttpRouteRouteIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteId>>, TError,{serviceName: string;routeId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteId>>, TError,{serviceName: string;routeId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteId>>, {serviceName: string;routeId: number}> = (props) => {
          const {serviceName,routeId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameHttpRouteRouteId(serviceName,routeId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameHttpRouteRouteIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteId>>>
    
    export type DeleteIpLoadbalancingServiceNameHttpRouteRouteIdMutationError = unknown

    /**
 * @summary Delete this HTTP route
 */
export const useDeleteIpLoadbalancingServiceNameHttpRouteRouteId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteId>>, TError,{serviceName: string;routeId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteId>>,
        TError,
        {serviceName: string;routeId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameHttpRouteRouteIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameHttpRouteRouteId = (
    serviceName: string,
    routeId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteHttpRouteHttpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/route/${routeId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpRouteRouteIdQueryKey = (serviceName: string,
    routeId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/http/route/${routeId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpRouteRouteIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError = unknown>(serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpRouteRouteIdQueryKey(serviceName,routeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpRouteRouteId(serviceName,routeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && routeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpRouteRouteIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>>
export type GetIpLoadbalancingServiceNameHttpRouteRouteIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpRouteRouteId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError = unknown>(
 serviceName: string,
    routeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpRouteRouteId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpRouteRouteId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameHttpRouteRouteId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpRouteRouteIdQueryOptions(serviceName,routeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameHttpRouteRouteId = (
    serviceName: string,
    routeId: number,
    ipLoadbalancingRouteHttpRouteHttpOVH: NonReadonly<IpLoadbalancingRouteHttpRouteHttpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/route/${routeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingRouteHttpRouteHttpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameHttpRouteRouteIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteId>>, TError,{serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteHttpRouteHttpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteId>>, TError,{serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteHttpRouteHttpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteId>>, {serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteHttpRouteHttpOVH>}> = (props) => {
          const {serviceName,routeId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameHttpRouteRouteId(serviceName,routeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameHttpRouteRouteIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteId>>>
    export type PutIpLoadbalancingServiceNameHttpRouteRouteIdMutationBody = NonReadonly<IpLoadbalancingRouteHttpRouteHttpOVH>
    export type PutIpLoadbalancingServiceNameHttpRouteRouteIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameHttpRouteRouteId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteId>>, TError,{serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteHttpRouteHttpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteId>>,
        TError,
        {serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteHttpRouteHttpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameHttpRouteRouteIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary HTTP routes for this iplb
 */
export const getIpLoadbalancingServiceNameHttpRouteRouteIdRule = (
    serviceName: string,
    routeId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/http/route/${routeId}/rule`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleQueryKey = (serviceName: string,
    routeId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/http/route/${routeId}/rule`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError = unknown>(serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleQueryKey(serviceName,routeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpRouteRouteIdRule(serviceName,routeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && routeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpRouteRouteIdRuleQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>>
export type GetIpLoadbalancingServiceNameHttpRouteRouteIdRuleQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpRouteRouteIdRule<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError = unknown>(
 serviceName: string,
    routeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpRouteRouteIdRule<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpRouteRouteIdRule<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary HTTP routes for this iplb
 */

export function useGetIpLoadbalancingServiceNameHttpRouteRouteIdRule<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleQueryOptions(serviceName,routeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new rule to your route
 */
export const postIpLoadbalancingServiceNameHttpRouteRouteIdRule = (
    serviceName: string,
    routeId: number,
    postIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody: PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteRuleRouteRuleOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/route/${routeId}/rule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameHttpRouteRouteIdRuleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError,{serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError,{serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, {serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody}> = (props) => {
          const {serviceName,routeId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameHttpRouteRouteIdRule(serviceName,routeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRouteRouteIdRule>>>
    export type PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleMutationBody = PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody
    export type PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleMutationError = unknown

    /**
 * @summary Add a new rule to your route
 */
export const usePostIpLoadbalancingServiceNameHttpRouteRouteIdRule = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRouteRouteIdRule>>, TError,{serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameHttpRouteRouteIdRule>>,
        TError,
        {serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameHttpRouteRouteIdRuleBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameHttpRouteRouteIdRuleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete this rule from the route
 */
export const deleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId = (
    serviceName: string,
    routeId: number,
    ruleId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/route/${routeId}/rule/${ruleId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, {serviceName: string;routeId: number;ruleId: number}> = (props) => {
          const {serviceName,routeId,ruleId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId(serviceName,routeId,ruleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>>
    
    export type DeleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationError = unknown

    /**
 * @summary Delete this rule from the route
 */
export const useDeleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>,
        TError,
        {serviceName: string;routeId: number;ruleId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId = (
    serviceName: string,
    routeId: number,
    ruleId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteRuleRouteRuleOVH>(
      {url: `/ipLoadbalancing/${serviceName}/http/route/${routeId}/rule/${ruleId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdQueryKey = (serviceName: string,
    routeId: number,
    ruleId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/http/route/${routeId}/rule/${ruleId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError = unknown>(serviceName: string,
    routeId: number,
    ruleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdQueryKey(serviceName,routeId,ruleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>> = ({ signal }) => getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId(serviceName,routeId,ruleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && routeId && ruleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>>
export type GetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError = unknown>(
 serviceName: string,
    routeId: number,
    ruleId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError = unknown>(
 serviceName: string,
    routeId: number,
    ruleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError = unknown>(
 serviceName: string,
    routeId: number,
    ruleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError = unknown>(
 serviceName: string,
    routeId: number,
    ruleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdQueryOptions(serviceName,routeId,ruleId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId = (
    serviceName: string,
    routeId: number,
    ruleId: number,
    ipLoadbalancingRouteRuleRouteRuleOVH: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/http/route/${routeId}/rule/${ruleId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingRouteRuleRouteRuleOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, {serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>}> = (props) => {
          const {serviceName,routeId,ruleId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId(serviceName,routeId,ruleId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>>
    export type PutIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationBody = NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>
    export type PutIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleId>>,
        TError,
        {serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameHttpRouteRouteIdRuleRuleIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Retrieve metrics token and endpoint for your Load Balancer
 */
export const getIpLoadbalancingServiceNameMetricsToken = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingMetricsTokenOVH>(
      {url: `/ipLoadbalancing/${serviceName}/metricsToken`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameMetricsTokenQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/metricsToken`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameMetricsTokenQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameMetricsTokenQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>> = ({ signal }) => getIpLoadbalancingServiceNameMetricsToken(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameMetricsTokenQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>>
export type GetIpLoadbalancingServiceNameMetricsTokenQueryError = unknown


export function useGetIpLoadbalancingServiceNameMetricsToken<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameMetricsToken<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameMetricsToken<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve metrics token and endpoint for your Load Balancer
 */

export function useGetIpLoadbalancingServiceNameMetricsToken<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameMetricsToken>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameMetricsTokenQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Ip subnet used by OVH to nat requests on your IPLB to your backends. You must ensure that your backends are not part of a network that overlap with this one
 * @summary Ip subnet used by OVH to nat requests on your IPLB to your backends
 */
export const getIpLoadbalancingServiceNameNatIp = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingNatIpsOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/natIp`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameNatIpQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/natIp`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameNatIpQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameNatIpQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>> = ({ signal }) => getIpLoadbalancingServiceNameNatIp(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameNatIpQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>>
export type GetIpLoadbalancingServiceNameNatIpQueryError = unknown


export function useGetIpLoadbalancingServiceNameNatIp<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameNatIp<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameNatIp<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ip subnet used by OVH to nat requests on your IPLB to your backends
 */

export function useGetIpLoadbalancingServiceNameNatIp<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameNatIp>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameNatIpQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List the pending changes on your Load Balancer configuration, per zone
 */
export const getIpLoadbalancingServiceNamePendingChanges = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingPendingChangesOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/pendingChanges`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNamePendingChangesQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/pendingChanges`] as const;
    }

    
export const getGetIpLoadbalancingServiceNamePendingChangesQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNamePendingChangesQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>> = ({ signal }) => getIpLoadbalancingServiceNamePendingChanges(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNamePendingChangesQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>>
export type GetIpLoadbalancingServiceNamePendingChangesQueryError = unknown


export function useGetIpLoadbalancingServiceNamePendingChanges<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNamePendingChanges<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNamePendingChanges<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List the pending changes on your Load Balancer configuration, per zone
 */

export function useGetIpLoadbalancingServiceNamePendingChanges<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNamePendingChanges>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNamePendingChangesQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Available quota informations for current billing period per zone
 */
export const getIpLoadbalancingServiceNameQuota = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<string[]>(
      {url: `/ipLoadbalancing/${serviceName}/quota`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameQuotaQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/quota`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameQuotaQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameQuotaQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>> = ({ signal }) => getIpLoadbalancingServiceNameQuota(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameQuotaQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>>
export type GetIpLoadbalancingServiceNameQuotaQueryError = unknown


export function useGetIpLoadbalancingServiceNameQuota<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameQuota<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameQuota<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Available quota informations for current billing period per zone
 */

export function useGetIpLoadbalancingServiceNameQuota<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuota>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameQuotaQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameQuotaZone = (
    serviceName: string,
    zone: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingQuotaQuotaOVH>(
      {url: `/ipLoadbalancing/${serviceName}/quota/${zone}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameQuotaZoneQueryKey = (serviceName: string,
    zone: string,) => {
    return [`/ipLoadbalancing/${serviceName}/quota/${zone}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameQuotaZoneQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError = unknown>(serviceName: string,
    zone: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameQuotaZoneQueryKey(serviceName,zone);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>> = ({ signal }) => getIpLoadbalancingServiceNameQuotaZone(serviceName,zone, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && zone), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameQuotaZoneQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>>
export type GetIpLoadbalancingServiceNameQuotaZoneQueryError = unknown


export function useGetIpLoadbalancingServiceNameQuotaZone<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError = unknown>(
 serviceName: string,
    zone: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameQuotaZone<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError = unknown>(
 serviceName: string,
    zone: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameQuotaZone<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError = unknown>(
 serviceName: string,
    zone: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameQuotaZone<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError = unknown>(
 serviceName: string,
    zone: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaZone>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameQuotaZoneQueryOptions(serviceName,zone,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameQuotaZone = (
    serviceName: string,
    zone: string,
    ipLoadbalancingQuotaQuotaOVH: NonReadonly<IpLoadbalancingQuotaQuotaOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/quota/${zone}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingQuotaQuotaOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameQuotaZoneMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameQuotaZone>>, TError,{serviceName: string;zone: string;data: NonReadonly<IpLoadbalancingQuotaQuotaOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameQuotaZone>>, TError,{serviceName: string;zone: string;data: NonReadonly<IpLoadbalancingQuotaQuotaOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameQuotaZone>>, {serviceName: string;zone: string;data: NonReadonly<IpLoadbalancingQuotaQuotaOVH>}> = (props) => {
          const {serviceName,zone,data} = props ?? {};

          return  putIpLoadbalancingServiceNameQuotaZone(serviceName,zone,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameQuotaZoneMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameQuotaZone>>>
    export type PutIpLoadbalancingServiceNameQuotaZoneMutationBody = NonReadonly<IpLoadbalancingQuotaQuotaOVH>
    export type PutIpLoadbalancingServiceNameQuotaZoneMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameQuotaZone = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameQuotaZone>>, TError,{serviceName: string;zone: string;data: NonReadonly<IpLoadbalancingQuotaQuotaOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameQuotaZone>>,
        TError,
        {serviceName: string;zone: string;data: NonReadonly<IpLoadbalancingQuotaQuotaOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameQuotaZoneMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Quota history informations, per month
 */
export const getIpLoadbalancingServiceNameQuotaHistory = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameQuotaHistoryParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/quotaHistory`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameQuotaHistoryQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameQuotaHistoryParams,) => {
    return [`/ipLoadbalancing/${serviceName}/quotaHistory`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameQuotaHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameQuotaHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameQuotaHistoryQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>> = ({ signal }) => getIpLoadbalancingServiceNameQuotaHistory(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameQuotaHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>>
export type GetIpLoadbalancingServiceNameQuotaHistoryQueryError = unknown


export function useGetIpLoadbalancingServiceNameQuotaHistory<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameQuotaHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameQuotaHistory<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameQuotaHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameQuotaHistory<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameQuotaHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Quota history informations, per month
 */

export function useGetIpLoadbalancingServiceNameQuotaHistory<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameQuotaHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameQuotaHistoryQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameQuotaHistoryId = (
    serviceName: string,
    id: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingQuotaHistoryQuotaHistoryOVH>(
      {url: `/ipLoadbalancing/${serviceName}/quotaHistory/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameQuotaHistoryIdQueryKey = (serviceName: string,
    id: number,) => {
    return [`/ipLoadbalancing/${serviceName}/quotaHistory/${id}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameQuotaHistoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError = unknown>(serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameQuotaHistoryIdQueryKey(serviceName,id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>> = ({ signal }) => getIpLoadbalancingServiceNameQuotaHistoryId(serviceName,id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameQuotaHistoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>>
export type GetIpLoadbalancingServiceNameQuotaHistoryIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameQuotaHistoryId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError = unknown>(
 serviceName: string,
    id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameQuotaHistoryId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameQuotaHistoryId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameQuotaHistoryId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameQuotaHistoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameQuotaHistoryIdQueryOptions(serviceName,id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Apply the configuration to your iplb
 */
export const postIpLoadbalancingServiceNameRefresh = (
    serviceName: string,
    postIpLoadbalancingServiceNameRefreshBody: PostIpLoadbalancingServiceNameRefreshBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingTaskTaskOVH>(
      {url: `/ipLoadbalancing/${serviceName}/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameRefreshBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameRefreshMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameRefresh>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameRefreshBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameRefresh>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameRefreshBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameRefresh>>, {serviceName: string;data: PostIpLoadbalancingServiceNameRefreshBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameRefresh(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameRefresh>>>
    export type PostIpLoadbalancingServiceNameRefreshMutationBody = PostIpLoadbalancingServiceNameRefreshBody
    export type PostIpLoadbalancingServiceNameRefreshMutationError = unknown

    /**
 * @summary Apply the configuration to your iplb
 */
export const usePostIpLoadbalancingServiceNameRefresh = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameRefresh>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameRefreshBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameRefresh>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameRefreshBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get service information
 */
export const getIpLoadbalancingServiceNameServiceInfos = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<ServicesServiceOVH>(
      {url: `/ipLoadbalancing/${serviceName}/serviceInfos`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameServiceInfosQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/serviceInfos`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameServiceInfosQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameServiceInfosQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>> = ({ signal }) => getIpLoadbalancingServiceNameServiceInfos(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameServiceInfosQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>>
export type GetIpLoadbalancingServiceNameServiceInfosQueryError = unknown


export function useGetIpLoadbalancingServiceNameServiceInfos<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameServiceInfos<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameServiceInfos<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get service information
 */

export function useGetIpLoadbalancingServiceNameServiceInfos<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameServiceInfos>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameServiceInfosQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update service information
 */
export const putIpLoadbalancingServiceNameServiceInfos = (
    serviceName: string,
    servicesServiceOVH: NonReadonly<ServicesServiceOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/serviceInfos`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: servicesServiceOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameServiceInfosMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameServiceInfos>>, TError,{serviceName: string;data: NonReadonly<ServicesServiceOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameServiceInfos>>, TError,{serviceName: string;data: NonReadonly<ServicesServiceOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameServiceInfos>>, {serviceName: string;data: NonReadonly<ServicesServiceOVH>}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  putIpLoadbalancingServiceNameServiceInfos(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameServiceInfosMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameServiceInfos>>>
    export type PutIpLoadbalancingServiceNameServiceInfosMutationBody = NonReadonly<ServicesServiceOVH>
    export type PutIpLoadbalancingServiceNameServiceInfosMutationError = unknown

    /**
 * @summary Update service information
 */
export const usePutIpLoadbalancingServiceNameServiceInfos = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameServiceInfos>>, TError,{serviceName: string;data: NonReadonly<ServicesServiceOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameServiceInfos>>,
        TError,
        {serviceName: string;data: NonReadonly<ServicesServiceOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameServiceInfosMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Ssl for this iplb
 */
export const getIpLoadbalancingServiceNameSsl = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameSslParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/ssl`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameSslQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameSslParams,) => {
    return [`/ipLoadbalancing/${serviceName}/ssl`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameSslQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameSslParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameSslQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>> = ({ signal }) => getIpLoadbalancingServiceNameSsl(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameSslQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>>
export type GetIpLoadbalancingServiceNameSslQueryError = unknown


export function useGetIpLoadbalancingServiceNameSsl<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameSslParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameSsl<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameSslParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameSsl<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameSslParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ssl for this iplb
 */

export function useGetIpLoadbalancingServiceNameSsl<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameSslParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSsl>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameSslQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new custom SSL certificate on your IP Load Balancing
 */
export const postIpLoadbalancingServiceNameSsl = (
    serviceName: string,
    postIpLoadbalancingServiceNameSslBody: PostIpLoadbalancingServiceNameSslBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingSslSslOVH>(
      {url: `/ipLoadbalancing/${serviceName}/ssl`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameSslBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameSslMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameSsl>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameSslBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameSsl>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameSslBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameSsl>>, {serviceName: string;data: PostIpLoadbalancingServiceNameSslBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameSsl(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameSslMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameSsl>>>
    export type PostIpLoadbalancingServiceNameSslMutationBody = PostIpLoadbalancingServiceNameSslBody
    export type PostIpLoadbalancingServiceNameSslMutationError = unknown

    /**
 * @summary Add a new custom SSL certificate on your IP Load Balancing
 */
export const usePostIpLoadbalancingServiceNameSsl = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameSsl>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameSslBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameSsl>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameSslBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameSslMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a custom SSL certificate
 */
export const deleteIpLoadbalancingServiceNameSslId = (
    serviceName: string,
    id: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/ssl/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameSslIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameSslId>>, TError,{serviceName: string;id: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameSslId>>, TError,{serviceName: string;id: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameSslId>>, {serviceName: string;id: number}> = (props) => {
          const {serviceName,id} = props ?? {};

          return  deleteIpLoadbalancingServiceNameSslId(serviceName,id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameSslIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameSslId>>>
    
    export type DeleteIpLoadbalancingServiceNameSslIdMutationError = unknown

    /**
 * @summary Delete a custom SSL certificate
 */
export const useDeleteIpLoadbalancingServiceNameSslId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameSslId>>, TError,{serviceName: string;id: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameSslId>>,
        TError,
        {serviceName: string;id: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameSslIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameSslId = (
    serviceName: string,
    id: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingSslSslOVH>(
      {url: `/ipLoadbalancing/${serviceName}/ssl/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameSslIdQueryKey = (serviceName: string,
    id: number,) => {
    return [`/ipLoadbalancing/${serviceName}/ssl/${id}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameSslIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError = unknown>(serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameSslIdQueryKey(serviceName,id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>> = ({ signal }) => getIpLoadbalancingServiceNameSslId(serviceName,id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameSslIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>>
export type GetIpLoadbalancingServiceNameSslIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameSslId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError = unknown>(
 serviceName: string,
    id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameSslId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameSslId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameSslId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameSslId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameSslIdQueryOptions(serviceName,id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameSslId = (
    serviceName: string,
    id: number,
    ipLoadbalancingSslSslOVH: NonReadonly<IpLoadbalancingSslSslOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/ssl/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingSslSslOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameSslIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameSslId>>, TError,{serviceName: string;id: number;data: NonReadonly<IpLoadbalancingSslSslOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameSslId>>, TError,{serviceName: string;id: number;data: NonReadonly<IpLoadbalancingSslSslOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameSslId>>, {serviceName: string;id: number;data: NonReadonly<IpLoadbalancingSslSslOVH>}> = (props) => {
          const {serviceName,id,data} = props ?? {};

          return  putIpLoadbalancingServiceNameSslId(serviceName,id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameSslIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameSslId>>>
    export type PutIpLoadbalancingServiceNameSslIdMutationBody = NonReadonly<IpLoadbalancingSslSslOVH>
    export type PutIpLoadbalancingServiceNameSslIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameSslId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameSslId>>, TError,{serviceName: string;id: number;data: NonReadonly<IpLoadbalancingSslSslOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameSslId>>,
        TError,
        {serviceName: string;id: number;data: NonReadonly<IpLoadbalancingSslSslOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameSslIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the global status of your IPLB
 */
export const getIpLoadbalancingServiceNameStatus = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingStatusOVH>(
      {url: `/ipLoadbalancing/${serviceName}/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameStatusQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/status`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameStatusQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameStatusQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>> = ({ signal }) => getIpLoadbalancingServiceNameStatus(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>>
export type GetIpLoadbalancingServiceNameStatusQueryError = unknown


export function useGetIpLoadbalancingServiceNameStatus<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameStatus<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameStatus<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get the global status of your IPLB
 */

export function useGetIpLoadbalancingServiceNameStatus<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameStatusQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Task for this iplb
 */
export const getIpLoadbalancingServiceNameTask = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameTaskParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/task`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTaskQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameTaskParams,) => {
    return [`/ipLoadbalancing/${serviceName}/task`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTaskQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameTaskParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTaskQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>> = ({ signal }) => getIpLoadbalancingServiceNameTask(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>>
export type GetIpLoadbalancingServiceNameTaskQueryError = unknown


export function useGetIpLoadbalancingServiceNameTask<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameTaskParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTask<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTaskParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTask<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTaskParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Task for this iplb
 */

export function useGetIpLoadbalancingServiceNameTask<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTaskParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTask>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTaskQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameTaskId = (
    serviceName: string,
    id: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingTaskTaskOVH>(
      {url: `/ipLoadbalancing/${serviceName}/task/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTaskIdQueryKey = (serviceName: string,
    id: number,) => {
    return [`/ipLoadbalancing/${serviceName}/task/${id}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTaskIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError = unknown>(serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTaskIdQueryKey(serviceName,id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>> = ({ signal }) => getIpLoadbalancingServiceNameTaskId(serviceName,id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTaskIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>>
export type GetIpLoadbalancingServiceNameTaskIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameTaskId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError = unknown>(
 serviceName: string,
    id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTaskId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTaskId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameTaskId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError = unknown>(
 serviceName: string,
    id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTaskId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTaskIdQueryOptions(serviceName,id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary TCP Farm for this iplb
 */
export const getIpLoadbalancingServiceNameTcpFarm = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFarmParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpFarmQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFarmParams,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/farm`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpFarmQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpFarmQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpFarm(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpFarmQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>>
export type GetIpLoadbalancingServiceNameTcpFarmQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameTcpFarmParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary TCP Farm for this iplb
 */

export function useGetIpLoadbalancingServiceNameTcpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpFarmQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new TCP Farm on your IP Load Balancing
 */
export const postIpLoadbalancingServiceNameTcpFarm = (
    serviceName: string,
    postIpLoadbalancingServiceNameTcpFarmBody: PostIpLoadbalancingServiceNameTcpFarmBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendTcpBackendTcpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameTcpFarmBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameTcpFarmMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpFarmBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpFarmBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarm>>, {serviceName: string;data: PostIpLoadbalancingServiceNameTcpFarmBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameTcpFarm(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameTcpFarmMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarm>>>
    export type PostIpLoadbalancingServiceNameTcpFarmMutationBody = PostIpLoadbalancingServiceNameTcpFarmBody
    export type PostIpLoadbalancingServiceNameTcpFarmMutationError = unknown

    /**
 * @summary Add a new TCP Farm on your IP Load Balancing
 */
export const usePostIpLoadbalancingServiceNameTcpFarm = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpFarmBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarm>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameTcpFarmBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameTcpFarmMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a TCP Farm
 */
export const deleteIpLoadbalancingServiceNameTcpFarmFarmId = (
    serviceName: string,
    farmId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameTcpFarmFarmIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmId>>, {serviceName: string;farmId: number}> = (props) => {
          const {serviceName,farmId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameTcpFarmFarmId(serviceName,farmId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameTcpFarmFarmIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmId>>>
    
    export type DeleteIpLoadbalancingServiceNameTcpFarmFarmIdMutationError = unknown

    /**
 * @summary Delete a TCP Farm
 */
export const useDeleteIpLoadbalancingServiceNameTcpFarmFarmId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmId>>,
        TError,
        {serviceName: string;farmId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameTcpFarmFarmIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameTcpFarmFarmId = (
    serviceName: string,
    farmId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendTcpBackendTcpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdQueryKey = (serviceName: string,
    farmId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError = unknown>(serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpFarmFarmIdQueryKey(serviceName,farmId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpFarmFarmId(serviceName,farmId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpFarmFarmIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>>
export type GetIpLoadbalancingServiceNameTcpFarmFarmIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameTcpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpFarmFarmIdQueryOptions(serviceName,farmId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameTcpFarmFarmId = (
    serviceName: string,
    farmId: number,
    ipLoadbalancingBackendTcpBackendTcpOVH: NonReadonly<IpLoadbalancingBackendTcpBackendTcpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingBackendTcpBackendTcpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameTcpFarmFarmIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendTcpBackendTcpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendTcpBackendTcpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmId>>, {serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendTcpBackendTcpOVH>}> = (props) => {
          const {serviceName,farmId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameTcpFarmFarmId(serviceName,farmId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameTcpFarmFarmIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmId>>>
    export type PutIpLoadbalancingServiceNameTcpFarmFarmIdMutationBody = NonReadonly<IpLoadbalancingBackendTcpBackendTcpOVH>
    export type PutIpLoadbalancingServiceNameTcpFarmFarmIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameTcpFarmFarmId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendTcpBackendTcpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmId>>,
        TError,
        {serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendTcpBackendTcpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameTcpFarmFarmIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary TCP Farm's Servers
 */
export const getIpLoadbalancingServiceNameTcpFarmFarmIdServer = (
    serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerQueryKey = (serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError = unknown>(serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerQueryKey(serviceName,farmId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpFarmFarmIdServer(serviceName,farmId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>>
export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params: undefined |  GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary TCP Farm's Servers
 */

export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerQueryOptions(serviceName,farmId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a server to a TCP Farm
 */
export const postIpLoadbalancingServiceNameTcpFarmFarmIdServer = (
    serviceName: string,
    farmId: number,
    postIpLoadbalancingServiceNameTcpFarmFarmIdServerBody: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameTcpFarmFarmIdServerBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameTcpFarmFarmIdServerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, {serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody}> = (props) => {
          const {serviceName,farmId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameTcpFarmFarmIdServer(serviceName,farmId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameTcpFarmFarmIdServerMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServer>>>
    export type PostIpLoadbalancingServiceNameTcpFarmFarmIdServerMutationBody = PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody
    export type PostIpLoadbalancingServiceNameTcpFarmFarmIdServerMutationError = unknown

    /**
 * @summary Add a server to a TCP Farm
 */
export const usePostIpLoadbalancingServiceNameTcpFarmFarmIdServer = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServer>>,
        TError,
        {serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameTcpFarmFarmIdServerMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a server from a TCP Farm
 */
export const deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, {serviceName: string;farmId: number;serverId: number}> = (props) => {
          const {serviceName,farmId,serverId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId(serviceName,farmId,serverId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>>
    
    export type DeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationError = unknown

    /**
 * @summary Delete a server from a TCP Farm
 */
export const useDeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>,
        TError,
        {serviceName: string;farmId: number;serverId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdQueryKey = (serviceName: string,
    farmId: number,
    serverId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError = unknown>(serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdQueryKey(serviceName,farmId,serverId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId(serviceName,farmId,serverId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId && serverId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>>
export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdQueryOptions(serviceName,farmId,serverId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
    ipLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH: NonReadonly<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, {serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>}> = (props) => {
          const {serviceName,farmId,serverId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId(serviceName,farmId,serverId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>>
    export type PutIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationBody = NonReadonly<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>
    export type PutIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFarmFarmIdServerServerId>>,
        TError,
        {serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendTcpCustomerServerBackendTCPServerOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary TCP Farm's Servers transparent configuration
 */
export const getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent = (
    serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}/transparent`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentQueryKey = (serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}/transparent`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentQueryKey(serviceName,farmId,serverId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent(serviceName,farmId,serverId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId && serverId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>>
export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    params: undefined |  GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary TCP Farm's Servers transparent configuration
 */

export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    params?: GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentQueryOptions(serviceName,farmId,serverId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new vrack transparent ip
 */
export const postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent = (
    serviceName: string,
    farmId: number,
    serverId: number,
    postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackTransparentIpVrackTransparentIpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}/transparent`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError,{serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError,{serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, {serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody}> = (props) => {
          const {serviceName,farmId,serverId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent(serviceName,farmId,serverId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>>
    export type PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentMutationBody = PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody
    export type PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentMutationError = unknown

    /**
 * @summary Add a new vrack transparent ip
 */
export const usePostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>, TError,{serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparent>>,
        TError,
        {serviceName: string;farmId: number;serverId: number;data: PostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a vrack transparent ip
 */
export const deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId = (
    serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}/transparent/${transparentId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError,{serviceName: string;farmId: number;serverId: number;transparentId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError,{serviceName: string;farmId: number;serverId: number;transparentId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, {serviceName: string;farmId: number;serverId: number;transparentId: number}> = (props) => {
          const {serviceName,farmId,serverId,transparentId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId(serviceName,farmId,serverId,transparentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>>
    
    export type DeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdMutationError = unknown

    /**
 * @summary Delete a vrack transparent ip
 */
export const useDeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError,{serviceName: string;farmId: number;serverId: number;transparentId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>,
        TError,
        {serviceName: string;farmId: number;serverId: number;transparentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId = (
    serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackTransparentIpVrackTransparentIpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}/transparent/${transparentId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdQueryKey = (serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/farm/${farmId}/server/${serverId}/transparent/${transparentId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdQueryKey(serviceName,farmId,serverId,transparentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId(serviceName,farmId,serverId,transparentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId && serverId && transparentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>>
export type GetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number,
    transparentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpFarmFarmIdServerServerIdTransparentTransparentIdQueryOptions(serviceName,farmId,serverId,transparentId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary TCP frontends for this iplb
 */
export const getIpLoadbalancingServiceNameTcpFrontend = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFrontendParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/frontend`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpFrontendQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFrontendParams,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/frontend`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpFrontendQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpFrontendQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpFrontend(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpFrontendQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>>
export type GetIpLoadbalancingServiceNameTcpFrontendQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameTcpFrontendParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary TCP frontends for this iplb
 */

export function useGetIpLoadbalancingServiceNameTcpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpFrontendQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new TCP frontend on your IP Load Balancing
 */
export const postIpLoadbalancingServiceNameTcpFrontend = (
    serviceName: string,
    postIpLoadbalancingServiceNameTcpFrontendBody: PostIpLoadbalancingServiceNameTcpFrontendBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFrontendTcpFrontendTcpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/frontend`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameTcpFrontendBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameTcpFrontendMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpFrontendBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpFrontendBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontend>>, {serviceName: string;data: PostIpLoadbalancingServiceNameTcpFrontendBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameTcpFrontend(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameTcpFrontendMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontend>>>
    export type PostIpLoadbalancingServiceNameTcpFrontendMutationBody = PostIpLoadbalancingServiceNameTcpFrontendBody
    export type PostIpLoadbalancingServiceNameTcpFrontendMutationError = unknown

    /**
 * @summary Add a new TCP frontend on your IP Load Balancing
 */
export const usePostIpLoadbalancingServiceNameTcpFrontend = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpFrontendBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontend>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameTcpFrontendBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameTcpFrontendMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete an TCP frontend
 */
export const deleteIpLoadbalancingServiceNameTcpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/frontend/${frontendId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFrontendFrontendId>>, {serviceName: string;frontendId: number}> = (props) => {
          const {serviceName,frontendId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameTcpFrontendFrontendId(serviceName,frontendId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFrontendFrontendId>>>
    
    export type DeleteIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationError = unknown

    /**
 * @summary Delete an TCP frontend
 */
export const useDeleteIpLoadbalancingServiceNameTcpFrontendFrontendId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpFrontendFrontendId>>,
        TError,
        {serviceName: string;frontendId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameTcpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFrontendTcpFrontendTcpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/frontend/${frontendId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpFrontendFrontendIdQueryKey = (serviceName: string,
    frontendId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/frontend/${frontendId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpFrontendFrontendIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError = unknown>(serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpFrontendFrontendIdQueryKey(serviceName,frontendId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpFrontendFrontendId(serviceName,frontendId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && frontendId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpFrontendFrontendIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>>
export type GetIpLoadbalancingServiceNameTcpFrontendFrontendIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameTcpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpFrontendFrontendIdQueryOptions(serviceName,frontendId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameTcpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
    ipLoadbalancingFrontendTcpFrontendTcpOVH: NonReadonly<IpLoadbalancingFrontendTcpFrontendTcpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/frontend/${frontendId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingFrontendTcpFrontendTcpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendTcpFrontendTcpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendTcpFrontendTcpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFrontendFrontendId>>, {serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendTcpFrontendTcpOVH>}> = (props) => {
          const {serviceName,frontendId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameTcpFrontendFrontendId(serviceName,frontendId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFrontendFrontendId>>>
    export type PutIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationBody = NonReadonly<IpLoadbalancingFrontendTcpFrontendTcpOVH>
    export type PutIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameTcpFrontendFrontendId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendTcpFrontendTcpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpFrontendFrontendId>>,
        TError,
        {serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendTcpFrontendTcpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameTcpFrontendFrontendIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Move the frontend in or out vrack
 */
export const postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate = (
    serviceName: string,
    frontendId: number,
    postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody: PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFrontendFrontendOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/frontend/${frontendId}/private`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate>>, TError,{serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate>>, TError,{serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate>>, {serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody}> = (props) => {
          const {serviceName,frontendId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate(serviceName,frontendId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate>>>
    export type PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateMutationBody = PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody
    export type PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateMutationError = unknown

    /**
 * @summary Move the frontend in or out vrack
 */
export const usePostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate>>, TError,{serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivate>>,
        TError,
        {serviceName: string;frontendId: number;data: PostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameTcpFrontendFrontendIdPrivateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary TCP routes for this iplb
 */
export const getIpLoadbalancingServiceNameTcpRoute = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpRouteParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpRouteQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpRouteParams,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/route`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpRouteQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpRouteParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpRouteQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpRoute(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpRouteQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>>
export type GetIpLoadbalancingServiceNameTcpRouteQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpRoute<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameTcpRouteParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpRoute<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpRouteParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpRoute<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpRouteParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary TCP routes for this iplb
 */

export function useGetIpLoadbalancingServiceNameTcpRoute<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameTcpRouteParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpRouteQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new TCP route to your frontend
 */
export const postIpLoadbalancingServiceNameTcpRoute = (
    serviceName: string,
    postIpLoadbalancingServiceNameTcpRouteBody: PostIpLoadbalancingServiceNameTcpRouteBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteTcpRouteTcpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameTcpRouteBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameTcpRouteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRoute>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpRouteBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRoute>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpRouteBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRoute>>, {serviceName: string;data: PostIpLoadbalancingServiceNameTcpRouteBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameTcpRoute(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameTcpRouteMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRoute>>>
    export type PostIpLoadbalancingServiceNameTcpRouteMutationBody = PostIpLoadbalancingServiceNameTcpRouteBody
    export type PostIpLoadbalancingServiceNameTcpRouteMutationError = unknown

    /**
 * @summary Add a new TCP route to your frontend
 */
export const usePostIpLoadbalancingServiceNameTcpRoute = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRoute>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameTcpRouteBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRoute>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameTcpRouteBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameTcpRouteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete this TCP route
 */
export const deleteIpLoadbalancingServiceNameTcpRouteRouteId = (
    serviceName: string,
    routeId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route/${routeId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameTcpRouteRouteIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteId>>, TError,{serviceName: string;routeId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteId>>, TError,{serviceName: string;routeId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteId>>, {serviceName: string;routeId: number}> = (props) => {
          const {serviceName,routeId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameTcpRouteRouteId(serviceName,routeId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameTcpRouteRouteIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteId>>>
    
    export type DeleteIpLoadbalancingServiceNameTcpRouteRouteIdMutationError = unknown

    /**
 * @summary Delete this TCP route
 */
export const useDeleteIpLoadbalancingServiceNameTcpRouteRouteId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteId>>, TError,{serviceName: string;routeId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteId>>,
        TError,
        {serviceName: string;routeId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameTcpRouteRouteIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameTcpRouteRouteId = (
    serviceName: string,
    routeId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteTcpRouteTcpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route/${routeId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpRouteRouteIdQueryKey = (serviceName: string,
    routeId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/route/${routeId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpRouteRouteIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError = unknown>(serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpRouteRouteIdQueryKey(serviceName,routeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpRouteRouteId(serviceName,routeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && routeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpRouteRouteIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>>
export type GetIpLoadbalancingServiceNameTcpRouteRouteIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpRouteRouteId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError = unknown>(
 serviceName: string,
    routeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpRouteRouteId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpRouteRouteId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameTcpRouteRouteId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpRouteRouteIdQueryOptions(serviceName,routeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameTcpRouteRouteId = (
    serviceName: string,
    routeId: number,
    ipLoadbalancingRouteTcpRouteTcpOVH: NonReadonly<IpLoadbalancingRouteTcpRouteTcpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route/${routeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingRouteTcpRouteTcpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameTcpRouteRouteIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteId>>, TError,{serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteTcpRouteTcpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteId>>, TError,{serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteTcpRouteTcpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteId>>, {serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteTcpRouteTcpOVH>}> = (props) => {
          const {serviceName,routeId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameTcpRouteRouteId(serviceName,routeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameTcpRouteRouteIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteId>>>
    export type PutIpLoadbalancingServiceNameTcpRouteRouteIdMutationBody = NonReadonly<IpLoadbalancingRouteTcpRouteTcpOVH>
    export type PutIpLoadbalancingServiceNameTcpRouteRouteIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameTcpRouteRouteId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteId>>, TError,{serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteTcpRouteTcpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteId>>,
        TError,
        {serviceName: string;routeId: number;data: NonReadonly<IpLoadbalancingRouteTcpRouteTcpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameTcpRouteRouteIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary HTTP routes for this iplb
 */
export const getIpLoadbalancingServiceNameTcpRouteRouteIdRule = (
    serviceName: string,
    routeId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route/${routeId}/rule`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleQueryKey = (serviceName: string,
    routeId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/route/${routeId}/rule`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError = unknown>(serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleQueryKey(serviceName,routeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpRouteRouteIdRule(serviceName,routeId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && routeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpRouteRouteIdRuleQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>>
export type GetIpLoadbalancingServiceNameTcpRouteRouteIdRuleQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpRouteRouteIdRule<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError = unknown>(
 serviceName: string,
    routeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpRouteRouteIdRule<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpRouteRouteIdRule<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary HTTP routes for this iplb
 */

export function useGetIpLoadbalancingServiceNameTcpRouteRouteIdRule<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError = unknown>(
 serviceName: string,
    routeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleQueryOptions(serviceName,routeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new rule to your route
 */
export const postIpLoadbalancingServiceNameTcpRouteRouteIdRule = (
    serviceName: string,
    routeId: number,
    postIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody: PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteRuleRouteRuleOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route/${routeId}/rule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameTcpRouteRouteIdRuleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError,{serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError,{serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, {serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody}> = (props) => {
          const {serviceName,routeId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameTcpRouteRouteIdRule(serviceName,routeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRouteRouteIdRule>>>
    export type PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleMutationBody = PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody
    export type PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleMutationError = unknown

    /**
 * @summary Add a new rule to your route
 */
export const usePostIpLoadbalancingServiceNameTcpRouteRouteIdRule = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRouteRouteIdRule>>, TError,{serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTcpRouteRouteIdRule>>,
        TError,
        {serviceName: string;routeId: number;data: PostIpLoadbalancingServiceNameTcpRouteRouteIdRuleBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameTcpRouteRouteIdRuleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete this rule from the route
 */
export const deleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId = (
    serviceName: string,
    routeId: number,
    ruleId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route/${routeId}/rule/${ruleId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, {serviceName: string;routeId: number;ruleId: number}> = (props) => {
          const {serviceName,routeId,ruleId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId(serviceName,routeId,ruleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>>
    
    export type DeleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationError = unknown

    /**
 * @summary Delete this rule from the route
 */
export const useDeleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>,
        TError,
        {serviceName: string;routeId: number;ruleId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId = (
    serviceName: string,
    routeId: number,
    ruleId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingRouteRuleRouteRuleOVH>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route/${routeId}/rule/${ruleId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdQueryKey = (serviceName: string,
    routeId: number,
    ruleId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/tcp/route/${routeId}/rule/${ruleId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError = unknown>(serviceName: string,
    routeId: number,
    ruleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdQueryKey(serviceName,routeId,ruleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>> = ({ signal }) => getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId(serviceName,routeId,ruleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && routeId && ruleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>>
export type GetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError = unknown>(
 serviceName: string,
    routeId: number,
    ruleId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError = unknown>(
 serviceName: string,
    routeId: number,
    ruleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError = unknown>(
 serviceName: string,
    routeId: number,
    ruleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError = unknown>(
 serviceName: string,
    routeId: number,
    ruleId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdQueryOptions(serviceName,routeId,ruleId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId = (
    serviceName: string,
    routeId: number,
    ruleId: number,
    ipLoadbalancingRouteRuleRouteRuleOVH: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/tcp/route/${routeId}/rule/${ruleId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingRouteRuleRouteRuleOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, {serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>}> = (props) => {
          const {serviceName,routeId,ruleId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId(serviceName,routeId,ruleId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>>
    export type PutIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationBody = NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>
    export type PutIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>, TError,{serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleId>>,
        TError,
        {serviceName: string;routeId: number;ruleId: number;data: NonReadonly<IpLoadbalancingRouteRuleRouteRuleOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameTcpRouteRouteIdRuleRuleIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Ask for the termination of your service. Admin contact of this service will receive a termination token by email in order to confirm its termination with /confirmTermination endpoint.
 * @summary Ask for the termination of your service
 */
export const postIpLoadbalancingServiceNameTerminate = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<string>(
      {url: `/ipLoadbalancing/${serviceName}/terminate`, method: 'POST', signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameTerminateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTerminate>>, TError,{serviceName: string}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTerminate>>, TError,{serviceName: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTerminate>>, {serviceName: string}> = (props) => {
          const {serviceName} = props ?? {};

          return  postIpLoadbalancingServiceNameTerminate(serviceName,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameTerminateMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTerminate>>>
    
    export type PostIpLoadbalancingServiceNameTerminateMutationError = unknown

    /**
 * @summary Ask for the termination of your service
 */
export const usePostIpLoadbalancingServiceNameTerminate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTerminate>>, TError,{serviceName: string}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameTerminate>>,
        TError,
        {serviceName: string},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameTerminateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary UDP Farm for this iplb
 */
export const getIpLoadbalancingServiceNameUdpFarm = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFarmParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameUdpFarmQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFarmParams,) => {
    return [`/ipLoadbalancing/${serviceName}/udp/farm`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameUdpFarmQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameUdpFarmQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>> = ({ signal }) => getIpLoadbalancingServiceNameUdpFarm(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameUdpFarmQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>>
export type GetIpLoadbalancingServiceNameUdpFarmQueryError = unknown


export function useGetIpLoadbalancingServiceNameUdpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameUdpFarmParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary UDP Farm for this iplb
 */

export function useGetIpLoadbalancingServiceNameUdpFarm<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFarmParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarm>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameUdpFarmQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new UDP Farm on your IP Load Balancing
 */
export const postIpLoadbalancingServiceNameUdpFarm = (
    serviceName: string,
    postIpLoadbalancingServiceNameUdpFarmBody: PostIpLoadbalancingServiceNameUdpFarmBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendUdpBackendUdpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameUdpFarmBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameUdpFarmMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameUdpFarmBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameUdpFarmBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarm>>, {serviceName: string;data: PostIpLoadbalancingServiceNameUdpFarmBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameUdpFarm(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameUdpFarmMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarm>>>
    export type PostIpLoadbalancingServiceNameUdpFarmMutationBody = PostIpLoadbalancingServiceNameUdpFarmBody
    export type PostIpLoadbalancingServiceNameUdpFarmMutationError = unknown

    /**
 * @summary Add a new UDP Farm on your IP Load Balancing
 */
export const usePostIpLoadbalancingServiceNameUdpFarm = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarm>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameUdpFarmBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarm>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameUdpFarmBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameUdpFarmMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete an UDP Farm
 */
export const deleteIpLoadbalancingServiceNameUdpFarmFarmId = (
    serviceName: string,
    farmId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm/${farmId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameUdpFarmFarmIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmId>>, {serviceName: string;farmId: number}> = (props) => {
          const {serviceName,farmId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameUdpFarmFarmId(serviceName,farmId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameUdpFarmFarmIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmId>>>
    
    export type DeleteIpLoadbalancingServiceNameUdpFarmFarmIdMutationError = unknown

    /**
 * @summary Delete an UDP Farm
 */
export const useDeleteIpLoadbalancingServiceNameUdpFarmFarmId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmId>>, TError,{serviceName: string;farmId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmId>>,
        TError,
        {serviceName: string;farmId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameUdpFarmFarmIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameUdpFarmFarmId = (
    serviceName: string,
    farmId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendUdpBackendUdpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm/${farmId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameUdpFarmFarmIdQueryKey = (serviceName: string,
    farmId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/udp/farm/${farmId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameUdpFarmFarmIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError = unknown>(serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameUdpFarmFarmIdQueryKey(serviceName,farmId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>> = ({ signal }) => getIpLoadbalancingServiceNameUdpFarmFarmId(serviceName,farmId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameUdpFarmFarmIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>>
export type GetIpLoadbalancingServiceNameUdpFarmFarmIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameUdpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameUdpFarmFarmId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError = unknown>(
 serviceName: string,
    farmId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameUdpFarmFarmIdQueryOptions(serviceName,farmId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameUdpFarmFarmId = (
    serviceName: string,
    farmId: number,
    ipLoadbalancingBackendUdpBackendUdpOVH: NonReadonly<IpLoadbalancingBackendUdpBackendUdpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm/${farmId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingBackendUdpBackendUdpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameUdpFarmFarmIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendUdpBackendUdpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendUdpBackendUdpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmId>>, {serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendUdpBackendUdpOVH>}> = (props) => {
          const {serviceName,farmId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameUdpFarmFarmId(serviceName,farmId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameUdpFarmFarmIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmId>>>
    export type PutIpLoadbalancingServiceNameUdpFarmFarmIdMutationBody = NonReadonly<IpLoadbalancingBackendUdpBackendUdpOVH>
    export type PutIpLoadbalancingServiceNameUdpFarmFarmIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameUdpFarmFarmId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmId>>, TError,{serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendUdpBackendUdpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmId>>,
        TError,
        {serviceName: string;farmId: number;data: NonReadonly<IpLoadbalancingBackendUdpBackendUdpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameUdpFarmFarmIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary UDP Farm's Servers
 */
export const getIpLoadbalancingServiceNameUdpFarmFarmIdServer = (
    serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm/${farmId}/server`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameUdpFarmFarmIdServerQueryKey = (serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams,) => {
    return [`/ipLoadbalancing/${serviceName}/udp/farm/${farmId}/server`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameUdpFarmFarmIdServerQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError = unknown>(serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameUdpFarmFarmIdServerQueryKey(serviceName,farmId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>> = ({ signal }) => getIpLoadbalancingServiceNameUdpFarmFarmIdServer(serviceName,farmId,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameUdpFarmFarmIdServerQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>>
export type GetIpLoadbalancingServiceNameUdpFarmFarmIdServerQueryError = unknown


export function useGetIpLoadbalancingServiceNameUdpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params: undefined |  GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary UDP Farm's Servers
 */

export function useGetIpLoadbalancingServiceNameUdpFarmFarmIdServer<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    params?: GetIpLoadbalancingServiceNameUdpFarmFarmIdServerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameUdpFarmFarmIdServerQueryOptions(serviceName,farmId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a server to an UDP Farm
 */
export const postIpLoadbalancingServiceNameUdpFarmFarmIdServer = (
    serviceName: string,
    farmId: number,
    postIpLoadbalancingServiceNameUdpFarmFarmIdServerBody: PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm/${farmId}/server`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameUdpFarmFarmIdServerBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameUdpFarmFarmIdServerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, {serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody}> = (props) => {
          const {serviceName,farmId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameUdpFarmFarmIdServer(serviceName,farmId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameUdpFarmFarmIdServerMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarmFarmIdServer>>>
    export type PostIpLoadbalancingServiceNameUdpFarmFarmIdServerMutationBody = PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody
    export type PostIpLoadbalancingServiceNameUdpFarmFarmIdServerMutationError = unknown

    /**
 * @summary Add a server to an UDP Farm
 */
export const usePostIpLoadbalancingServiceNameUdpFarmFarmIdServer = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarmFarmIdServer>>, TError,{serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFarmFarmIdServer>>,
        TError,
        {serviceName: string;farmId: number;data: PostIpLoadbalancingServiceNameUdpFarmFarmIdServerBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameUdpFarmFarmIdServerMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a server from an UDP Farm
 */
export const deleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm/${farmId}/server/${serverId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, {serviceName: string;farmId: number;serverId: number}> = (props) => {
          const {serviceName,farmId,serverId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId(serviceName,farmId,serverId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>>
    
    export type DeleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationError = unknown

    /**
 * @summary Delete a server from an UDP Farm
 */
export const useDeleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>,
        TError,
        {serviceName: string;farmId: number;serverId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm/${farmId}/server/${serverId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdQueryKey = (serviceName: string,
    farmId: number,
    serverId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/udp/farm/${farmId}/server/${serverId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError = unknown>(serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdQueryKey(serviceName,farmId,serverId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>> = ({ signal }) => getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId(serviceName,farmId,serverId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && farmId && serverId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>>
export type GetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError = unknown>(
 serviceName: string,
    farmId: number,
    serverId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdQueryOptions(serviceName,farmId,serverId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId = (
    serviceName: string,
    farmId: number,
    serverId: number,
    ipLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH: NonReadonly<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/udp/farm/${farmId}/server/${serverId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, {serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>}> = (props) => {
          const {serviceName,farmId,serverId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId(serviceName,farmId,serverId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>>
    export type PutIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationBody = NonReadonly<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>
    export type PutIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>, TError,{serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFarmFarmIdServerServerId>>,
        TError,
        {serviceName: string;farmId: number;serverId: number;data: NonReadonly<IpLoadbalancingBackendUdpCustomerServerBackendUDPServerOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameUdpFarmFarmIdServerServerIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary UDP frontends for this iplb
 */
export const getIpLoadbalancingServiceNameUdpFrontend = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFrontendParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/udp/frontend`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameUdpFrontendQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFrontendParams,) => {
    return [`/ipLoadbalancing/${serviceName}/udp/frontend`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameUdpFrontendQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameUdpFrontendQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>> = ({ signal }) => getIpLoadbalancingServiceNameUdpFrontend(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameUdpFrontendQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>>
export type GetIpLoadbalancingServiceNameUdpFrontendQueryError = unknown


export function useGetIpLoadbalancingServiceNameUdpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameUdpFrontendParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary UDP frontends for this iplb
 */

export function useGetIpLoadbalancingServiceNameUdpFrontend<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameUdpFrontendParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontend>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameUdpFrontendQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a new UDP frontend on your IP Load Balancing
 */
export const postIpLoadbalancingServiceNameUdpFrontend = (
    serviceName: string,
    postIpLoadbalancingServiceNameUdpFrontendBody: PostIpLoadbalancingServiceNameUdpFrontendBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFrontendUdpFrontendUdpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/udp/frontend`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameUdpFrontendBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameUdpFrontendMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameUdpFrontendBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameUdpFrontendBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFrontend>>, {serviceName: string;data: PostIpLoadbalancingServiceNameUdpFrontendBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameUdpFrontend(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameUdpFrontendMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFrontend>>>
    export type PostIpLoadbalancingServiceNameUdpFrontendMutationBody = PostIpLoadbalancingServiceNameUdpFrontendBody
    export type PostIpLoadbalancingServiceNameUdpFrontendMutationError = unknown

    /**
 * @summary Add a new UDP frontend on your IP Load Balancing
 */
export const usePostIpLoadbalancingServiceNameUdpFrontend = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFrontend>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameUdpFrontendBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameUdpFrontend>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameUdpFrontendBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameUdpFrontendMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete an UDP frontend
 */
export const deleteIpLoadbalancingServiceNameUdpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/udp/frontend/${frontendId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFrontendFrontendId>>, {serviceName: string;frontendId: number}> = (props) => {
          const {serviceName,frontendId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameUdpFrontendFrontendId(serviceName,frontendId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFrontendFrontendId>>>
    
    export type DeleteIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationError = unknown

    /**
 * @summary Delete an UDP frontend
 */
export const useDeleteIpLoadbalancingServiceNameUdpFrontendFrontendId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameUdpFrontendFrontendId>>,
        TError,
        {serviceName: string;frontendId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameUdpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingFrontendUdpFrontendUdpOVH>(
      {url: `/ipLoadbalancing/${serviceName}/udp/frontend/${frontendId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameUdpFrontendFrontendIdQueryKey = (serviceName: string,
    frontendId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/udp/frontend/${frontendId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameUdpFrontendFrontendIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError = unknown>(serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameUdpFrontendFrontendIdQueryKey(serviceName,frontendId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>> = ({ signal }) => getIpLoadbalancingServiceNameUdpFrontendFrontendId(serviceName,frontendId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && frontendId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameUdpFrontendFrontendIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>>
export type GetIpLoadbalancingServiceNameUdpFrontendFrontendIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameUdpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameUdpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameUdpFrontendFrontendId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError = unknown>(
 serviceName: string,
    frontendId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameUdpFrontendFrontendIdQueryOptions(serviceName,frontendId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameUdpFrontendFrontendId = (
    serviceName: string,
    frontendId: number,
    ipLoadbalancingFrontendUdpFrontendUdpOVH: NonReadonly<IpLoadbalancingFrontendUdpFrontendUdpOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/udp/frontend/${frontendId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingFrontendUdpFrontendUdpOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendUdpFrontendUdpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendUdpFrontendUdpOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFrontendFrontendId>>, {serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendUdpFrontendUdpOVH>}> = (props) => {
          const {serviceName,frontendId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameUdpFrontendFrontendId(serviceName,frontendId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFrontendFrontendId>>>
    export type PutIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationBody = NonReadonly<IpLoadbalancingFrontendUdpFrontendUdpOVH>
    export type PutIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameUdpFrontendFrontendId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFrontendFrontendId>>, TError,{serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendUdpFrontendUdpOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameUdpFrontendFrontendId>>,
        TError,
        {serviceName: string;frontendId: number;data: NonReadonly<IpLoadbalancingFrontendUdpFrontendUdpOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameUdpFrontendFrontendIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Descriptions of private networks in the vRack attached to this Load Balancer
 */
export const getIpLoadbalancingServiceNameVrackNetwork = (
    serviceName: string,
    params?: GetIpLoadbalancingServiceNameVrackNetworkParams,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<number[]>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/network`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameVrackNetworkQueryKey = (serviceName: string,
    params?: GetIpLoadbalancingServiceNameVrackNetworkParams,) => {
    return [`/ipLoadbalancing/${serviceName}/vrack/network`, ...(params ? [params]: [])] as const;
    }

    
export const getGetIpLoadbalancingServiceNameVrackNetworkQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError = unknown>(serviceName: string,
    params?: GetIpLoadbalancingServiceNameVrackNetworkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameVrackNetworkQueryKey(serviceName,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>> = ({ signal }) => getIpLoadbalancingServiceNameVrackNetwork(serviceName,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameVrackNetworkQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>>
export type GetIpLoadbalancingServiceNameVrackNetworkQueryError = unknown


export function useGetIpLoadbalancingServiceNameVrackNetwork<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError = unknown>(
 serviceName: string,
    params: undefined |  GetIpLoadbalancingServiceNameVrackNetworkParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackNetwork<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameVrackNetworkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackNetwork<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameVrackNetworkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Descriptions of private networks in the vRack attached to this Load Balancer
 */

export function useGetIpLoadbalancingServiceNameVrackNetwork<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError = unknown>(
 serviceName: string,
    params?: GetIpLoadbalancingServiceNameVrackNetworkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetwork>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameVrackNetworkQueryOptions(serviceName,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add a description of a private network in the attached vRack
 */
export const postIpLoadbalancingServiceNameVrackNetwork = (
    serviceName: string,
    postIpLoadbalancingServiceNameVrackNetworkBody: PostIpLoadbalancingServiceNameVrackNetworkBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackNetworkVrackNetworkOVH>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/network`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameVrackNetworkBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameVrackNetworkMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetwork>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameVrackNetworkBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetwork>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameVrackNetworkBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetwork>>, {serviceName: string;data: PostIpLoadbalancingServiceNameVrackNetworkBody}> = (props) => {
          const {serviceName,data} = props ?? {};

          return  postIpLoadbalancingServiceNameVrackNetwork(serviceName,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameVrackNetworkMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetwork>>>
    export type PostIpLoadbalancingServiceNameVrackNetworkMutationBody = PostIpLoadbalancingServiceNameVrackNetworkBody
    export type PostIpLoadbalancingServiceNameVrackNetworkMutationError = unknown

    /**
 * @summary Add a description of a private network in the attached vRack
 */
export const usePostIpLoadbalancingServiceNameVrackNetwork = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetwork>>, TError,{serviceName: string;data: PostIpLoadbalancingServiceNameVrackNetworkBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetwork>>,
        TError,
        {serviceName: string;data: PostIpLoadbalancingServiceNameVrackNetworkBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameVrackNetworkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete this description of a private network in the vRack. It must not be used by any farm server
 */
export const deleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId = (
    serviceName: string,
    vrackNetworkId: number,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/network/${vrackNetworkId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError,{serviceName: string;vrackNetworkId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError,{serviceName: string;vrackNetworkId: number}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, {serviceName: string;vrackNetworkId: number}> = (props) => {
          const {serviceName,vrackNetworkId} = props ?? {};

          return  deleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId(serviceName,vrackNetworkId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>>
    
    export type DeleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationError = unknown

    /**
 * @summary Delete this description of a private network in the vRack. It must not be used by any farm server
 */
export const useDeleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError,{serviceName: string;vrackNetworkId: number}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>,
        TError,
        {serviceName: string;vrackNetworkId: number},
        TContext
      > => {

      const mutationOptions = getDeleteIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId = (
    serviceName: string,
    vrackNetworkId: number,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackNetworkVrackNetworkOVH>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/network/${vrackNetworkId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdQueryKey = (serviceName: string,
    vrackNetworkId: number,) => {
    return [`/ipLoadbalancing/${serviceName}/vrack/network/${vrackNetworkId}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError = unknown>(serviceName: string,
    vrackNetworkId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdQueryKey(serviceName,vrackNetworkId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>> = ({ signal }) => getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId(serviceName,vrackNetworkId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && vrackNetworkId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>>
export type GetIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdQueryError = unknown


export function useGetIpLoadbalancingServiceNameVrackNetworkVrackNetworkId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError = unknown>(
 serviceName: string,
    vrackNetworkId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackNetworkVrackNetworkId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError = unknown>(
 serviceName: string,
    vrackNetworkId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackNetworkVrackNetworkId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError = unknown>(
 serviceName: string,
    vrackNetworkId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameVrackNetworkVrackNetworkId<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError = unknown>(
 serviceName: string,
    vrackNetworkId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdQueryOptions(serviceName,vrackNetworkId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Alter this object properties
 */
export const putIpLoadbalancingServiceNameVrackNetworkVrackNetworkId = (
    serviceName: string,
    vrackNetworkId: number,
    ipLoadbalancingVrackNetworkVrackNetworkOVH: NonReadonly<IpLoadbalancingVrackNetworkVrackNetworkOVH>,
 options?: SecondParameter<typeof customInstanceV6>,) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/network/${vrackNetworkId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ipLoadbalancingVrackNetworkVrackNetworkOVH
    },
      options);
    }
  


export const getPutIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError,{serviceName: string;vrackNetworkId: number;data: NonReadonly<IpLoadbalancingVrackNetworkVrackNetworkOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError,{serviceName: string;vrackNetworkId: number;data: NonReadonly<IpLoadbalancingVrackNetworkVrackNetworkOVH>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, {serviceName: string;vrackNetworkId: number;data: NonReadonly<IpLoadbalancingVrackNetworkVrackNetworkOVH>}> = (props) => {
          const {serviceName,vrackNetworkId,data} = props ?? {};

          return  putIpLoadbalancingServiceNameVrackNetworkVrackNetworkId(serviceName,vrackNetworkId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationResult = NonNullable<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>>
    export type PutIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationBody = NonReadonly<IpLoadbalancingVrackNetworkVrackNetworkOVH>
    export type PutIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationError = unknown

    /**
 * @summary Alter this object properties
 */
export const usePutIpLoadbalancingServiceNameVrackNetworkVrackNetworkId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>, TError,{serviceName: string;vrackNetworkId: number;data: NonReadonly<IpLoadbalancingVrackNetworkVrackNetworkOVH>}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof putIpLoadbalancingServiceNameVrackNetworkVrackNetworkId>>,
        TError,
        {serviceName: string;vrackNetworkId: number;data: NonReadonly<IpLoadbalancingVrackNetworkVrackNetworkOVH>},
        TContext
      > => {

      const mutationOptions = getPutIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Update farm attached to that vrack network id
 */
export const postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId = (
    serviceName: string,
    vrackNetworkId: number,
    postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody: PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackNetworkVrackNetworkOVH>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/network/${vrackNetworkId}/updateFarmId`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody, signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId>>, TError,{serviceName: string;vrackNetworkId: number;data: PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId>>, TError,{serviceName: string;vrackNetworkId: number;data: PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId>>, {serviceName: string;vrackNetworkId: number;data: PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody}> = (props) => {
          const {serviceName,vrackNetworkId,data} = props ?? {};

          return  postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId(serviceName,vrackNetworkId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId>>>
    export type PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdMutationBody = PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody
    export type PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdMutationError = unknown

    /**
 * @summary Update farm attached to that vrack network id
 */
export const usePostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId>>, TError,{serviceName: string;vrackNetworkId: number;data: PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmId>>,
        TError,
        {serviceName: string;vrackNetworkId: number;data: PostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdBody},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameVrackNetworkVrackNetworkIdUpdateFarmIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Rules to create a network attached to a vrack
 */
export const getIpLoadbalancingServiceNameVrackNetworkCreationRules = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackNetworkCreationRulesOVH>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/networkCreationRules`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameVrackNetworkCreationRulesQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/vrack/networkCreationRules`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameVrackNetworkCreationRulesQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameVrackNetworkCreationRulesQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>> = ({ signal }) => getIpLoadbalancingServiceNameVrackNetworkCreationRules(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameVrackNetworkCreationRulesQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>>
export type GetIpLoadbalancingServiceNameVrackNetworkCreationRulesQueryError = unknown


export function useGetIpLoadbalancingServiceNameVrackNetworkCreationRules<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackNetworkCreationRules<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackNetworkCreationRules<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Rules to create a network attached to a vrack
 */

export function useGetIpLoadbalancingServiceNameVrackNetworkCreationRules<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackNetworkCreationRules>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameVrackNetworkCreationRulesQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Information about vRack for your Load Balancer
 */
export const getIpLoadbalancingServiceNameVrackStatus = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackInformationOVH>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameVrackStatusQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/vrack/status`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameVrackStatusQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameVrackStatusQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>> = ({ signal }) => getIpLoadbalancingServiceNameVrackStatus(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameVrackStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>>
export type GetIpLoadbalancingServiceNameVrackStatusQueryError = unknown


export function useGetIpLoadbalancingServiceNameVrackStatus<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackStatus<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackStatus<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Information about vRack for your Load Balancer
 */

export function useGetIpLoadbalancingServiceNameVrackStatus<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameVrackStatusQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get gateways for configured vrack transparent ip
 */
export const getIpLoadbalancingServiceNameVrackTransparentGateways = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingVrackTransparentGatewaysOVH[]>(
      {url: `/ipLoadbalancing/${serviceName}/vrack/transparent/gateways`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameVrackTransparentGatewaysQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/vrack/transparent/gateways`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameVrackTransparentGatewaysQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameVrackTransparentGatewaysQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>> = ({ signal }) => getIpLoadbalancingServiceNameVrackTransparentGateways(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameVrackTransparentGatewaysQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>>
export type GetIpLoadbalancingServiceNameVrackTransparentGatewaysQueryError = unknown


export function useGetIpLoadbalancingServiceNameVrackTransparentGateways<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackTransparentGateways<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameVrackTransparentGateways<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get gateways for configured vrack transparent ip
 */

export function useGetIpLoadbalancingServiceNameVrackTransparentGateways<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameVrackTransparentGateways>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameVrackTransparentGatewaysQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Zone for this iplb
 */
export const getIpLoadbalancingServiceNameZone = (
    serviceName: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<string[]>(
      {url: `/ipLoadbalancing/${serviceName}/zone`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameZoneQueryKey = (serviceName: string,) => {
    return [`/ipLoadbalancing/${serviceName}/zone`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameZoneQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError = unknown>(serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameZoneQueryKey(serviceName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>> = ({ signal }) => getIpLoadbalancingServiceNameZone(serviceName, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameZoneQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>>
export type GetIpLoadbalancingServiceNameZoneQueryError = unknown


export function useGetIpLoadbalancingServiceNameZone<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError = unknown>(
 serviceName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameZone<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameZone<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Zone for this iplb
 */

export function useGetIpLoadbalancingServiceNameZone<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError = unknown>(
 serviceName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZone>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameZoneQueryOptions(serviceName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get this object properties
 */
export const getIpLoadbalancingServiceNameZoneName = (
    serviceName: string,
    name: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<IpLoadbalancingZoneZoneOVH>(
      {url: `/ipLoadbalancing/${serviceName}/zone/${name}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetIpLoadbalancingServiceNameZoneNameQueryKey = (serviceName: string,
    name: string,) => {
    return [`/ipLoadbalancing/${serviceName}/zone/${name}`] as const;
    }

    
export const getGetIpLoadbalancingServiceNameZoneNameQueryOptions = <TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError = unknown>(serviceName: string,
    name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIpLoadbalancingServiceNameZoneNameQueryKey(serviceName,name);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>> = ({ signal }) => getIpLoadbalancingServiceNameZoneName(serviceName,name, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceName && name), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIpLoadbalancingServiceNameZoneNameQueryResult = NonNullable<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>>
export type GetIpLoadbalancingServiceNameZoneNameQueryError = unknown


export function useGetIpLoadbalancingServiceNameZoneName<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError = unknown>(
 serviceName: string,
    name: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameZoneName<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError = unknown>(
 serviceName: string,
    name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIpLoadbalancingServiceNameZoneName<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError = unknown>(
 serviceName: string,
    name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get this object properties
 */

export function useGetIpLoadbalancingServiceNameZoneName<TData = Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError = unknown>(
 serviceName: string,
    name: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getIpLoadbalancingServiceNameZoneName>>, TError, TData>>, request?: SecondParameter<typeof customInstanceV6>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetIpLoadbalancingServiceNameZoneNameQueryOptions(serviceName,name,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Cancel the termination request of your service zone option
 */
export const postIpLoadbalancingServiceNameZoneNameCancelTermination = (
    serviceName: string,
    name: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/zone/${name}/cancelTermination`, method: 'POST', signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameZoneNameCancelTerminationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameCancelTermination>>, TError,{serviceName: string;name: string}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameCancelTermination>>, TError,{serviceName: string;name: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameCancelTermination>>, {serviceName: string;name: string}> = (props) => {
          const {serviceName,name} = props ?? {};

          return  postIpLoadbalancingServiceNameZoneNameCancelTermination(serviceName,name,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameZoneNameCancelTerminationMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameCancelTermination>>>
    
    export type PostIpLoadbalancingServiceNameZoneNameCancelTerminationMutationError = unknown

    /**
 * @summary Cancel the termination request of your service zone option
 */
export const usePostIpLoadbalancingServiceNameZoneNameCancelTermination = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameCancelTermination>>, TError,{serviceName: string;name: string}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameCancelTermination>>,
        TError,
        {serviceName: string;name: string},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameZoneNameCancelTerminationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Terminate your service zone option
 */
export const postIpLoadbalancingServiceNameZoneNameTerminate = (
    serviceName: string,
    name: string,
 options?: SecondParameter<typeof customInstanceV6>,signal?: AbortSignal
) => {
      
      
      return customInstanceV6<void>(
      {url: `/ipLoadbalancing/${serviceName}/zone/${name}/terminate`, method: 'POST', signal
    },
      options);
    }
  


export const getPostIpLoadbalancingServiceNameZoneNameTerminateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameTerminate>>, TError,{serviceName: string;name: string}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameTerminate>>, TError,{serviceName: string;name: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameTerminate>>, {serviceName: string;name: string}> = (props) => {
          const {serviceName,name} = props ?? {};

          return  postIpLoadbalancingServiceNameZoneNameTerminate(serviceName,name,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostIpLoadbalancingServiceNameZoneNameTerminateMutationResult = NonNullable<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameTerminate>>>
    
    export type PostIpLoadbalancingServiceNameZoneNameTerminateMutationError = unknown

    /**
 * @summary Terminate your service zone option
 */
export const usePostIpLoadbalancingServiceNameZoneNameTerminate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameTerminate>>, TError,{serviceName: string;name: string}, TContext>, request?: SecondParameter<typeof customInstanceV6>}
): UseMutationResult<
        Awaited<ReturnType<typeof postIpLoadbalancingServiceNameZoneNameTerminate>>,
        TError,
        {serviceName: string;name: string},
        TContext
      > => {

      const mutationOptions = getPostIpLoadbalancingServiceNameZoneNameTerminateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
